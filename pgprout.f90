#!/bin/sh
#---------------------------------------------------------------------
cat > temp.c << "EOC"
cat > vmodules.f << "EOF"
      module Vpname1
      use kind_spec
      integer, parameter :: nthpts = 99
      integer, parameter :: nfloops = 40
      integer, parameter :: nbloops = 40
      integer, parameter :: nbsetsp = 2
      integer, parameter :: nbcoilsp = 50
      integer, parameter :: nbrbz_id = 1
      integer, parameter :: nmirnov_id = 2
      integer :: nrt
      real(kind=rprec), parameter :: dmu0 = 1.256637d-06
      end module Vpname1

      module Vpname2
      use kind_spec
      use Vpname1
      integer, dimension(:), allocatable :: ixm, ixn
      integer :: nbrbz, nmirnov,  nmirnovset
      real(kind=rprec), dimension(:), allocatable :: dbzcods, ffp, ub, 
     1   iotaf, darea, iotazb, psi, itors, ipols
      real(kind=rprec), dimension(:), allocatable :: brcoil, plbrfld, 
     1   brbc, bzcoil, plbzfld, bzbc
      real(kind=rprec), dimension(:), allocatable :: sqrt_phimod, 
     1   phimod, dbsubudstz, bsubutz, bsubvtz
      real(kind=rprec) :: itor, ipol
      character   limpos_file*40, gmeta_file*40
      character   cdate*30, runlabel*60
      end module Vpname2

      module Vpname3
      use kind_spec
      integer, parameter :: nlimd = 50
      integer, parameter :: nlimset = 2
      integer, parameter :: nltot = nlimd*nlimset
      integer, parameter :: ndim1 = 100
      integer, parameter :: n2max = 40
      integer, parameter :: nsetsmax = 13
      integer :: initnml = 0, ltouch
      integer, dimension(nsetsmax) :: ipset
      real(kind=rprec) :: rx1sv, rx2sv, zy1sv, zy2sv, condifsv
      character :: tokid1*20
      integer :: nrgridsv, nzgridsv
      real(kind=rprec), dimension(ndim1) :: rgrid, zgrid
      real(kind=rprec), dimension(:,:), allocatable :: pfltot
      real(kind=rprec), dimension(:,:,:), allocatable :: pflcoilgr
      real(kind=rprec), dimension(nlimd,nlimset) :: xlim, ylim
      real(kind=rprec), dimension(nltot) :: xlimt, ylimt, seplimt
      integer :: nrgrid_17 = 60, nzgrid_17 = 60, 
     1           nrgrid_18 = 60, nzgrid_18 = 60
      real(kind=rprec) :: rx1_17 = 1.5, rx2_17 = 4.0, zy1_17 = -1.40, 
     1        zy2_17 = 1.40,
     1        rx1_18 = 0.6, rx2_18 = 5.0, zy1_18 = -2.88, zy2_18 = 2.88
      end module Vpname3

      module Vindat2
      use kind_spec
      integer   mn0
      real(kind=rprec) :: hs, ohs, twopi
      end module Vindat2

      module Vmagaxis
      use kind_spec
      real(kind=rprec) :: rmagaxis, zmagaxis
      end module Vmagaxis

      module Vplotdata
      use kind_spec
      integer :: ndata, j1
      integer, parameter :: iselect = 2 
      real, parameter :: lx1 = 0.10
      real, parameter :: lx2 = 0.50
      real, parameter :: lx3 = 0.50
      real, parameter :: lx4 = 0.90
      real, parameter :: ly1 = 0.10
      real, parameter :: ly2 = 0.50
      real, parameter :: ly3 = 0.50
      real, parameter :: ly4 = 0.90
      real, dimension(4,5) :: gwnd
      real, dimension(100) :: rdata, pldata

      data (gwnd(j1,1),j1=1,4) / lx1, lx2, ly3, ly4 /
      data (gwnd(j1,2),j1=1,4) / lx3, lx4, ly3, ly4 /
      data (gwnd(j1,3),j1=1,4) / lx1, lx2, ly1, ly2 /
      data (gwnd(j1,4),j1=1,4) / lx3, lx4, ly1, ly2 /
      data (gwnd(j1,5),j1=1,4) / lx1, lx4, ly1, ly4 / 

      end module Vplotdata

      module Vpltcn2
      use kind_spec
      real(kind=rprec) :: rmin, rmax, zmin, zmax
      end module Vpltcn2
      module pgplotinc
C-----------------------------------------------------------------------
C This module is simply a copy of pgplot.inc from version 5.2
C This module may need updating with future releases of PGPLOT
C Contents used for basic coordinate conversions, e.g., xyitoxys
C Ed Lazarus
C-----------------------------------------------------------------------
C PGPLOT: common block definition.
C-----------------------------------------------------------------------
C Maximum number of concurrent devices (should match GRIMAX).
C-----------------------------------------------------------------------
      INTEGER PGMAXD
      PARAMETER (PGMAXD=8)
C-----------------------------------------------------------------------
C Indentifier of currently selected device.
C-----------------------------------------------------------------------
      INTEGER PGID
C-----------------------------------------------------------------------
C Device status (indexed by device identifier).
C-----------------------------------------------------------------------
C PGDEVS  =0 if device is not open; 1 if device is open.
C PGADVS  Set to 0 by PGBEGIN, set to 1 by PGPAGE; used to suppress
C         the prompt for the first page.
C PROMPT  If .TRUE., ask user before clearing page; set by PGASK
C         and (indirectly) by PGBEGIN, used in PGENV.
C PGBLEV  Buffering level: incremented by PGBBUF, decremented by
C         PGEBUF.
C PGPFIX  TRUE if PGPAP has been called, FALSE otherwise.
C
      INTEGER PGDEVS(PGMAXD), PGADVS(PGMAXD), PGBLEV(PGMAXD)
      LOGICAL PGPRMP(PGMAXD), PGPFIX(PGMAXD)
C-----------------------------------------------------------------------
C Panel parameters (indexed by device identification).
C-----------------------------------------------------------------------
C NX      Number of panels in x direction
C NY      Number of panels in y direction
C NXC     Ordinal number of current X panel
C NYC     Ordinal number of current Y panel
C XSZ     X dimension of panel (device units)
C YSZ     Y dimension of panel (device units)
C PGROWS  TRUE if panels are used in row order, FALSE for column
C         order.
C
      INTEGER PGNX  (PGMAXD), PGNY  (PGMAXD)
      INTEGER PGNXC (PGMAXD), PGNYC (PGMAXD)
      REAL    PGXSZ (PGMAXD), PGYSZ (PGMAXD)
      LOGICAL PGROWS(PGMAXD)
C-----------------------------------------------------------------------
C Attributes (indexed by device identification).
C-----------------------------------------------------------------------
C PGCLP   clipping enabled/disabed
C PGFAS   fill-area style
C PGCHSZ  character height
C PGAHS   arrow-head fill style
C PGAHA   arrow-head angle
C PGAHV   arrow-head vent
C PGTBCI  text background color index
C PGMNCI  lower range of color indices available to PGGRAY/PGIMAG
C PGMXCI  upper range of color indices available to PGGRAY/PGIMAG
C PGITF   type of transfer function used by PGGRAY/PGIMAG
C PGHSA   hatching line angle
C PGHSS   hatching line separation
C PGHSP   hatching line phase
C
      INTEGER PGCLP (PGMAXD)
      INTEGER PGFAS (PGMAXD)
      REAL    PGCHSZ(PGMAXD)
      INTEGER PGAHS (PGMAXD)
      REAL    PGAHA (PGMAXD)
      REAL    PGAHV (PGMAXD)
      INTEGER PGTBCI(PGMAXD)
      INTEGER PGMNCI(PGMAXD)
      INTEGER PGMXCI(PGMAXD)
      INTEGER PGITF (PGMAXD)
      REAL    PGHSA (PGMAXD)
      REAL    PGHSS (PGMAXD)
      REAL    PGHSP (PGMAXD)
C-----------------------------------------------------------------------
C Viewport parameters (indexed by device identification); all are device
C coordinates:
C-----------------------------------------------------------------------
C PGXOFF  X coordinate of blc of viewport.
C PGYOFF  Y coordinate of blc of viewport.
C PGXVP   X coordinate of blc of viewport, relative to blc of subpage.
C PGYVP   Y coordinate of blc of viewport, relative to blc of subpage.
C PGXLEN  Width of viewport. 
C PGYLEN  Height of viewport.
C
      REAL   PGXOFF(PGMAXD), PGYOFF(PGMAXD)
      REAL   PGXVP (PGMAXD), PGYVP (PGMAXD)
      REAL   PGXLEN(PGMAXD), PGYLEN(PGMAXD)
C-----------------------------------------------------------------------
C Scaling parameters (indexed by device identification):
C-----------------------------------------------------------------------
C PGXORG  device coordinate value corresponding to world X=0
C PGYORG  device coordinate value corresponding to world Y=0
C PGXSCL  scale in x (device units per world coordinate unit)
C PGYSCL  scale in y (device units per world coordinate unit)
C PGXPIN  device x scale in device units/inch
C PGYPIN  device y scale in device units/inch
C PGXSP   Character X spacing (device units)
C PGYSP   Character Y spacing (device units)
C
      REAL   PGXORG(PGMAXD), PGYORG(PGMAXD)
      REAL   PGXSCL(PGMAXD), PGYSCL(PGMAXD)
      REAL   PGXPIN(PGMAXD), PGYPIN(PGMAXD)
      REAL   PGXSP (PGMAXD), PGYSP (PGMAXD)
C-----------------------------------------------------------------------
C Window parameters (indexed by device identification); all are world
C coordinate values:
C-----------------------------------------------------------------------
C PGXBLC  world X at bottom left corner of window
C PGXTRC  world X at top right corner of window
C PGYBLC  world Y at bottom left corner of window
C PGYTRC  world Y at top right corner of window
C
      REAL    PGXBLC(PGMAXD), PGXTRC(PGMAXD)
      REAL    PGYBLC(PGMAXD), PGYTRC(PGMAXD)
C-----------------------------------------------------------------------
C The following parameters are used in the contouring routines to pass
C information to the action routine. They do not need to be indexed.
C-----------------------------------------------------------------------
C TRANS   Transformation matrix for contour plots; copied
C         from argument list by PGCONT and used by PGCP.
C
      INTEGER PGCINT, PGCMIN
      REAL    TRANS(6)
      CHARACTER*32 PGCLAB
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
      COMMON/PGPLT1/ PGID,PGDEVS,PGADVS,PGNX,  PGNY,  PGNXC, PGNYC ,
     1        PGXPIN,PGYPIN,PGXSP, PGYSP, PGXSZ, PGYSZ,
     2        PGXOFF,PGYOFF,PGXVP, PGYVP, PGXLEN,PGYLEN,PGXORG,PGYORG,
     3        PGXSCL,PGYSCL,PGXBLC,PGXTRC,PGYBLC,PGYTRC,TRANS,
     4        PGPRMP,PGCLP, PGFAS, PGCHSZ,PGBLEV,PGROWS,
     5        PGAHS, PGAHA, PGAHV, PGTBCI,PGMNCI,PGMXCI,PGCINT,PGCMIN,
     6        PGPFIX,PGITF, PGHSA, PGHSS, PGHSP
      COMMON/PGPLT2/ PGCLAB
      SAVE    /PGPLT1/
      SAVE    /PGPLT2/
C-----------------------------------------------------------------------
      end module pgplotinc
      module grpckg1inc

C-----------------------------------------------------------------------
C      From PGPLOT V5.2 -- Be sure this is up-to-date
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C            Include file for GRPCKG
C Modifications:
C   29-Jan-1985 - add HP2648 (KS/TJP).
C   16-Sep-1985 - remove tabs (TJP).
C   30-Dec-1985 - add PS, VPS (TJP).
C   27-May-1987 - remove ARGS, NULL, PS, VPS, QMS, VQMS, HIDMP,
C                 HP7221, GRINL (TJP).
C    6-Jun-1987 - remove PRTX, TRILOG, VERS, VV (TJP).
C   11-Jun-1987 - remove remaining built-in devices (TJP).
C    5-Jul-1987 - replace GRINIT, GRPLTD by GRSTAT.
C   16-Aug-1987 - remove obsolete variables.
C    9-Sep-1989 - add SAVE statement.
C   26-Nov-1990 - remove GRCTYP.
C    5-Jan-1993 - add GRADJU.
C    1-Sep-1994 - add GRGCAP.
C   21-Dec-1995 - increase GRIMAX to 8.
C   30-Apr-1997 - remove GRC{XY}SP
C-----------------------------------------------------------------------
C
C Parameters:
C   GRIMAX : maximum number of concurrent devices
C   GRFNMX : maximum length of file names
C   GRCXSZ : default width of chars (pixels)
C   GRCYSZ : default height of chars (pixels)
C
      INTEGER   GRIMAX, GRFNMX
      REAL      GRCXSZ, GRCYSZ
      PARAMETER (GRIMAX = 8)
      PARAMETER (GRFNMX = 90)
      PARAMETER (GRCXSZ =  7.0, GRCYSZ =  9.0)
C
C Common blocks:
C   GRCIDE : identifier of current plot
C   GRGTYP : device type of current plot
C The following are qualified by a plot id:
C   GRSTAT : 0 => workstation closed
C            1 => workstation open
C            2 => picture open
C   GRPLTD :
C   GRDASH : software dashing in effect?
C   GRUNIT : unit associated with id
C   GRFNLN : length of filename
C   GRTYPE : device type
C   GRXMXA : x size of plotting surface
C   GRYMXA : y size of plotting surface
C   GRXMIN : blc of plotting window
C   GRYMIN : ditto
C   GRXMAX : trc of plotting window
C   GRYMAX : ditto
C   GRSTYL : line style (integer code)
C   GRWIDT : line width (integer code)
C   GRCCOL : current color index (integer code)
C   GRMNCI : minimum color index on this device
C   GRMXCI : maximum color index on this device
C   GRCMRK : marker number
C   GRXPRE : previous (current) pen position (x)
C   GRYPRE : ditto (y)
C   GRXORG : transformation variables (GRTRAN)
C   GRYORG : ditto
C   GRXSCL : ditto
C   GRYSCL : ditto
C   GRCSCL : character scaling factor
C   GRCFAC :
C   GRCFNT : character font
C   GRFILE : file name (character)
C   GRGCAP : device capabilities (character)
C   GRPXPI : pixels per inch in x
C   GRPYPI : pixels per inch in y
C   GRADJU : TRUE if GRSETS (PGPAP) has been called
C
      INTEGER   GRCIDE, GRGTYP
      LOGICAL   GRPLTD(GRIMAX), GRDASH(GRIMAX), GRADJU(GRIMAX)
      INTEGER   GRSTAT(GRIMAX)
      INTEGER   GRUNIT(GRIMAX), GRFNLN(GRIMAX), GRTYPE(GRIMAX),
     1          GRXMXA(GRIMAX), GRYMXA(GRIMAX), 
     2          GRSTYL(GRIMAX), GRWIDT(GRIMAX), GRCCOL(GRIMAX),
     3          GRCMRK(GRIMAX), GRIPAT(GRIMAX), GRCFNT(GRIMAX),
     4          GRMNCI(GRIMAX), GRMXCI(GRIMAX)
      REAL      GRXMIN(GRIMAX), GRYMIN(GRIMAX),
     1          GRXMAX(GRIMAX), GRYMAX(GRIMAX)
      REAL      GRXPRE(GRIMAX), GRYPRE(GRIMAX), GRXORG(GRIMAX),
     1          GRYORG(GRIMAX), GRXSCL(GRIMAX), GRYSCL(GRIMAX),
     2          GRCSCL(GRIMAX), GRCFAC(GRIMAX), GRPOFF(GRIMAX),
     3          GRPATN(GRIMAX,8),GRPXPI(GRIMAX),GRPYPI(GRIMAX)
      COMMON /GRCM00/ GRCIDE, GRGTYP, GRSTAT, GRPLTD, GRUNIT,
     1                GRFNLN, GRTYPE, GRXMXA, GRYMXA, GRXMIN, GRYMIN,
     2                GRXMAX, GRYMAX, GRWIDT, GRCCOL, GRSTYL,
     3                GRXPRE, GRYPRE, GRXORG, GRYORG, GRXSCL, GRYSCL,
     4                GRCSCL, GRCFAC, GRDASH, GRPATN, GRPOFF,
     5                GRIPAT, GRCFNT, GRCMRK, GRPXPI, GRPYPI, GRADJU,
     6                GRMNCI, GRMXCI
C
      CHARACTER*(GRFNMX) GRFILE(GRIMAX)
      CHARACTER*11       GRGCAP(GRIMAX)
      COMMON /GRCM01/ GRFILE, GRGCAP
      SAVE /GRCM00/, /GRCM01/
C-----------------------------------------------------------------------
      end module grpckg1inc


      module Vpltcn6
      integer   lxc, lyc, noxc, noyc
      contains
       subroutine newframe
       use pgplotinc, only: pgnxc,pgnyc,pgnx,pgny
       pgnxc=pgnx
       pgnyc=pgny
       return
       end subroutine newframe
      end module Vpltcn6

      module Vrzarray
      use kind_spec
      real(kind=rprec), dimension(:), allocatable :: r, z
      real(kind=rprec), dimension(:), allocatable :: ru, zu
      end module Vrzarray

      module Vtraneq
      use kind_spec
      integer, parameter :: maxmom = 20
      integer, parameter :: maxpsi = 502
      integer, parameter :: maxtht = 502
      integer, parameter :: maxord = 10
      integer   itype, ieqedg, numtht, intord, ieqax, mombnd, nequil, 
     1   nstep, njav, mom, ncycle, irun, isyms, ipest, npsit, kmax
      real(kind=rprec), dimension(maxmom) :: rmb, ymb
      real(kind=rprec), dimension(maxpsi) :: psi, press, dpdpsi, q, 
     1 dqdpsi, g, ggp, ainvrs
      real(kind=rprec), dimension(maxtht) :: xbound, zbound
      real(kind=rprec) :: zlowp, zlowq, zlowps, zcycp, zcycq, zcycps, 
     1   pfilt1, pfilt2, pfilt3, r0b, shotnm, runum, time, btor, rtor, 
     2   eqcamp, times, xaxes, zmags, gzeros, apls, betas, betaps, 
     3   ali2s, qsaws, psimins, psilims
      character   thdfil*80, flnmi1*80, flnmo1*80
      real(kind=rprec), dimension(maxpsi) :: jdotbc
      real(kind=rprec) :: batot, bapol, bator, baxis
      end module Vtraneq


      module Vcpmpcm1
      integer, parameter :: ntmax = 101
      real, dimension(ntmax) :: comxi, comyj
      end module Vcpmpcm1

      module Vcpmpcm2
      real, dimension(:,:), allocatable :: comxij, comyij
      end module Vcpmpcm2

      module Vcpmpinf
      integer   mxdim, nydim
      end module Vcpmpinf

      module Vthrint
      integer   ithrmj, ithrmn, ithrtx
      end module Vthrint
      module Toexternal
      use kind_spec
      integer, parameter :: nxcnt=50
      real(kind=rprec),parameter :: pi = 3.141592654_rprec
      real :: contrs(nxcnt)
      character*20 :: labelformat
      integer:: lcontr(nxcnt),kbold(nxcnt),klabel(nxcnt),ncont
      data lcontr/nxcnt*0/,kbold/nxcnt*0/,klabel/nxcnt*0/
      common/passtoexternal/contrs,lcontr,kbold,klabel,ncont,labelformat
      integer :: mxnt
      real(kind=rprec)   :: phit
      common /pass_plot_info/ phit, mxnt
      end module Toexternal

#ifdef OSF1
      module decdebug
      external fdate, getenv, ttynam ,isatty
      logical isatty, thisone
      integer walltim,strttim
      character*24 fdate ,ctty ,datebuf ,tty
       contains
       subroutine decdebugset
        datebuf=fdate()
        write(*,fmt='(a)')datebuf
        thisone=isatty(6)
        if(thisone) then
          call getenv('TTY',ctty)
          tty='/dev/' // ctty
          open  (unit = 5, file = tty , status = 'UNKNOWN')
          open  (unit = 6, file = tty , status = 'UNKNOWN')
        endif
! the write of datbuf seems necessary to get isatty and ttynam to work
!!!!!!!!!! the above gets ladebug to accept input 
       end subroutine decdebugset
      end module decdebug
#endif

      module coltabs
C-----------------------------------------------------------------------
C This module is used by PGXTAL 3-D routines and is simply a copy of
C COLTABS.INC from that distribution -- may need updating, but doubtful.
C-----------------------------------------------------------------------

c `````````````````        include 'coltabs.inc'   ```````````````````
      real bgyrw(3,256),heat(3,256),spectrum(3,256),serp(3,256)
      real rcol(256),bcol(256),gcol(256)
c
      data bgyrw /0.0,0.0,0.0,0.00,0.0000,0.0195,0.0000,0.0000,0.0391,
     * 0.0000,0.0000,0.0586,0.0000,0.0000,0.0781,0.0000,0.0000,0.0977,
     * 0.0000,0.0000,0.1172,0.0000,0.0000,0.1367,0.0000,0.0000,0.1563,
     * 0.0000,0.0000,0.1758,0.0000,0.0000,0.1992,0.0000,0.0000,0.2188,
     * 0.0000,0.0000,0.2383,0.0000,0.0000,0.2578,0.0000,0.0000,0.2773,
     * 0.0000,0.0000,0.2969,0.0000,0.0000,0.3164,0.0000,0.0000,0.3359,
     * 0.0000,0.0000,0.3555,0.0000,0.0000,0.3750,0.0000,0.0000,0.3984,
     * 0.0000,0.0000,0.4180,0.0000,0.0000,0.4375,0.0000,0.0000,0.4570,
     * 0.0000,0.0000,0.4766,0.0000,0.0000,0.4961,0.0000,0.0000,0.5156,
     * 0.0000,0.0000,0.5352,0.0000,0.0000,0.5547,0.0000,0.0000,0.5742,
     * 0.0000,0.0000,0.5977,0.0000,0.0000,0.6172,0.0000,0.0000,0.6367,
     * 0.0000,0.0000,0.6563,0.0000,0.0000,0.6758,0.0000,0.0000,0.6953,
     * 0.0000,0.0000,0.7148,0.0000,0.0000,0.7344,0.0000,0.0000,0.7539,
     * 0.0000,0.0000,0.7734,0.0000,0.0000,0.7969,0.0000,0.0000,0.8164,
     * 0.0000,0.0000,0.8359,0.0000,0.0000,0.8555,0.0000,0.0000,0.8750,
     * 0.0000,0.0000,0.8945,0.0000,0.0000,0.9141,0.0000,0.0000,0.9336,
     * 0.0000,0.0000,0.9531,0.0000,0.0000,0.9727,0.0000,0.0000,0.9961,
     * 0.0000,0.0156,0.9961,0.0000,0.0469,0.9961,0.0000,0.0781,0.9961,
     * 0.0000,0.0938,0.9961,0.0000,0.1250,0.9961,0.0000,0.1563,0.9961,
     * 0.0000,0.1719,0.9961,0.0000,0.2031,0.9961,0.0000,0.2344,0.9961,
     * 0.0000,0.2656,0.9961,0.0000,0.2813,0.9961,0.0000,0.3125,0.9961,
     * 0.0000,0.3438,0.9961,0.0000,0.3594,0.9961,0.0000,0.3906,0.9961,
     * 0.0000,0.4219,0.9961,0.0000,0.4375,0.9961,0.0000,0.4688,0.9961,
     * 0.0000,0.5000,0.9961,0.0000,0.5313,0.9961,0.0000,0.5469,0.9961,
     * 0.0000,0.5781,0.9961,0.0000,0.6094,0.9961,0.0000,0.6250,0.9961,
     * 0.0000,0.6563,0.9961,0.0000,0.6875,0.9961,0.0000,0.7031,0.9961,
     * 0.0000,0.7344,0.9961,0.0000,0.7656,0.9961,0.0000,0.7969,0.9961,
     * 0.0000,0.8125,0.9961,0.0000,0.8438,0.9961,0.0000,0.8750,0.9961,
     * 0.0000,0.8906,0.9961,0.0000,0.9219,0.9961,0.0000,0.9531,0.9961,
     * 0.0000,0.9688,0.9961,0.0000,0.9961,0.9844,0.0000,0.9961,0.9531,
     * 0.0000,0.9961,0.9219,0.0000,0.9961,0.9063,0.0000,0.9961,0.8750,
     * 0.0000,0.9961,0.8438,0.0000,0.9961,0.8281,0.0000,0.9961,0.7969,
     * 0.0000,0.9961,0.7656,0.0000,0.9961,0.7500,0.0000,0.9961,0.7188,
     * 0.0000,0.9961,0.6875,0.0000,0.9961,0.6563,0.0000,0.9961,0.6406,
     * 0.0000,0.9961,0.6094,0.0000,0.9961,0.5781,0.0000,0.9961,0.5625,
     * 0.0000,0.9961,0.5313,0.0000,0.9961,0.5000,0.0000,0.9961,0.4844,
     * 0.0000,0.9961,0.4531,0.0000,0.9961,0.4219,0.0000,0.9961,0.3906,
     * 0.0000,0.9961,0.3750,0.0000,0.9961,0.3438,0.0000,0.9961,0.3125,
     * 0.0000,0.9961,0.2969,0.0000,0.9961,0.2656,0.0000,0.9961,0.2344,
     * 0.0000,0.9961,0.2188,0.0000,0.9961,0.1875,0.0000,0.9961,0.1563,
     * 0.0000,0.9961,0.1250,0.0000,0.9961,0.1094,0.0000,0.9961,0.0781,
     * 0.0000,0.9961,0.0469,0.0000,0.9961,0.0313,0.0000,0.9961,0.0000,
     * 0.0156,0.9961,0.0000,0.0313,0.9961,0.0000,0.0625,0.9961,0.0000,
     * 0.0938,0.9961,0.0000,0.1250,0.9961,0.0000,0.1406,0.9961,0.0000,
     * 0.1719,0.9961,0.0000,0.2031,0.9961,0.0000,0.2188,0.9961,0.0000,
     * 0.2500,0.9961,0.0000,0.2813,0.9961,0.0000,0.2969,0.9961,0.0000,
     * 0.3281,0.9961,0.0000,0.3594,0.9961,0.0000,0.3906,0.9961,0.0000,
     * 0.4063,0.9961,0.0000,0.4375,0.9961,0.0000,0.4688,0.9961,0.0000,
     * 0.4844,0.9961,0.0000,0.5156,0.9961,0.0000,0.5469,0.9961,0.0000,
     * 0.5625,0.9961,0.0000,0.5938,0.9961,0.0000,0.6250,0.9961,0.0000,
     * 0.6563,0.9961,0.0000,0.6719,0.9961,0.0000,0.7031,0.9961,0.0000,
     * 0.7344,0.9961,0.0000,0.7500,0.9961,0.0000,0.7813,0.9961,0.0000,
     * 0.8125,0.9961,0.0000,0.8281,0.9961,0.0000,0.8594,0.9961,0.0000,
     * 0.8906,0.9961,0.0000,0.9219,0.9961,0.0000,0.9375,0.9961,0.0000,
     * 0.9688,0.9961,0.0000,0.9961,0.9844,0.0000,0.9961,0.9688,0.0000,
     * 0.9961,0.9375,0.0000,0.9961,0.9063,0.0000,0.9961,0.8906,0.0000,
     * 0.9961,0.8594,0.0000,0.9961,0.8281,0.0000,0.9961,0.7969,0.0000,
     * 0.9961,0.7813,0.0000,0.9961,0.7500,0.0000,0.9961,0.7188,0.0000,
     * 0.9961,0.7031,0.0000,0.9961,0.6719,0.0000,0.9961,0.6406,0.0000,
     * 0.9961,0.6250,0.0000,0.9961,0.5938,0.0000,0.9961,0.5625,0.0000,
     * 0.9961,0.5313,0.0000,0.9961,0.5156,0.0000,0.9961,0.4844,0.0000,
     * 0.9961,0.4531,0.0000,0.9961,0.4375,0.0000,0.9961,0.4063,0.0000,
     * 0.9961,0.3750,0.0000,0.9961,0.3594,0.0000,0.9961,0.3281,0.0000,
     * 0.9961,0.2969,0.0000,0.9961,0.2656,0.0000,0.9961,0.2500,0.0000,
     * 0.9961,0.2188,0.0000,0.9961,0.1875,0.0000,0.9961,0.1719,0.0000,
     * 0.9961,0.1406,0.0000,0.9961,0.1094,0.0000,0.9961,0.0938,0.0000,
     * 0.9961,0.0625,0.0000,0.9961,0.0313,0.0000,0.9961,0.0000,0.0000,
     * 0.9961,0.0000,0.0000,0.9961,0.0000,0.0000,0.9961,0.0000,0.0000,
     * 0.9961,0.0000,0.0000,0.9961,0.0000,0.0000,0.9961,0.0000,0.0000,
     * 0.9961,0.0000,0.0000,0.9961,0.0000,0.0000,0.9961,0.0000,0.0000,
     * 0.9961,0.0000,0.0000,0.9961,0.0000,0.0000,0.9961,0.0000,0.0000,
     * 0.9961,0.0000,0.0000,0.9961,0.0000,0.0000,0.9961,0.0000,0.0000,
     * 0.9961,0.0000,0.0000,0.9961,0.0000,0.0000,0.9961,0.0000,0.0000,
     * 0.9961,0.0000,0.0000,0.9961,0.0000,0.0000,0.9961,0.0273,0.0273,
     * 0.9961,0.0547,0.0547,0.9961,0.0820,0.0820,0.9961,0.1133,0.1133,
     * 0.9961,0.1406,0.1406,0.9961,0.1680,0.1680,0.9961,0.1992,0.1992,
     * 0.9961,0.2266,0.2266,0.9961,0.2539,0.2539,0.9961,0.2813,0.2813,
     * 0.9961,0.3125,0.3125,0.9961,0.3398,0.3398,0.9961,0.3672,0.3672,
     * 0.9961,0.3984,0.3984,0.9961,0.4258,0.4258,0.9961,0.4531,0.4531,
     * 0.9961,0.4805,0.4805,0.9961,0.5117,0.5117,0.9961,0.5391,0.5391,
     * 0.9961,0.5664,0.5664,0.9961,0.5977,0.5977,0.9961,0.6250,0.6250,
     * 0.9961,0.6523,0.6523,0.9961,0.6797,0.6797,0.9961,0.7109,0.7109,
     * 0.9961,0.7383,0.7383,0.9961,0.7656,0.7656,0.9961,0.7969,0.7969,
     * 0.9961,0.8242,0.8242,0.9961,0.8516,0.8516,0.9961,0.8789,0.8789,
     * 0.9961,0.9102,0.9102,0.9961,0.9375,0.9375,0.9961,0.9648,0.9648,
     * 0.9961,0.9961,0.9961/
c
      data heat /0.0,0.0,0.0,0.000,0.0000,0.0000,0.0000,0.0000,0.0000,
     * 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     * 0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,
     * 0.0000,0.0000,0.0000,0.0195,0.0000,0.0195,0.0391,0.0000,0.0391,
     * 0.0586,0.0000,0.0586,0.0781,0.0000,0.0781,0.1016,0.0000,0.1016,
     * 0.1211,0.0000,0.1211,0.1406,0.0000,0.1406,0.1602,0.0000,0.1602,
     * 0.1797,0.0000,0.1797,0.1992,0.0000,0.1992,0.2188,0.0000,0.2188,
     * 0.2383,0.0000,0.2383,0.2578,0.0000,0.2578,0.2773,0.0000,0.2773,
     * 0.3008,0.0000,0.3008,0.3203,0.0000,0.3203,0.3398,0.0000,0.3398,
     * 0.3594,0.0000,0.3594,0.3789,0.0000,0.3789,0.3984,0.0000,0.3984,
     * 0.4180,0.0000,0.4180,0.4375,0.0000,0.4375,0.4570,0.0000,0.4570,
     * 0.4766,0.0000,0.4766,0.5000,0.0000,0.5000,0.5195,0.0000,0.5195,
     * 0.5391,0.0000,0.5391,0.5586,0.0000,0.5586,0.5781,0.0000,0.5781,
     * 0.5977,0.0000,0.5977,0.6172,0.0000,0.6172,0.6367,0.0000,0.6367,
     * 0.6563,0.0000,0.6563,0.6758,0.0000,0.6758,0.6992,0.0000,0.6992,
     * 0.7188,0.0000,0.7188,0.7383,0.0000,0.7383,0.7578,0.0000,0.7578,
     * 0.7773,0.0000,0.7773,0.7969,0.0000,0.7969,0.8164,0.0000,0.8164,
     * 0.8359,0.0000,0.8359,0.8555,0.0000,0.8555,0.8750,0.0000,0.8750,
     * 0.8984,0.0000,0.8984,0.9375,0.0000,0.9180,0.9766,0.0000,0.9375,
     * 0.9961,0.0000,0.9570,0.9961,0.0000,0.9766,0.9961,0.0000,0.9961,
     * 0.9961,0.0000,0.9766,0.9961,0.0000,0.9570,0.9961,0.0000,0.9375,
     * 0.9961,0.0000,0.9180,0.9961,0.0000,0.8984,0.9961,0.0000,0.8750,
     * 0.9961,0.0000,0.8555,0.9961,0.0000,0.8359,0.9961,0.0000,0.8164,
     * 0.9961,0.0000,0.7969,0.9961,0.0000,0.7773,0.9961,0.0000,0.7578,
     * 0.9961,0.0000,0.7383,0.9961,0.0000,0.7188,0.9961,0.0000,0.6992,
     * 0.9961,0.0000,0.6758,0.9961,0.0000,0.6563,0.9961,0.0000,0.6367,
     * 0.9961,0.0000,0.6172,0.9961,0.0000,0.5977,0.9961,0.0000,0.5781,
     * 0.9961,0.0000,0.5586,0.9961,0.0000,0.5391,0.9961,0.0000,0.5195,
     * 0.9961,0.0000,0.5000,0.9961,0.0000,0.4766,0.9961,0.0000,0.4570,
     * 0.9961,0.0000,0.4375,0.9961,0.0000,0.4180,0.9961,0.0000,0.3984,
     * 0.9961,0.0000,0.3789,0.9961,0.0000,0.3594,0.9961,0.0000,0.3398,
     * 0.9961,0.0000,0.3203,0.9961,0.0000,0.3008,0.9961,0.0000,0.2773,
     * 0.9961,0.0000,0.2578,0.9961,0.0000,0.2383,0.9961,0.0000,0.2188,
     * 0.9961,0.0000,0.1992,0.9961,0.0000,0.1797,0.9961,0.0117,0.1602,
     * 0.9961,0.0195,0.1406,0.9961,0.0313,0.1211,0.9961,0.0391,0.0000,
     * 0.9961,0.0508,0.0781,0.9961,0.0586,0.0586,0.9961,0.0703,0.0391,
     * 0.9961,0.0781,0.0195,0.9961,0.0898,0.0000,0.9961,0.1016,0.0000,
     * 0.9961,0.1094,0.0000,0.9961,0.1211,0.0000,0.9961,0.1289,0.0000,
     * 0.9961,0.1406,0.0000,0.9961,0.1484,0.0000,0.9961,0.1602,0.0000,
     * 0.9961,0.1719,0.0000,0.9961,0.1797,0.0000,0.9961,0.1914,0.0000,
     * 0.9961,0.1992,0.0000,0.9961,0.2109,0.0000,0.9961,0.2188,0.0000,
     * 0.9961,0.2305,0.0000,0.9961,0.2383,0.0000,0.9961,0.2500,0.0000,
     * 0.9961,0.2617,0.0000,0.9961,0.2695,0.0000,0.9961,0.2813,0.0000,
     * 0.9961,0.2891,0.0000,0.9961,0.3008,0.0000,0.9961,0.3086,0.0000,
     * 0.9961,0.3203,0.0000,0.9961,0.3281,0.0000,0.9961,0.3398,0.0000,
     * 0.9961,0.3516,0.0000,0.9961,0.3594,0.0000,0.9961,0.3711,0.0000,
     * 0.9961,0.3789,0.0000,0.9961,0.3906,0.0000,0.9961,0.3984,0.0000,
     * 0.9961,0.4102,0.0000,0.9961,0.4219,0.0000,0.9961,0.4297,0.0000,
     * 0.9961,0.4414,0.0000,0.9961,0.4492,0.0000,0.9961,0.4609,0.0000,
     * 0.9961,0.4688,0.0000,0.9961,0.4805,0.0000,0.9961,0.4883,0.0000,
     * 0.9961,0.5195,0.0000,0.9961,0.5273,0.0000,0.9961,0.5391,0.0000,
     * 0.9961,0.5469,0.0000,0.9961,0.5625,0.0000,0.9961,0.5703,0.0000,
     * 0.9961,0.5820,0.0000,0.9961,0.5898,0.0000,0.9961,0.6016,0.0000,
     * 0.9961,0.6094,0.0000,0.9961,0.6172,0.0000,0.9961,0.6289,0.0000,
     * 0.9961,0.6367,0.0000,0.9961,0.6484,0.0000,0.9961,0.6602,0.0000,
     * 0.9961,0.6719,0.0000,0.9961,0.6797,0.0000,0.9961,0.6875,0.0000,
     * 0.9961,0.6992,0.0000,0.9961,0.7070,0.0000,0.9961,0.7188,0.0000,
     * 0.9961,0.7266,0.0000,0.9961,0.7383,0.0000,0.9961,0.7461,0.0000,
     * 0.9961,0.7617,0.0000,0.9961,0.7695,0.0000,0.9961,0.7773,0.0000,
     * 0.9961,0.7891,0.0000,0.9961,0.7969,0.0000,0.9961,0.8086,0.0000,
     * 0.9961,0.8164,0.0000,0.9961,0.8281,0.0000,0.9961,0.8359,0.0000,
     * 0.9961,0.8477,0.0000,0.9961,0.8594,0.0000,0.9961,0.8672,0.0000,
     * 0.9961,0.8789,0.0000,0.9961,0.8867,0.0000,0.9961,0.8984,0.0000,
     * 0.9961,0.9063,0.0000,0.9961,0.9180,0.0000,0.9961,0.9258,0.0000,
     * 0.9961,0.9688,0.0156,0.9961,0.9961,0.0352,0.9961,0.9961,0.0508,
     * 0.9961,0.9961,0.0664,0.9961,0.9961,0.0820,0.9961,0.9961,0.1016,
     * 0.9961,0.9961,0.1172,0.9961,0.9961,0.1328,0.9961,0.9961,0.1484,
     * 0.9961,0.9961,0.1680,0.9961,0.9961,0.1836,0.9961,0.9961,0.1992,
     * 0.9961,0.9961,0.2148,0.9961,0.9961,0.2344,0.9961,0.9961,0.2500,
     * 0.9961,0.9961,0.2656,0.9961,0.9961,0.2852,0.9961,0.9961,0.3008,
     * 0.9961,0.9961,0.3164,0.9961,0.9961,0.3320,0.9961,0.9961,0.3516,
     * 0.9961,0.9961,0.3672,0.9961,0.9961,0.3828,0.9961,0.9961,0.3984,
     * 0.9961,0.9961,0.4180,0.9961,0.9961,0.4336,0.9961,0.9961,0.4492,
     * 0.9961,0.9961,0.4648,0.9961,0.9961,0.4844,0.9961,0.9961,0.5000,
     * 0.9961,0.9961,0.4844,0.9961,0.9961,0.4648,0.9961,0.9961,0.4492,
     * 0.9961,0.9961,0.4336,0.9961,0.9961,0.4531,0.9961,0.9961,0.4648,
     * 0.9961,0.9961,0.4844,0.9961,0.9961,0.5000,0.9961,0.9961,0.5195,
     * 0.9961,0.9961,0.5313,0.9961,0.9961,0.5508,0.9961,0.9961,0.5664,
     * 0.9961,0.9961,0.5859,0.9961,0.9961,0.5977,0.9961,0.9961,0.6172,
     * 0.9961,0.9961,0.6328,0.9961,0.9961,0.6484,0.9961,0.9961,0.6641,
     * 0.9961,0.9961,0.6836,0.9961,0.9961,0.6992,0.9961,0.9961,0.7148,
     * 0.9844,0.9844,0.7305,0.9688,0.9688,0.7500,0.9414,0.9414,0.7656,
     * 0.9258,0.9258,0.7813,0.9023,0.9023,0.7969,0.8867,0.8867,0.8164,
     * 0.8633,0.8633,0.8320,0.8672,0.8672,0.8477,0.8633,0.8633,0.8633,
     * 0.8984,0.8984,0.8984,0.9297,0.9297,0.9297,0.9648,0.9648,0.9648,
     * 0.9961,0.9961,0.9961/
c
      data spectrum / 0.0,0.0,0.0,0.016,0.169,0.910,0.012,0.184,0.922,
     * 0.0118,0.1961,0.9373,0.0078,0.2078,0.9490,0.0039,0.2235,0.9608,
     * 0.0000,0.2392,0.9765,0.0000,0.2510,0.9882,0.0000,0.2627,1.0000,
     * 0.0000,0.2627,1.0000,0.0000,0.2745,0.9882,0.0000,0.2863,0.9804,
     * 0.0000,0.2980,0.9686,0.0000,0.3098,0.9569,0.0000,0.3255,0.9490,
     * 0.0000,0.3373,0.9373,0.0000,0.3490,0.9294,0.0000,0.3647,0.9176,
     * 0.0000,0.3804,0.9059,0.0000,0.3922,0.8941,0.0000,0.4039,0.8863,
     * 0.0000,0.4157,0.8745,0.0000,0.4275,0.8667,0.0000,0.4431,0.8549,
     * 0.0000,0.4549,0.8431,0.0000,0.4667,0.8353,0.0000,0.4784,0.8235,
     * 0.0000,0.4941,0.8118,0.0000,0.5098,0.8039,0.0000,0.5216,0.7922,
     * 0.0000,0.5333,0.7804,0.0000,0.5451,0.7725,0.0000,0.5608,0.7647,
     * 0.0000,0.5725,0.7529,0.0000,0.5843,0.7412,0.0000,0.5961,0.7333,
     * 0.0000,0.6118,0.7216,0.0000,0.6235,0.7098,0.0000,0.6353,0.7020,
     * 0.0000,0.6510,0.6902,0.0000,0.6627,0.6784,0.0000,0.6745,0.6706,
     * 0.0000,0.6902,0.6588,0.0000,0.7020,0.6471,0.0000,0.7137,0.6392,
     * 0.0000,0.7294,0.6314,0.0000,0.7412,0.6196,0.0000,0.7529,0.6078,
     * 0.0000,0.7647,0.6000,0.0000,0.7804,0.5882,0.0000,0.7843,0.5882,
     * 0.0000,0.7843,0.5804,0.0000,0.7882,0.5647,0.0000,0.7961,0.5490,
     * 0.0000,0.8000,0.5333,0.0000,0.8078,0.5216,0.0000,0.8118,0.5059,
     * 0.0000,0.8157,0.4902,0.0000,0.8235,0.4745,0.0000,0.8275,0.4627,
     * 0.0000,0.8353,0.4471,0.0000,0.8392,0.4314,0.0000,0.8431,0.4196,
     * 0.0000,0.8471,0.4039,0.0000,0.8549,0.3882,0.0000,0.8588,0.3725,
     * 0.0000,0.8667,0.3569,0.0000,0.8745,0.3451,0.0000,0.8784,0.3294,
     * 0.0000,0.8824,0.3137,0.0000,0.8863,0.3020,0.0000,0.8941,0.2863,
     * 0.0000,0.8980,0.2706,0.0000,0.9020,0.2549,0.0000,0.9059,0.2392,
     * 0.0000,0.9137,0.2275,0.0000,0.9176,0.2118,0.0000,0.9255,0.2000,
     * 0.0000,0.9333,0.1843,0.0000,0.9373,0.1686,0.0000,0.9412,0.1529,
     * 0.0000,0.9451,0.1373,0.0000,0.9529,0.1255,0.0000,0.9569,0.1098,
     * 0.0000,0.9647,0.0980,0.0000,0.9686,0.0824,0.0000,0.9725,0.0667,
     * 0.0000,0.9765,0.0510,0.0000,0.9843,0.0353,0.0000,0.9922,0.0196,
     * 0.0000,0.9961,0.0078,0.0000,1.0000,0.0000,0.0039,1.0000,0.0000,
     * 0.0275,1.0000,0.0000,0.0510,1.0000,0.0000,0.0745,1.0000,0.0000,
     * 0.0980,1.0000,0.0000,0.1216,1.0000,0.0000,0.1490,1.0000,0.0000,
     * 0.1765,1.0000,0.0000,0.2000,1.0000,0.0000,0.2235,1.0000,0.0000,
     * 0.2471,1.0000,0.0000,0.2745,1.0000,0.0000,0.3020,1.0000,0.0000,
     * 0.3255,1.0000,0.0000,0.3490,1.0000,0.0000,0.3725,1.0000,0.0000,
     * 0.3961,1.0000,0.0000,0.4235,1.0000,0.0000,0.4510,1.0000,0.0000,
     * 0.4745,1.0000,0.0000,0.4980,1.0000,0.0000,0.5216,1.0000,0.0000,
     * 0.5490,1.0000,0.0000,0.5765,1.0000,0.0000,0.6000,1.0000,0.0000,
     * 0.6235,1.0000,0.0000,0.6471,1.0000,0.0000,0.6706,1.0000,0.0000,
     * 0.6980,1.0000,0.0000,0.7216,1.0000,0.0000,0.7490,1.0000,0.0000,
     * 0.7725,1.0000,0.0000,0.7961,1.0000,0.0000,0.8235,1.0000,0.0000,
     * 0.8471,1.0000,0.0000,0.8745,1.0000,0.0000,0.8980,1.0000,0.0000,
     * 0.9216,1.0000,0.0000,0.9451,1.0000,0.0000,0.9725,1.0000,0.0000,
     * 1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,
     * 1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,
     * 1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,
     * 1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,
     * 1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,
     * 1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,
     * 1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,
     * 1.0000,1.0000,0.0000,1.0000,1.0000,0.0000,1.0000,0.9843,0.0000,
     * 1.0000,0.9725,0.0000,1.0000,0.9608,0.0000,1.0000,0.9490,0.0000,
     * 1.0000,0.9373,0.0000,1.0000,0.9255,0.0000,1.0000,0.9098,0.0000,
     * 1.0000,0.8980,0.0000,1.0000,0.8863,0.0000,1.0000,0.8745,0.0000,
     * 1.0000,0.8627,0.0000,1.0000,0.8510,0.0000,1.0000,0.8392,0.0000,
     * 1.0000,0.8275,0.0000,1.0000,0.8157,0.0000,1.0000,0.8039,0.0000,
     * 1.0000,0.7922,0.0000,1.0000,0.7765,0.0000,1.0000,0.7647,0.0000,
     * 1.0000,0.7529,0.0000,1.0000,0.7412,0.0000,1.0000,0.7294,0.0000,
     * 1.0000,0.7176,0.0000,1.0000,0.7059,0.0000,1.0000,0.6941,0.0000,
     * 1.0000,0.6824,0.0000,1.0000,0.6706,0.0000,1.0000,0.6549,0.0000,
     * 1.0000,0.6392,0.0000,1.0000,0.6275,0.0000,1.0000,0.6157,0.0000,
     * 1.0000,0.6039,0.0000,1.0000,0.5922,0.0000,1.0000,0.5804,0.0000,
     * 1.0000,0.5686,0.0000,1.0000,0.5569,0.0000,1.0000,0.5451,0.0000,
     * 1.0000,0.5333,0.0000,1.0000,0.5216,0.0000,1.0000,0.5098,0.0000,
     * 1.0000,0.4941,0.0000,1.0000,0.4824,0.0000,1.0000,0.4706,0.0000,
     * 1.0000,0.4588,0.0000,1.0000,0.4471,0.0000,1.0000,0.4353,0.0000,
     * 1.0000,0.4235,0.0000,1.0000,0.4118,0.0000,1.0000,0.4000,0.0000,
     * 1.0000,0.3882,0.0000,1.0000,0.3765,0.0000,1.0000,0.3608,0.0000,
     * 1.0000,0.3490,0.0000,1.0000,0.3373,0.0000,1.0000,0.3255,0.0000,
     * 1.0000,0.3098,0.0000,1.0000,0.2980,0.0000,1.0000,0.2863,0.0000,
     * 1.0000,0.2745,0.0000,1.0000,0.2627,0.0000,1.0000,0.2510,0.0000,
     * 1.0000,0.2392,0.0000,1.0000,0.2235,0.0000,1.0000,0.2118,0.0000,
     * 1.0000,0.2000,0.0000,1.0000,0.1882,0.0000,1.0000,0.1765,0.0000,
     * 1.0000,0.1647,0.0000,1.0000,0.1529,0.0000,1.0000,0.1412,0.0000,
     * 1.0000,0.1294,0.0000,1.0000,0.1176,0.0000,1.0000,0.1059,0.0000,
     * 1.0000,0.0902,0.0000,1.0000,0.0784,0.0000,1.0000,0.0667,0.0000,
     * 1.0000,0.0549,0.0000,1.0000,0.0431,0.0000,1.0000,0.0314,0.0000,
     * 1.0000,0.0196,0.0000,1.0000,0.0078,0.0000,1.0000,0.0000,0.0000,
     * 1.0000,0.0000,0.0000,1.0000,0.0000,0.0000,1.0000,0.0000,0.0000,
     * 1.0000,0.0000,0.0000,1.0000,0.0000,0.0000,1.0000,0.0000,0.0000,
     * 1.0000,0.0000,0.0000,1.0000,0.0000,0.0000,1.0000,0.0000,0.0000,
     * 1.0000,0.0000,0.0000,1.0000,0.0000,0.0000,1.0000,0.0000,0.0000,
     * 1.0000,0.0000,0.0000,1.0000,0.0000,0.0000,1.0000,0.0000,0.0000,
     * 1.0000,0.0000,0.0000,1.0000,0.0000,0.0000,1.0000,0.0000,0.0000,
     * 1.0000,0.0000,0.0000/
c
      data serp /0.0,0.0,0.0,0.0,1.0000,1.0000,0.0204,1.0000,0.9796,
     * 0.0408,1.0000,0.9592,0.0612,1.0000,0.9388,0.0816,1.0000,0.9184,
     * 0.1020,1.0000,0.8980,0.1224,1.0000,0.8776,0.1429,1.0000,0.8571,
     * 0.1633,1.0000,0.8367,0.1837,1.0000,0.8163,0.2041,1.0000,0.7959,
     * 0.2245,1.0000,0.7755,0.2449,1.0000,0.7551,0.2653,1.0000,0.7347,
     * 0.2857,1.0000,0.7143,0.3061,1.0000,0.6939,0.3265,1.0000,0.6735,
     * 0.3469,1.0000,0.6531,0.3673,1.0000,0.6327,0.3878,1.0000,0.6122,
     * 0.4082,1.0000,0.5918,0.4286,1.0000,0.5714,0.4490,1.0000,0.5510,
     * 0.4694,1.0000,0.5306,0.4898,1.0000,0.5102,0.5102,1.0000,0.4898,
     * 0.5306,1.0000,0.4694,0.5510,1.0000,0.4490,0.5714,1.0000,0.4286,
     * 0.5918,1.0000,0.4082,0.6122,1.0000,0.3878,0.6327,1.0000,0.3673,
     * 0.6531,1.0000,0.3469,0.6735,1.0000,0.3265,0.6939,1.0000,0.3061,
     * 0.7143,1.0000,0.2857,0.7347,1.0000,0.2653,0.7551,1.0000,0.2449,
     * 0.7755,1.0000,0.2245,0.7959,1.0000,0.2041,0.8163,1.0000,0.1837,
     * 0.8367,1.0000,0.1633,0.8571,1.0000,0.1429,0.8776,1.0000,0.1224,
     * 0.8980,1.0000,0.1020,0.9184,1.0000,0.0816,0.9388,1.0000,0.0612,
     * 0.9592,1.0000,0.0408,0.9796,1.0000,0.0204,1.0000,1.0000,0.0000,
     * 1.0000,0.9800,0.0200,1.0000,0.9600,0.0400,1.0000,0.9400,0.0600,
     * 1.0000,0.9200,0.0800,1.0000,0.9000,0.1000,1.0000,0.8800,0.1200,
     * 1.0000,0.8600,0.1400,1.0000,0.8400,0.1600,1.0000,0.8200,0.1800,
     * 1.0000,0.8000,0.2000,1.0000,0.7800,0.2200,1.0000,0.7600,0.2400,
     * 1.0000,0.7400,0.2600,1.0000,0.7200,0.2800,1.0000,0.7000,0.3000,
     * 1.0000,0.6800,0.3200,1.0000,0.6600,0.3400,1.0000,0.6400,0.3600,
     * 1.0000,0.6200,0.3800,1.0000,0.6000,0.4000,1.0000,0.5800,0.4200,
     * 1.0000,0.5600,0.4400,1.0000,0.5400,0.4600,1.0000,0.5200,0.4800,
     * 1.0000,0.5000,0.5000,1.0000,0.4800,0.5200,1.0000,0.4600,0.5400,
     * 1.0000,0.4400,0.5600,1.0000,0.4200,0.5800,1.0000,0.4000,0.6000,
     * 1.0000,0.3800,0.6200,1.0000,0.3600,0.6400,1.0000,0.3400,0.6600,
     * 1.0000,0.3200,0.6800,1.0000,0.3000,0.7000,1.0000,0.2800,0.7200,
     * 1.0000,0.2600,0.7400,1.0000,0.2400,0.7600,1.0000,0.2200,0.7800,
     * 1.0000,0.2000,0.8000,1.0000,0.1800,0.8200,1.0000,0.1600,0.8400,
     * 1.0000,0.1400,0.8600,1.0000,0.1200,0.8800,1.0000,0.1000,0.9000,
     * 1.0000,0.0800,0.9200,1.0000,0.0600,0.9400,1.0000,0.0400,0.9600,
     * 1.0000,0.0200,0.9800,1.0000,0.0000,1.0000,1.0000,0.0000,0.9900,
     * 1.0000,0.0000,0.9800,1.0000,0.0000,0.9700,1.0000,0.0000,0.9600,
     * 1.0000,0.0000,0.9500,1.0000,0.0000,0.9400,1.0000,0.0000,0.9300,
     * 1.0000,0.0000,0.9200,1.0000,0.0000,0.9100,1.0000,0.0000,0.9000,
     * 1.0000,0.0000,0.8900,1.0000,0.0000,0.8800,1.0000,0.0000,0.8700,
     * 1.0000,0.0000,0.8600,1.0000,0.0000,0.8500,1.0000,0.0000,0.8400,
     * 1.0000,0.0000,0.8300,1.0000,0.0000,0.8200,1.0000,0.0000,0.8100,
     * 1.0000,0.0000,0.8000,1.0000,0.0000,0.7900,1.0000,0.0000,0.7800,
     * 1.0000,0.0000,0.7700,1.0000,0.0000,0.7600,1.0000,0.0000,0.7500,
     * 1.0000,0.0000,0.7400,1.0000,0.0000,0.7300,1.0000,0.0000,0.7200,
     * 1.0000,0.0000,0.7100,1.0000,0.0000,0.7000,1.0000,0.0000,0.6900,
     * 1.0000,0.0000,0.6800,1.0000,0.0000,0.6700,1.0000,0.0000,0.6600,
     * 1.0000,0.0000,0.6500,1.0000,0.0000,0.6400,1.0000,0.0000,0.6300,
     * 1.0000,0.0000,0.6200,1.0000,0.0000,0.6100,1.0000,0.0000,0.6000,
     * 1.0000,0.0000,0.5900,1.0000,0.0000,0.5800,1.0000,0.0000,0.5700,
     * 1.0000,0.0000,0.5600,1.0000,0.0000,0.5500,1.0000,0.0000,0.5400,
     * 1.0000,0.0000,0.5300,1.0000,0.0000,0.5200,1.0000,0.0000,0.5100,
     * 1.0000,0.0000,0.5000,1.0000,0.0000,0.4900,1.0000,0.0000,0.4800,
     * 1.0000,0.0000,0.4700,1.0000,0.0000,0.4600,1.0000,0.0000,0.4500,
     * 1.0000,0.0000,0.4400,1.0000,0.0000,0.4300,1.0000,0.0000,0.4200,
     * 1.0000,0.0000,0.4100,1.0000,0.0000,0.4000,1.0000,0.0000,0.3900,
     * 1.0000,0.0000,0.3800,1.0000,0.0000,0.3700,1.0000,0.0000,0.3600,
     * 1.0000,0.0000,0.3500,1.0000,0.0000,0.3400,1.0000,0.0000,0.3300,
     * 1.0000,0.0000,0.3200,1.0000,0.0000,0.3100,1.0000,0.0000,0.3000,
     * 1.0000,0.0000,0.2900,1.0000,0.0000,0.2800,1.0000,0.0000,0.2700,
     * 1.0000,0.0000,0.2600,1.0000,0.0000,0.2500,1.0000,0.0000,0.2400,
     * 1.0000,0.0000,0.2300,1.0000,0.0000,0.2200,1.0000,0.0000,0.2100,
     * 1.0000,0.0000,0.2000,1.0000,0.0000,0.1900,1.0000,0.0000,0.1800,
     * 1.0000,0.0000,0.1700,1.0000,0.0000,0.1600,1.0000,0.0000,0.1500,
     * 1.0000,0.0000,0.1400,1.0000,0.0000,0.1300,1.0000,0.0000,0.1200,
     * 1.0000,0.0000,0.1100,1.0000,0.0000,0.1000,1.0000,0.0000,0.0900,
     * 1.0000,0.0000,0.0800,1.0000,0.0000,0.0700,1.0000,0.0000,0.0600,
     * 1.0000,0.0000,0.0500,1.0000,0.0000,0.0400,1.0000,0.0000,0.0300,
     * 1.0000,0.0000,0.0200,1.0000,0.0000,0.0100,1.0000,0.0000,0.0000,
     * 0.9500,0.0000,0.0500,0.9000,0.0000,0.1000,0.8500,0.0000,0.1500,
     * 0.8000,0.0000,0.2000,0.7500,0.0000,0.2500,0.7000,0.0000,0.3000,
     * 0.6500,0.0000,0.3500,0.6000,0.0000,0.4000,0.5500,0.0000,0.4500,
     * 0.5000,0.0000,0.5000,0.4500,0.0000,0.5500,0.4000,0.0000,0.6000,
     * 0.3500,0.0000,0.6500,0.3000,0.0000,0.7000,0.2500,0.0000,0.7500,
     * 0.2000,0.0000,0.8000,0.1500,0.0000,0.8500,0.1000,0.0000,0.9000,
     * 0.0500,0.0000,0.9500,0.0000,0.0000,1.0000,0.0000,0.0467,1.0000,
     * 0.0000,0.0933,1.0000,0.0000,0.1400,1.0000,0.0000,0.1867,1.0000,
     * 0.0000,0.2333,1.0000,0.0000,0.2800,1.0000,0.0000,0.3267,1.0000,
     * 0.0000,0.3733,1.0000,0.0000,0.4200,1.0000,0.0000,0.4667,1.0000,
     * 0.0000,0.5133,1.0000,0.0000,0.5600,1.0000,0.0000,0.6067,1.0000,
     * 0.0000,0.6533,1.0000,0.0000,0.7000,1.0000,0.0000,0.7429,1.0000,
     * 0.0000,0.7857,1.0000,0.0000,0.8286,1.0000,0.0000,0.8714,1.0000,
     * 0.0000,0.9143,1.0000,0.0000,0.9571,1.0000,0.0000,1.0000,1.0000,
     * 0.0000,1.0000,1.0000,0.1429,0.9286,0.8571,0.2857,0.8571,0.7143,
     * 0.4286,0.7857,0.5714,0.5714,0.7143,0.4286,0.7143,0.6429,0.2857,
     * 0.8571,0.5714,0.1429,1.0000,0.5000,0.0000,1.0000,0.5000,0.0000,
     * 1.0000,0.6250,0.2500,1.0000,0.7500,0.5000,1.0000,0.8750,0.7500,
     * 1.0000,1.0000,1.0000/
c-----------------------------------------------------------------------
c `````````````````        include 'coltabs.inc'   ```````````````````

      end module coltabs
      module optim
      use optim_params
      implicit none
C-----------------------------------------------
C   L o c a l   P a r a m e t e r s
C-----------------------------------------------
      integer, parameter :: nxc = 300
      integer, parameter :: iout = 54
      real(kind=rprec) :: bigno = 1.e10_dp
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: ierr_vmec, ns_booz_max, ns_surf_max
      integer, dimension(nxc) :: nbrho_opt, mbrho_opt
      integer, dimension(2*ntor1d) :: nrz0_opt
      integer :: irho_bdy, irm0_bdy, izm0_bdy,
     1   nrad, num_ai
      integer :: nfp_opt, mpol_opt, mpol1_opt, ntor_opt, 
     1      ntor1_opt, mnmax_opt, iunit_opt, iunit_opt_local,
     2      nextcur_opt, nextcur_vmec
      real(kind=rprec), dimension(-ntord:ntord,0:mpol1d) :: rhobc
      real(kind=rprec) :: wp_opt, wb_opt, rmax_opt, rmin_opt, zmax_opt
      real(kind=rprec) :: aspect_opt, coil_complex_opt
      real(kind=rprec) :: chisq_min, rbtor_opt
      real(kind=rprec), dimension(nsd) :: 
     1  vp_opt, iota_opt, phip_opt, buco_opt, Dmerc_opt, jdotb_opt
      real(kind=rprec), dimension(nsd) ::  pres_opt                            !!COBRA
      real(kind=rprec) :: version_opt, am0_9, am10                             !!COBRA
      real(kind=rprec) :: raxis_old(0:ntord), zaxis_old(0:ntord)
 
      integer, allocatable :: ns_booz(:), ns_surf(:)
      logical vv
      character*120 :: input_file, home_dir, min_ext
      character*130 :: output_file, min_input_file, min_wout_file
c-----------------------------------------------
      end module optim


EOF
cat > pgprout.f << "EOF"
      program pgpplotout

C-----------------------------------------------   
c  Ed Lazarus Jan. 2000

c  A version of prout which uses PGPLOT
c  http://astro.caltech.edu/~tjp/pgplot/

c  the 3D package PGXTAL is also required
c  http://www.isis.rl.ac.uk/dataanalysis/dsplot/

c  Aside from a new module in avmodules.f, subroutine and file
c  names are the same as prout with "pgp" prepended.

c  The plots having to do with reconstruction of an experiment are
c  likely to fail at this time (1/26/00)
C-----------------------------------------------   

C-----------------------------------------------   
C   M o d u l e s 
C-----------------------------------------------
      use read_wout_mod, itor_w=>itor
c      use read_old_wout
      use Vpname1
      use Vpname2
      use Vpname3
      use system_mod, only: system
      use Vindat2
      use optim, only: rbc_vv,zbs_vv,mpol_vv,ntor_vv,vv
      use vmec_input, only: rbc,rbs,zbc,zbs, lfreeb
      use read_namelist_mod
      use safe_open_mod

#ifdef OSF1
      use decdebug
#endif
      implicit none
C-----------------------------------------------
C   L o c a l   P a r a m e t e r s
C-----------------------------------------------
      integer, parameter :: lastplot = 18
      integer, parameter :: maxlist = 100
      logical, parameter :: lwstbf = .TRUE.
      character*(*), parameter :: version = 
     1   ' VMEC Plotter Version 6.10pg  y2k '

      character*(*), parameter :: tempfile = 'QqZzXLftemp'

C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: id1, id2, pgopen
      integer :: numargs, numchars, lenlist, i, 
     1   js, lj, mn, l, j, n, ii, k, m, iunit,  
     2   ntor0, lp, ierr
      real(kind=rprec), dimension(:), allocatable :: szc, szb, dummy
      real(kind=rprec) :: r0
      character :: input_id*60, threed2_file*60, ictrans_sel*60, 
     1   explist*100, device*20
      character ::device_type*11
      character, dimension(0:lastplot) :: pagedir*50
      character*120 :: stripped_input_file, in_file

#ifdef CRAY
      character*8 cday,ctime
#else
      character*30 timeloc
#endif

C-----------------------------------------------
C   E x t e r n a l   F u n c t i o n s
C-----------------------------------------------
      integer , EXTERNAL :: iargc
C-----------------------------------------------
*
*                 THIS PROGRAM - PROUT - ACCEPTS THE OUTPUT
*                 FROM THE EQUILIBRIUM PROGRAM VMEC (WOUT FILE)
*                 AND PRINTS/PLOTS THE APPROPRIATE DATA
*
*                GET FILE ID EXTENSION FROM COMMAND LINE
*
*                 Modified (Aug, 1993) ... by M. Vachharajan, R Wieland
*                 Removed DISSPLA Graphics, replaced by NCAR Graphics (V3.0),
*                 using a modified version (ncarplts1.)of the PPPL "ncarplts"
*                 graphics package by Derek Fox.
*                 Graphics calls in this program are a mix of AUTOGRAPH
*                 calls (for 2d plots) and NCARPLTS calls for contours
*
*                To generate all plots %xprout fileid
*                To generate selected plots %xprout fileid "1,5 7 12 14,$"
*                To generate no plots %xprout fileid 0
*
*                 Modified Jan 1994 by R. Wieland to generate fileid.EQI
*                 file for stability code analysis. (Cf lwstbf vbl in WRFCN)
*************
*               Bsubs,Bsubu,Bsubv,Gmn  come in on the half-mesh
*               Vp,Mass,Pres(*),phip   come in on the half-mesh
*               Iotas(*), Lmns         come in on the half-mesh
*               Rmnc,Zmns              come in on the full-mesh
*               Jcuru,Jcurv            come in on the full-mesh
*               Gmn ==> Gsqrt                  on the half mesh
*               sknots,ystark,y2stark  spline knots come in on the sqrt(s) grid
*               pknots,ythom,y2thom    spline knots come in on the sqrt(s) grid
*************
*               (*)  Use Iota Spline Knots instead
*               (*)  Use Pressure Spline Knots instead

#ifdef OSF1
      call decdebugset
      numargs = iargc()
#endif

!!!!!!!!!! the above gets ladebug to accept input 
      pagedir=' '
      pagedir(0) = 'Outer magnetic flux surface'
      pagedir(1) = 'Flux, Mod-B, Mesh, J Contours'
      pagedir(2) = 'Jacobian  Contours'
      pagedir(3) = 'Free Boundary - Boundary Error'
      pagedir(4) = 'Convergence, Magnetic Axis'
      pagedir(5) = 'Stability and Curvatures'
      pagedir(6) = 'Fluxes, Iota, Well'
      pagedir(7) =  'Mass, Pressure, Beta, Pol. Cur vs phi'
      pagedir(8) =   'Jtor , J|| & Itor vs phi'
      pagedir(9) = 'Force Balance'
      pagedir(10) = '|B| Spectrum'
      pagedir(16) = '{R,Z,L} set - the DEFAULT is to skip these'
c      pagedir(17) = 'Limiter & Coil Positions'
c      pagedir(18) = 'Poloidal Flux'

#ifndef CRAY
      timeloc = 'date >> '//tempfile
      call system (timeloc)
      open(unit=99, file=tempfile, status='old', err=100)
      read (99, 5) cdate
    5 format(a)
  100 continue
      close(unit=99, status='delete')
#else
      call date(cday)
      call clock(ctime)
      cdate = cday // ' ' // ctime
#endif

 
      numchars = 0
 
*       Get the Command Line Arguments (Case & Plot Selection)

      numargs = iargc()
      if (numargs >= 1) then
         call getarg (1, input_id)
         ictrans_sel = '1 4 5 6 7 8 $'     ! the default is ALL PLOTS PLEASE
                                 ! except for the {R,Y,L} set
      endif
!!!!!!!!  bypass for ladebug and take from terminal window
      if (input_id .eq. '-h' ) then
         write (*, 104)
  104    format(/' ** To generate all plots %xprout fileid'/
     1' ** To generate selected plots %xprout fileid "1,5 12 14,$"'/
     2' ** choose plotting device %xprout fileid "1,5 12 14,$" /device'/
     3' ** typically choose /xw (default) or /cps for/device'/
     4      ' ** To generate surface plot %xprout fileid 0')
         write (*, 105) (i,pagedir(i),i=0,lastplot)
  105    format(/,' *** Plot Directory ***',2/,(i5,3x,a))
         stop 
      endif
      if (numargs .ge. 2) call getarg (2, ictrans_sel)
      if (numargs .eq. 3) call getarg (3, device)
      if (numargs .lt. 3) device='/xw'
      if(numargs .eq. 0) then
         write (6, 104)
         write (6, 105) (i,pagedir(i),i=0,lastplot)
         write(6,*)
     .'enter fileid <cr> , selections (no quotes) <cr>, device <cr>'
         read(5,fmt='(a)')input_id
         read(5,fmt='(a)')ictrans_sel
         read(5,fmt='(a)')device
         if(device .eq. ' ') device='/xw'
         write(6,*)input_id
         write(6,*)ictrans_sel           
         write(6,*)device
       endif

 
*       Parse the Plot Selection Part, If Present
      call icsel1 (ictrans_sel, lastplot, explist, maxlist, lenlist)

*
*       Does the Input File Exist ?
*
      numchars = len_trim(input_id)
      if (numchars .eq. 0) then
         write(6,*) ' MUST ENTER FILE SUFFIX ON COMMAND LINE'
         stop 
      endif
      if (index(input_id,'wout.') .eq. 1) then
         input_id = input_id(6:)
         numchars = numchars - 6
      endif
      runlabel = input_id(1:numchars+1)//' '//cdate(1:len_trim(cdate)+1)
      threed2_file = 'threed2.'//input_id
      gmeta_file = 'gmeta.'//input_id(1:numchars)
      open(unit=39, file=threed2_file, status='unknown')


      call read_wout_file('wout.'//trim(input_id),ierr)
      if (ierr .ne. 0 ) stop "call read_wout_file"

      if (ierr .eq. 1) stop 'could not read wout file: check extension'
      if (ierr.ne.0 .and. ierr.le.10) stop 'error in plotter read_wout'
      if (niter .le. 0) stop 'VMEC CODE DID NOT RUN PROPERLY!'
      
      
      if (imse .ne. (-1)) then
         i = index(mgrid_file,'.')
         if (i .eq. 0) then
            write (*, *) 
     1      'MGRID_FILE (in WOUT & INPUT) has incorrect format!'
             stop 
         endif
         tokid = mgrid_file(i+1:)
      else
         tokid = ' '
         mgrid_file = ' '
      endif

      if (ireconstruct > 0) then
        nbrbz = nbfld(nbrbz_id)/2          ! count in pairs
        if (nbrbz.gt.0 .and. ireconstruct .gt. 0) then
          allocate (brcoil(nbrbz), plbrfld(nbrbz), brbc(nbrbz),
     1    bzcoil(nbrbz), plbzfld(nbrbz), bzbc(nbrbz))
          ii = 0
          do i = 1, 2*nbrbz, 2
             ii = ii +1
             brcoil(ii)  = bcoil(i,1)
             bzcoil(ii)  = bcoil(i+1,1)
             brbc(ii)    = bbc(i,1)
             bzbc(ii)    = bbc(i+1,1)
             plbrfld(ii) = plbfld(i,1)
             plbzfld(ii) = plbfld(i+1,1)
          enddo
        endif
      endif

      nmirnovset = 0
      nmirnov = 0
      do n = 1, nbsets
         if (n .eq. nmirnov_id) then
            nmirnovset = n
            nmirnov = nbfld(nmirnovset)
            exit 
         endif
      enddo
*****************************
* Read input file for RBC, etc.
* Needed for LFREEB=T
*****************************
C  need to strip comments from input file producved by stellopt
*****************************
!------------------------------------------------------------------------------

!
!     read input (optimum) namelist
!     first, strip any comments from input file (F95-not necessary)
!
      in_file='input.'//trim(input_id)
      call strip_comments(trim(in_file)) 
!!Produces clean file input_file//'.stripped'      
      stripped_input_file = trim(in_file) // '.stripped'
      id1 = 99
      call safe_open (id1, id2, trim(stripped_input_file)  ,
     .  'old', 'formatted')
      if (id2 .ne. 0) then
         print *,  trim(stripped_input_file)  ,
     .   ': input file open error: iostat = ', 
     .      id2
      else
         call read_namelist (id1, id2, 'indata')
      endif
      close(id1) !  close and reopen to avoid error on hecate
      if (id2 .ne. 0) then
         write (*, *) ' indata namelist READ error: iostat = ', id2
         ierr = 3
      endif
      ierr=0; id1 = 99; id2=0
      call safe_open (id1, id2, trim(stripped_input_file)  ,
     .  'old', 'formatted')
      if (id2 .ne. 0) then
         print *,  trim(stripped_input_file)  ,
     .   ': input file open error: iostat = ', 
     .      id2
      else
         call read_namelist (id1, id2, 'optimum')
      endif
      if (id2 .ne. 0) then
         write (*, *) ' optimum namelist READ error: iostat = ', id2
         ierr = ierr+6
      endif
      vv=lfreeb .and. ierr.lt.6 .and. rbc_vv(0,0).gt.0 
       print *,'vv=',vv, lfreeb,ierr,rbc_vv(0,0)
      vv=lfreeb .and. rbc_vv(0,0).gt.0
       print *,'vv=',vv,rbc_vv(0,0)
      if(id2.eq.0) close(id1,status='delete')
      if(id2.ne.0) close(id1)

*****************************

      allocate (sqrt_phimod(mnmax*ns), phimod(mnmax*ns), dbzcods(ns), 
     1   ffp(ns), ub(ns), iotaf(ns), darea(ns), iotazb(ns), psi(ns),
     2   itors(ns), ipols(ns), szc(ns), szb(ns), dummy(ns),
     3   ixm(mnmax), ixn(mnmax), stat=mn)
      if (mn .ne. 0) stop 'Allocation error in plotout'        

      ixm(:mnmax) = nint(xm(:mnmax))
      ixn(:mnmax) = nint(xn(:mnmax))

      do mn = 1, mnmax
         if (ixm(mn).eq.0 .and. ixn(mn).eq.0) mn0 = mn
      enddo

      ntor0 = 1 + ntor
      nrt = ns*nthpts
 
*****************************
*        COMPUTE FOURIER COEFFICIENTS OF d Bu/ds and d Bs/du
*        ON ZONE BNDRY GRID
*        Bsubu,v on 1/2 grid; dBsubu,v on full grid
*****************************
      hs = 1./(ns - 1)
      phip(1) = phip(2)
      
 
      do mn = 1, ntor0
         bmn(mn,1) = 1.5*bmn(mn,2) - 0.5*bmn(mn,3)
      enddo

      do mn = 1, ntor
         gmn(mn,1) = 1.5*gmn(mn,2) - 0.5*gmn(mn,3)
      enddo

      currvmn(1+ntor0:mnmax,1) = 0.
      bmn(1+ntor0:mnmax,1) = 0.
      gmn(1+ntor0:mnmax,1) = 0.
      darea(2:ns) = vp(2:ns)*overr(2:ns)
      overr(2:ns-1) = .5*(overr(2:ns-1)+overr(3:ns))
      iotaf(2:ns-1) = .5*(iotas(2:ns-1)+iotas(3:ns))
      jcuru(1) = 2.*jcuru(2) - jcuru(3)
      overr(1) = 2.*overr(2) - overr(3)
      jcuru(ns) = 2.*jcuru(ns-1) - jcuru(ns-2)
      overr(ns) = 2.*overr(ns-1) - overr(ns-2)
      iotas(1) = 1.5*iotas(2) - 0.5*iotas(3)
      iotaf(1) = iotas(1)
      iotaf(ns) = 1.5*iotas(ns) - 0.5*iotas(ns-1)
 
*     Spline Knots are on sqrt(s) grid ...
      if (ireconstruct .gt. 0) then
         do i = 2, ns
            szc(i) = sqrt(hs*(i - 1.5))
            szb(i) = sqrt(hs*(i - 1))
         enddo
         szc(1) = 0.
         szb(1) = 0.
         call splint (sknots, ystark, y2stark, isnodes, szc, iotas, 
     1      dummy, ns)
         call splint (sknots, ystark, y2stark, isnodes, szb, iotazb, 
     1      dummy, ns)
         iotaf(:ns) = iotazb(:ns)
         call splint (pknots, ythom, y2thom, ipnodes, szc, pres, 
     1      dummy, ns)
      endif
*     Forming <J-dot-GradPhi> / < R**-1 > ...
cj      where (overr .ne. 0.) jcurv = jcurv/overr  !  obsolete
      hs = 1.0/(ns - 1)
      ohs = 1.0/hs
      r0 = rmnc(mn0,ns)
      call wrfcn (input_id)
      id2 = pgopen (trim(device)) 
      if (id2.le.0)
     .  write(*,*)'Fail to Open ',trim(device),' with code ',id2
      if (id2.le.0) stop 'id2'
      call pgscf(2)
      call pgpplotter (r0, explist, lenlist, input_id, trim(device))
      call wrfcn2 (input_id)
*
*                   CALL EQI STABILITY FILE GENERATOR
*
*     Poloidal Flux / TwoPi
      if (lwstbf .and. ireconstruct.gt.0) then
         psi(1) = 0.
         do j = 2, ns
            psi(j) = psi(j-1) + hs*phip(j)*iotas(j)
         enddo
*
         call wrstab (ns, psi, pres, iotaf, input_id, mnmax, 
     1      rmnc, zmns, bvco(ns), itor, ffp, jdotb, betatot, betapol,
     2      betator, betaxis)
      endif
!
!     Deallocate memory
!

      call read_wout_deallocate
      deallocate (sqrt_phimod, phimod, dbzcods, ffp, ub, iotaf, 
     1   darea, iotazb, psi, itors, ipols, szc, szb, dummy,
     2   ixm, ixn)
      if (allocated(brcoil)) deallocate (brcoil, plbrfld, brbc,
     1    bzcoil, plbzfld, bzbc)
8033  call pgclos

      end program pgpplotout






      
 
      subroutine dlm_parse(string, delimiter, n_tokens, tokens, 
     1   len_tokens)
C...Translated by Pacific-Sierra Research VAST-90 2.06G2  12:27:59  11/23/98  
C...Switches: -p4 -yb
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer n_tokens
      character string*(*), delimiter
      integer, dimension(*) :: len_tokens
      character, dimension(*) :: tokens*(*)
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: n_tokens_max, i, isl, iii, ipos, i_run
C-----------------------------------------------
 
c     Written by R. Wieland
c
c     break up the string "string" into its component tokens
c     delimiter given specifically
c
c     input:
c       string
c             delimiter delimiter character to be used
c       n_tokens: max no. of tokens allowed
c     output:
c       n_tokens: no. of tokens returned
c       tokens:   char array of individual tokens returned
c       len_tokens: integer array containing length of
c           each token
 
 
      n_tokens_max = n_tokens
 
      do i = 1, n_tokens
         tokens(i) = ' '
      enddo
 
      isl = len_trim(string)
      if (isl .eq. 0) then
         n_tokens = 0
         iii = len(tokens(1))
cobsolete call str$copy_r (tokens(1), iii, %REF(string))
         len_tokens(1) = 0
         return 
      endif
 
c     Tag on a trailing delimiter; remove it at the end
      string(isl+1:isl+1) = delimiter
 
      i = 1
      ipos = 1
      do while(i .eq. 1)
         i = index(string(ipos:),delimiter)
         ipos = ipos + 1
      enddo
      i_run = ipos - 1
 
      n_tokens = 0
      do while(i_run<=isl .and. n_tokens<n_tokens_max)
         i = index(string(i_run:),delimiter) + i_run - 1
         n_tokens = n_tokens + 1
         tokens(n_tokens) = string(i_run:i-1)
         len_tokens(n_tokens) = len_trim(tokens(n_tokens))
         i_run = i + 1
      enddo
 
c     Remove trailing delimiter at the end
      string(isl+1:isl+1) = ' '
 
      end subroutine dlm_parse
      integer function gen_find_first_in_set (string, set)
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      character string*(*), set*(*)
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: i, j, lstring, lset
C-----------------------------------------------
 
 
 
c     Mimic Str$Find_First_In_Set
 
      gen_find_first_in_set = 0
 
      lstring = len_trim(string)
      lset = len_trim(set)
 
      if (lstring==0 .or. lset==0) return 
 
      do i = 1, lstring
         do j = 1, lset
            if (string(i:i) .eq. set(j:j)) goto 100
         enddo
      enddo
 
      return 
 
  100 continue
 
c     Found a character in SET
 
      gen_find_first_in_set = i
 
      end function !gen_find_first_in_set

      subroutine get_lun(iu)
      integer*4  iun(20),ist(20)
      save    iun,ist
      data iun/  119,118,117,116,115,114,113,112,111,110,
     &             109,108,107,106,105,104,103,102,101,100/
      data ist/  20*0/
      do j = 1,20
        if (ist(j) .eq. 0) then
          iu = iun(j)
          ist(j) = 1
          return
        endif
      enddo
      iu = -1
      return
      entry    free_lun(iu)
      ist(120-iu) = 0
      return
      end subroutine get_lun

        subroutine graf1 (x,y,n,lx,ly,lt,runlbl)
         implicit none
         integer n
         real , dimension(n), intent(in) :: x, y
         real ymin, ymax, xmin, xmax, siz
         character*(*) lx,ly,lt,runlbl
         call pgsave
         call pgbbuf
         call pgsci(1)
         xmin=minval(x);xmax=maxval(x)
         ymin=minval(y);ymax=maxval(y)
         if(ymax.eq.ymin)then
          if(ymax.gt.0.)ymin=.99*ymax
          if(ymax.lt.0.)ymax=.99*ymin
          if(ymax.eq.0.)ymax=1.e-3;ymin=-1.e-3
         endif
         call pgenv(minval(x),maxval(x),ymin,ymax,0,0)
         call pglab(trim(lx),trim(ly),trim(lt))
         call pgqch(siz)
         call pgsch(siz-.5)
         call pgmtxt('B',2.85,0.5,0.5,trim(runlbl))
         call pgsch(siz)
         call pgsci(2)
         call pgslw(3)
         call pgline(n,x,y)
         call pgebuf
         call pgunsa
        return
        end subroutine graf1
        subroutine graf1x (x,y,n,lx,ly,lt,runlbl)
         implicit none
         integer n
         real , dimension(n), intent(in) :: x, y
         real ymin, ymax, xmin, xmax, siz
         character*(*) lx,ly,lt,runlbl
         call pgsave
         call pgbbuf
         call pgsci(1)
         xmin=minval(x);xmax=maxval(x)
         ymin=minval(y);ymax=maxval(y)
         if(ymax.eq.ymin)then
          if(ymax.gt.0.)ymin=.99*ymax
          if(ymax.lt.0.)ymax=.99*ymin
          if(ymax.eq.0.)ymax=1.e-3;ymin=-1.e-3
         endif
         call pgenv(minval(x),maxval(x),ymin,ymax,0,1)
         call pglab(trim(lx),trim(ly),trim(lt))
         call pgqch(siz)
         call pgsch(siz-.5)
         call pgmtxt('B',2.85,0.5,0.5,trim(runlbl))
         call pgsch(siz)
         call pgsci(2)
         call pgslw(3)
         call pgline(n,x,y)
         call pgebuf
         call pgunsa
        return
        end subroutine graf1x

        subroutine graf1pt (x,y,n,lx,ly,lt,runlbl)
         implicit none
         integer n
         real , dimension(n), intent(in)  :: x, y
         real ymin, ymax, siz
         character*(*) lx,ly,lt,runlbl
         call pgsave
         call pgsci(1)
         ymin=minval(y);ymax=maxval(y)
         if(ymax.eq.ymin)then
          if(ymax.gt.0.)ymin=.99*ymax
          if(ymax.lt.0.)ymax=.99*ymin
          if(ymax.eq.0.)ymax=1.e-3;ymin=-1.e-3
         endif
         call pgpage
         call pgvstd
         call pgswin(minval(x),maxval(x),ymin,ymax)
         call pgbox('BCNT',0.,0,'BCNTP1',0.,0)
c         call pgenv(minval(x),maxval(x),ymin,ymax,0,0)
         call pglab(trim(lx),trim(ly),trim(lt))
         call pgqch(siz)
         call pgsch(siz-.5)
         call pgmtxt('B',2.85,0.5,0.5,trim(runlbl))
         call pgsch(siz)
         call pgsci(2)
         call pgpt(n,x,y,2)
         call pgunsa
        return
        end subroutine graf1pt

        subroutine midplpt (x1,y1,nx,ny,lx,ly,lt,runlbl)
         USE Vmagaxis
         implicit none
         integer nx,ny
         real , dimension(nx,ny), intent(in)  :: x1, y1
         real ymin, ymax, siz
         real, dimension(:), allocatable :: x,y
         character*(*) lx,ly,lt,runlbl
         call pgsave
         call pgsci(1)
         allocate(x(2*ny),y(2*ny))
         x=(/x1(1,1:ny),x1((nx+1)/2,1:ny)/)
         y=(/y1(1,1:ny),y1((nx+1)/2,1:ny)/)
         ymin=minval(y);ymax=maxval(y)
         if(ymax.eq.ymin)then
          if(ymax.gt.0.)ymin=.99*ymax
          if(ymax.lt.0.)ymax=.99*ymin
          if(ymax.eq.0.)ymax=1.e-3;ymin=-1.e-3
         endif
         call pgenv(minval(x),maxval(x),ymin,ymax,0,0)
         call pglab(trim(lx),trim(ly),trim(lt))
         call pgqch(siz)
         call pgsch(siz-.5)
         call pgmtxt('B',2.85,0.5,0.5,trim(runlbl))
         call pgsch(siz)
         call pgsci(2)
         call pgpt(2*ny,x,y,1)
         call pgsci(4)
         call pgpt1 ( real(rmagaxis), ymin+(ymax-ymin)/3.,-4)
         call pgunsa
         deallocate(x,y)
        return
        end subroutine midplpt

        subroutine graf2 (x,y,yfit,n,lx,ly,lt,runlbl)
c  two lines on a single scale
         implicit none
         integer i, n
         real ymin, ymax, siz
         real *4, dimension(n) :: x,y,yfit
         character*(*) lx,ly,lt,runlbl
         call pgsave
         call pgbbuf
         call pgsci(1)
         ymin=min(minval(y),minval(yfit))
         ymax=max(maxval(y),maxval(yfit))
         if(ymax.eq.ymin)then
          if(ymax.gt.0.)ymin=.99*ymax
          if(ymax.lt.0.)ymax=.99*ymin
          if(ymax.eq.0.)ymax=1.e-3;ymin=-1.e-3
         endif
         call pgenv(minval(x),maxval(x),ymin,ymax,0,0)
         call pglab(trim(lx),trim(ly),trim(lt))
         call pgqch(siz)
         call pgsch(siz-.5)
         call pgmtxt('B',2.85,0.5,0.5,trim(runlbl))
         call pgsch(siz)
         call pgsci(3)
         call pgpt(n,x,y,-2)
         call pgslw(3)
         call pgsls(1)
         call pgsci(2)
         call pgline(n,x,yfit)
         call pgsci(3)
         call pgpt(n,x,y,2)
         call pgebuf
         call pgunsa
        return
        end subroutine graf2

        subroutine graf2pt (x1,x2,y1,y2,n,lx,ly1,ly2,lt,runlbl)
         integer n
         real , dimension(n), intent(in)  :: x1, x2, y1, y2
         real ymin, ymax, siz
         character*(*) lx,ly1,ly2,lt,runlbl
         call pgsave
         call pgslw(1)
         call pgsci(1)
         xmin=minval(x1);xmax=maxval(x1)
         xmin=min(xmin,minval(x2))
         xmax=max(xmax,maxval(x2))
         ymin=minval(y1);ymax=maxval(y1)
         ymin=min(ymin,minval(y2))
         ymax=max(ymax,maxval(y2))
         if(ymax.eq.ymin)then
          if(ymax.gt.0.)ymin=.99*ymax
          if(ymax.lt.0.)ymax=.99*ymin
          if(ymax.eq.0.)ymax=1.e-3;ymin=-1.e-3
         endif
         call pgpage
         call pgvstd
         call pgswin(xmin,xmax,ymin,ymax)
         call pgbox('BCNT',0.,0,'BCNTP1',0.,0)
c         call pgenv(xmin,xmax,ymin,ymax,0,0)
         call pglab(trim(lx),'(m)',trim(lt))
         call pgqch(siz)
         call pgsch(siz-.5)
         call pgmtxt('B',2.85,0.5,0.5,trim(runlbl))
         call pgsch(siz)
         call pgsci(4)
         call pgslw(1)
         call pgpt(n,x1,y1,-1)
         call pgmtxt('L',2.65,0.,0.,trim(ly1))
         call pgsci(2)
         call pgslw(3)
         call pgpt(n,x2,y2,-2)
         call pgmtxt('L',2.65,1.0,1.0,trim(ly2))
         call pgunsa
        return
        end subroutine graf2pt

        subroutine graf3pt (x,y1,y2,y3,n,lx,ly1,ly2,ly3,lt,runlbl)
         integer n
         real , dimension(n), intent(in)  :: x, y1, y2, y3
         real ymin, ymax, siz
         character*(*) lx,ly1,ly2,ly3,lt,runlbl
         call pgsave
         call pgsci(1)
         ymin=minval(y1);ymax=maxval(y1)
         ymin=min(ymin,minval(y2))
         ymax=max(ymax,maxval(y2))
         ymin=min(ymin,minval(y3))
         ymax=max(ymax,maxval(y3))
         if(ymax.eq.ymin)then
          if(ymax.gt.0.)ymin=.99*ymax
          if(ymax.lt.0.)ymax=.99*ymin
          if(ymax.eq.0.)ymax=1.e-3;ymin=-1.e-3
         endif
         call pgenv(minval(x),maxval(x),ymin,ymax,0,0)
         call pglab(trim(lx),' ',trim(lt))
         call pgqch(siz)
         call pgsch(siz-.5)
         call pgmtxt('B',2.85,0.5,0.5,trim(runlbl))
         call pgsch(siz)
         call pgsci(1)
         call pgpt(n,x,y1,2)
         call pgmtxt('L',2.65,0.,0.,trim(ly1))
         call pgsci(2)
         call pgpt(n,x,y2,3)
         call pgmtxt('L',2.65,0.5,0.5,trim(ly2))
         call pgsci(4)
         call pgpt(n,x,y3,4)
         call pgmtxt('L',2.65,1.,1.,trim(ly3))
         call pgunsa
        return
        end subroutine graf3pt

        subroutine graf2x (x,y,yfit,n,lx,lyl,lyr,lt,runlbl)
c two lines in a box with y axis left and right
         implicit none
         integer i, n
         real ymin, ymax, dx, siz
         real *4, dimension(n) :: x,y,yfit
         character*(*) lx,lyl,lyr,lt,runlbl
         character*8 xopt,yopt
         dx=x(3)-x(1)
         if(n.lt.30)dx=x(2)-x(1)
         call pgsave
         call pgbbuf
         call pgsci(1)
         call pgpage
         call pgvstd
         call pgswin(minval(x),maxval(x),minval(y),maxval(y))
         xopt='BCNST';yopt='B'
         call pgbox(trim(xopt),0.,0,trim(yopt),0.,0)
c         call pgmtxt('B',1.5,0.5,0.5,trim(lx))
         call pglab(trim(lx),' ',trim(lt))
c         call pgmtxt('T',1.5,0.5,0.5,trim(lt))
         call pgqch(siz)
         call pgsch(siz-.5)
         call pgmtxt('B',2.85,0.5,0.5,trim(runlbl))
         call pgsch(siz)
         call pgsci(2)
         yopt='BNST'
         call pgbox(' ',0.,0,trim(yopt),0.,0)
         call pgmtxt('L',2.25,0.5,0.5,trim(lyl))
         call pgsls(1)
         call pgslw(3)
         call pgline(n,x,y)
c         call pgarro(x(n/3)-dx,y(n/3),x(n/3-n/5)-dx,y(n/3))
c         call pgunsa
         xopt=' ';yopt='CMST'
         call pgsci(4)
         call pgswin(minval(x),maxval(x),minval(yfit),maxval(yfit))
         call pgbox(' ',0.,0,trim(yopt),0.,0)
         call pgmtxt('R',2.25,0.5,0.5,trim(lyr))
c         call pgsave
         call pgsls(4)
         call pgslw(8)
         call pgline(n,x,yfit)
c         call pgarro(x(2*n/3)+dx,yfit(2*n/3),x(2*n/3+n/5)+dx,yfit(2*n/3))
         call pgebuf
         call pgunsa
        return
        end subroutine graf2x

      subroutine plot2d(x,nx,y,ny,zin,n1,n2,w,
     &  size,iwidth,xlbl,ylbl,titl,iwid)
c     ---------------------------------------------------------------
      use coltabs
c
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer nx, ny, n1, n2, iwid, iwidth
      real          x(*),y(*),zin(n1,n2),w(*),size
      character*(*) xlbl, ylbl, titl
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: iplot, ictab, ncband, icmax, icmin, maxbuf, ncb
      real :: difus, shin, polish, dofset, dlow, dhigh
      real, dimension(:,:), allocatable :: z
      real rgb(3,3), eye(3), light(3), latice(3,3)
      real lutusr(3,256), rgbbkg(3)
      character string*32, type*16, chr*16
      logical   ovrlay, lshin
C-----------------------------------------------
C   I n i t i a l i z a t i o n
C-----------------------------------------------
      data eye,light /0.0,0.0,1000.0,-1.0,-1.0,-1.0/
      data rgb /0.0,0.0,1.0,0.35,0.35,0.35,1.0,1.0,1.0/
      data rgbbkg /1.,1.,0./
c+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c
c
c purpose
c      this subroutine plots "data" defined on a regularly-spaced 
c   rectangular grid of points z(i,j). with the default choice for the 
c   pgcell routine that is linked, the output is a linearly-interpolated 
c   map (rather than coarse rectangular boxes).
c
c parameters
c   argument  type  i/o  dimension  description
c    z        r*4    i    n1 x n2   the recatangular "data"-array.
c    z        r*4    o    n1 x n2   a scaled, and clipped, version of 
c                                   the input array(!).
c    n1       i*4    i       -      the first dimension of array z.
c    n2       i*4    i       -      the second dimension of array z.
c    x        r*4    i      nx      array of x-coordinates.
c    nx       i*4    i       -      number of x-pixels to be plotted 
c                                  (usually = n1, but must be <= n1).
c    y        r*4    i      ny      array of y-coordinates.
c    ny       i*4    i       -      number of y-pixels to be plotted 
c                                  (usually = n2, but must be <= n2).
c    w        r*4    i       -      dummy parameter (back-compatibility).
c    size     r*4    i       -      character-size for plot (try 1.5).
c    iwidth   i*4    i       -      line-width for plot (try 2).
c    xlbl     a*1    i     *(*)     label for x-axis.
c    ylbl     a*1    i     *(*)     label for y-axis.
c    titl     a*1    i     *(*)     title for plot.
c
c globals
c    coltabs.inc
c
c history
c   initial release.                                    dss:  3 jul 1992
c   minor changes to conform with new pgcell.           dss:  6 feb 1995
c   put in option to over-lay contours.                 dss: 21 feb 1995
c   now has proper 3-d surface surface rendering.       dss: 27 aug 1997
c   fortran made linux-friendly!                        dss: 15 sep 1997
c   choose white background colour for postscript.      dss:  5 feb 1999
c-----------------------------------------------------------------------
c
c
   1  iplot=1
        if (n1.ne.nx .or. n2.ne.ny) then
          write(*,*)' sorry folks, surface option needs n1=nx & n2=ny!'
          return
        endif
        allocate(z(n1,n2))
        z=zin(1:n1,1:n2)
        ictab=0
        shin=0.
        ncband=15
        difus=.7
        ncb=27
        polish=1
        lshin=.false.
        call eulerfix(latice)
        dhigh=maxval(z)
        dlow=minval(z)
        dofset=max(-dlow,0.)
        z=z+dofset
        dhigh=maxval(z)
        dlow=minval(z)
        call pgqcol(icmin,icmax)
        ncband=min(ncband,icmax-17+1)
        call pgsch(size)
        call pgslw(iwidth)
c        call pgpaper(0.0,1.0)
        call pgvport(0.0,1.0,0.0,1.0)
        call pgswin(-1.,1.,-1.,1.)
        call pgsci(0)
        call pgbox('BC',0.0,0,'BC',0.0,0)
        call pgsci(1)
          call sbfint(rgbbkg,15,1,iwid,maxbuf)
        if (ictab.le.2 .or. ictab.ge.7) then
          call colint(rgb,17,icmax,difus,shin,polish)
        elseif (ictab.eq.3) then
          call colsrf(heat,256,1.0,17,icmax,ncb,difus,shin,polish)
        elseif (ictab.eq.4) then
          call colsrf(spectrum(1,2),255,1.0,17,icmax,ncb,difus,shin,
     *                polish)
        elseif (ictab.eq.5) then
          call colsrf(bgyrw,256,1.0,17,icmax,ncb,difus,shin,polish)
        elseif (ictab.eq.6) then
          call colsrf(serp,256,1.0,17,icmax,ncb,difus,shin,polish)
        endif
        call sb2srf(eye,latice,z,n1-1,n2-1,dlow,dhigh,1.0,17,icmax,ncb,
     *              light,lshin)
        call pgsci(1)
        call axes3d(eye,latice,x(1),x(n1),y(1),y(n2),xlbl,ylbl,size,
     *         dlow,dhigh,dofset,z(1,1),z(n1,1),z(n1,n2),z(1,n2))
        call sbtext(eye,0.,0.5,0.5,titl)
        call sbfcls(iwid)
        call pgmtxt("T",-1.72,0.5,0.5,titl)
        call pgebuf
        call pgupdt
        deallocate(z)
        return
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC DRIVER CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
c2d        call pgsave
c2d        call pgsubp(1,1)
c2d        call plot2d(real(hshere(1:)),nx,
c2d     1   real(lka(nx,1:)),ny,
c2d     1   real(residual12(1:nx,1:ny)),nx,ny,
c2d     1   real(br),1.5,1,'hs','mn','residual',id2)
c2d
c2d          call pgqinf('DEV/TYPE',device_type,kz)
c2d          if((device_type(2:4).eq.'/XW').or.
c2d     &     (device_type(2:4).eq.'/XS'))then 
c2d           write(6,*)trim(device_type),' Type <RETURN> for next page:'
c2d           read(5,fmt='(a)')pchar
c2d          endif
c2d        call pgunsa
c2d
c2d
c2d        call pgsave
c2d        call pgsubp(1,1)
c2d        call plot2d(real(hshere(1:)),nznt1,
c2d     1   real(pang(1:)),ntheta2/2+1,
c2d     1   real(r3d(1:nznt1,1:ntheta2/2+1,1)),nznt1,ntheta2/2+1,
c2d     1   real(br),1.5,1,'hs','theta','residual',id2)
c2d
c2d          call pgqinf('DEV/TYPE',device_type,kz)
c2d          if((device_type(2:4).eq.'/XW').or.
c2d     &     (device_type(2:4).eq.'/XS'))then 
c2d           write(6,*)trim(device_type),' Type <RETURN> for next page:'
c2d           read(5,fmt='(a)')pchar
c2d          endif
c2d        call pgunsa
c2d
c2d
c2d        call pgsave
c2d        call pgsubp(1,1)
c2d        call plot2d(real(hshere(1:)),nznt1,
c2d     1   real(tang(1:)),nzeta/2,
c2d     1   real(r3d(1:nznt1,1,1:nzeta/2)),nznt1,nzeta/2,
c2d     1   real(br),1.5,1,'hs','zeta','residual',id2)
c2d
c2d          call pgqinf('DEV/TYPE',device_type,kz)
c2d          if((device_type(2:4).eq.'/XW').or.
c2d     &     (device_type(2:4).eq.'/XS'))then 
c2d           write(6,*)trim(device_type),' Type <RETURN> for next page:'
c2d           read(5,fmt='(a)')pchar
c2d          endif
c2d        call pgunsa
c2d        call pgsubp(2,2)
c2dc        call pgpage
c2d        call resetcolor
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC END DRIVER CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      end subroutine plot2d

      subroutine eulerfix(latice)
c     ------------------------
c
      real         latice(3,*)
      data         pirad /0.01745329252/
      data ia,ib/45,30/
c
        sina=-sin(float(ia)*pirad)
        cosa=cos(float(ia)*pirad)
        sinb=-sin(float(ib)*pirad)
        cosb=cos(float(ib)*pirad)
      call roty(-0.5,-0.5,+0.5,u,v,w,sina,cosa)
      call rotx(u,v,w,latice(1,1),latice(2,1),z1,sinb,cosb)
      latice(3,1)=z1-1.0
      call roty(+0.5,-0.5,+0.5,u,v,w,sina,cosa)
      call rotx(u,v,w,latice(1,2),latice(2,2),z2,sinb,cosb)
      latice(3,2)=z2-1.0
      call roty(-0.5,-0.5,-0.5,u,v,w,sina,cosa)
      call rotx(u,v,w,latice(1,3),latice(2,3),z3,sinb,cosb)
      latice(3,3)=z3-1.0
      end subroutine eulerfix
 
      subroutine icsel1(line, lastplot, explist, maxlist, len)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer lastplot, maxlist, len
      character line*(*), explist*(*)
C-----------------------------------------------
C   L o c a l   P a r a m e t e r s
C-----------------------------------------------
      integer, parameter :: maxtokens = 20
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: ntokens
      integer, dimension(maxtokens) :: ltokens
      integer :: i, ndt
      integer, dimension(2) :: ldtokens
      integer :: lim1, lim2, j, lint
      character, dimension(maxtokens) :: tokens*20
      character, dimension(2) :: dtokens*20
      character :: cint*20, addon*11
C-----------------------------------------------
 
c     Purpose: expand ICTRANS style plot list ( 1,3 5 ) to char list
c       e.g.,  1,3 into -1-2-3-
c       replace "$" with last plot number
 
c     input:  line [character*(*)]        line to be parsed
c             lastplot [integer]        substitute this for "$" in line
c             maxlist  [integer]        max len of list
c     output:
c             explist(1:len) [char]     generated list
c             len      [integer]        len of expanded list
 
 
 
 
c     Local Vbls
 
      explist = '-'
      len = 1
 
c     Break Up Token List By Whitespace First
      ntokens = maxtokens
      call wie_parse (line, ntokens, tokens, ltokens)
 
c     Check The Line For Dashes ... Cry Out And Die !
      if (index(line,'-') .ne. 0) then
         write (*, *) 
     1' Wrong format ... use COMMAs, not DASHES to indicate plot range !
     2'
         call exit (2)
      endif
 
c      do i = 1, ntokens
c       write (*,'(i3,2x,a)') i, tokens(i)
c      enddo
 
c     Check Each Whitespace Delimited Token To See If It Is A
c     Triplet ("i,j") Or A Singlet ("i")
      do i = 1, ntokens
         ndt = 2
         call dlm_parse (tokens(i), ',', ndt, dtokens, ldtokens)
         if (ndt .eq. 2) then                      !  like 3,5 - Triplet -
            read (dtokens(1), 10) lim1
   10       format(i20)
            if (dtokens(2) .ne. '$') then
               read (dtokens(2), 10) lim2
            else
               lim2 = lastplot
            endif
         else if (ndt .eq. 1) then                 !  like 3   - Singlet -
            if (dtokens(1) .ne. '$') then
               read (dtokens(1), 10) lim1
            else
               lim1 = lastplot
            endif
            lim2 = lim1
         endif
         do j = lim1, lim2
            write (cint, 100) j
  100       format(i20)
            call str_strip (cint, lint)
            addon = cint(1:lint)//'-'
            if (len + lint + 1 > maxlist) then
               write (*, *) 
     1            ' ICSEL ??: # of elems expanded exceeds limit ', 
     2            maxlist
               call exit (2)
            endif
            explist = explist(1:len)//addon(1:lint+1)
            len = len + lint + 1
         enddo
      enddo
 
      end subroutine icsel1

      logical function iswhitespace (letter, byteset, nwsp)
C...Translated by Pacific-Sierra Research VAST-90 2.06G2  12:27:59  11/23/98  
C...Switches: -p4 -yb
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer nwsp
      character letter
      character, dimension(*) :: byteset
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: j
      logical :: whitespace
C-----------------------------------------------
      whitespace = .FALSE.
      j = 1
      do while( .not.whitespace .and. j<=nwsp)
         whitespace = letter .eq. byteset(j)
         j = j + 1
      enddo
      iswhitespace = whitespace

      end function !iswhitespace

        subroutine loggraf1 (x,y,n,lx,ly,lt,runlbl)
         implicit none
         integer i, n
         real ymin, ymax, siz
         real *4, dimension(n) :: x,y
         real *4, dimension(:), allocatable :: logx,logy
         character*(*) lx,ly,lt,runlbl
         character*100 loglabel
         allocate(logy(n))
       logy=alog10(y)
         call pgsave
         call pgbbuf
         call pgsci(1)
         ymin=minval(logy);ymax=maxval(logy)
         if(ymax.eq.ymin)then
          if(ymax.gt.0.)ymin=.99*ymax
          if(ymax.lt.0.)ymax=.99*ymin
          if(ymax.eq.0.)ymax=1.e-3;ymin=-1.e-3
         endif
         call pgenv(minval(x),maxval(x),ymin,ymax,0,20)
         loglabel='Log\d10\u\(2223)'//trim(ly)//'\(2224)'
         call pglab(
     &     trim(lx),trim(loglabel),trim(lt))
         call pgqch(siz)
         call pgsch(siz-.5)
         call pgmtxt('B',2.85,0.5,0.5,trim(runlbl))
         call pgsch(siz)
         call pgslw(3)
         call pgline(n,x,logy)
         call pgebuf
         call pgunsa
         deallocate(logy)
        return
        end subroutine loggraf1


        subroutine loggraf3pt (x,y1,y2,y3,n,lx,ly1,ly2,ly3,lt,runlbl)
         integer n
         real , dimension(n), intent(in)  :: x, y1, y2, y3
         real *4, dimension(:), allocatable :: logx,logy1,logy2,logy3
         real ymin, ymax, siz
         character*(*) lx,ly1,ly2,ly3,lt,runlbl
         character*100 loglabel
         allocate(logy1(n),logy2(n),logy3(n)   )
       logy1=alog10(y1)
       logy2=alog10(y2)
       logy3=alog10(y3)
         call pgsave
         call pgsci(1)
         ymin=minval(logy1);ymax=maxval(logy1)
         ymin=min(ymin,minval(logy2))
         ymax=max(ymax,maxval(logy2))
         ymin=min(ymin,minval(logy3))
         ymax=max(ymax,maxval(logy3))
         if(ymax.eq.ymin)then
          if(ymax.gt.0.)ymin=.99*ymax
          if(ymax.lt.0.)ymax=.99*ymin
          if(ymax.eq.0.)ymax=1.e-3;ymin=-1.e-3
         endif
         call pgenv(minval(x),maxval(x),ymin,ymax,0,20)
         loglabel='Log\d10\u\(2223)'//trim(ly2)//'\(2224)'
         call pglab(trim(lx),' ',trim(lt))
         call pgqch(siz)
         call pgsch(siz-.5)
         call pgmtxt('B',2.85,0.5,0.5,trim(runlbl))
         call pgsch(siz)
         call pgsci(1)
         call pgpt(n,x,logy1,2)
         call pgmtxt('L',2.65,0.,0.,trim(ly1))
         call pgsci(2)
         call pgpt(n,x,logy2,3)
         call pgmtxt('L',2.65,0.5,0.5,trim(loglabel))
         call pgsci(4)
         call pgpt(n,x,logy3,4)
         call pgmtxt('L',2.65,1.,1.,trim(ly3))
         call pgunsa
        return
        end subroutine loggraf3pt
        subroutine loggrafpt (x,y,n,lx,ly,lt,runlbl)
         implicit none
         integer i, n
         real ymin, ymax, dx, siz
         real *4, dimension(n) :: x,y
         real *4, dimension(:), allocatable :: logx,logy
         character*(*) lx,ly,lt,runlbl
         character*100 loglabel
         allocate(logy(n))
         logy=alog10(y)
         call pgsave
         call pgbbuf
         call pgsci(1)
         ymin=minval(logy);ymax=maxval(logy)
         if(ymax.eq.ymin)then
          if(ymax.gt.0.)ymin=.99*ymax
          if(ymax.lt.0.)ymax=.99*ymin
          if(ymax.eq.0.)ymax=1.e-3;ymin=-1.e-3
         endif
         call pgenv(minval(x),maxval(x),ymin,ymax,0,20)
         loglabel='Log\d10\u\(2223)'//trim(ly)//'\(2224)'
         call pglab(
     &     trim(lx),trim(loglabel),trim(lt))
         call pgqch(siz)
         call pgsch(siz-.5)
         call pgmtxt('B',2.85,0.5,0.5,trim(runlbl))
         call pgsch(siz)
         call pgsci(2)
         call pgpt(n,x,logy,2)
         call pgsci(15)
         call pgslw(1)
         call pgline(n,x,logy)
         call pgebuf
         call pgunsa
         deallocate(logy)
        return
        end subroutine loggrafpt

      subroutine logint(contr,zmin,zmax,n,irr)
        implicit none
c logarithmic interpolation
        real zmin,zmax,zlmin,zlmax,amin, amax
        logical misign,allpos,zerol,zerou
        complex c,d,bmin,bmax
        real cs, conv, pi, el, da
        integer i,n,n1, irr
        real*4 contr(*)
        pi=4.*atan(1.)
        if(zmax-zmin .lt. 10.)goto 1001  !  linear
        zlmax=zmax
        zlmin=zmin
        zerol=zmin.eq.0.
        zerou=zmax.eq.0.
        if(zerol)zlmin=-zmax/1.e4
        if(zerou)zlmax=abs(zmin/1.e4)
        conv=log(10.)
        allpos=(zlmax.gt.0.).and.(zlmin.gt.0.)
        misign=zlmin.lt.0.
        bmin=cmplx(zlmin,.0)
        bmin=(log(bmin))
        if(misign)cs=real(bmin)
        if(misign)bmin=cmplx(cs,pi)
        amin=real(bmin)
        if(zerol)amin=0
        if(misign)amin=-amin
        misign=zlmax.lt.0.
        bmax=cmplx(zlmax,.0)
        bmax=(log(bmax))
        if(misign)cs=real(bmax)
        if(misign)bmax=cmplx(cs,pi)
        amax=real(bmax)
        if(zerou)amax=0
        if(amin.gt.amax)then
          cs=amin
          amin=amax
          amax=cs
        endif
        da=real(amax-amin)/(n-1)
        if(allpos) then
          do i=1,n
          c=cmplx(amin+(i-1)*da)
          contr(i)=real(exp(c)) 
          enddo
        else
          el=abs(zlmax)+abs(zlmin)
          n1=-(zlmin/el)*n
          n1=max(1,n1)
          do i=1,n1
          c=cmplx(amin+(i-1)*da,pi)
          contr(i)=real(exp(-c)) 
          enddo
          i=n1+1
          contr(i)=0
          do i=n1+2,n
          c=cmplx(amin+(i-1)*da)
          contr(i)=real(exp(c)) 
          enddo
        endif
        irr=0
        return

 1001   continue     
        da=real(zmax-zmin)/(n-1)
        do i=1,n
           contr(i)=zmin +da*(i-1)
        enddo
        irr= 1001
        return
        end subroutine logint

      logical function makeplot (explist, lenlist, page, pagedesc)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer lenlist
      character explist*(*), page*(*), pagedesc*(*)
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      logical :: flag, echo
      character :: id*10
C-----------------------------------------------
 
 
c     Local Vbls
      data echo/.TRUE./
 
 
c     Local Fncs
 
      id = '-'//page(1:len_trim(page))//'-'
 
      flag = index(explist(1:lenlist),id(1:len_trim(id))) > 0
 
      if (echo .and. flag) write (*, *) ' Making plot # ', page, ' : ', 
     1   pagedesc
 
      makeplot = flag
 
      end function !makeplot




      subroutine pgpcontour(xplot, yplot, func, nx,ny,
     1    ncon, ivar, mxnp, nmxnp, runlabel,xlab,ylab,zlab,mtitl)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      use Toexternal
      USE READ_WOUT_MOD
      use Vpname1
      USE Vpltcn2
      USE Vpltcn6
      USE Vrzarray
      USE Vmagaxis
      USE Vplotdata
      USE Vindat2
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer ncon, ivar, nx, ny, ny1
      real(kind=rprec) :: grsz
      character xlab*(*), ylab*(*), zlab*(*), mtitl*(*), runlabel*(*)
      real(kind=rprec), dimension(nx*ny) :: xplot, yplot, func
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: nstep, nrav, nzav, n, k, l, kt, j, mxnp, nmxnp
      real, dimension(ny) :: rthet, zthet
      real :: step, exstep, fac, xmin, xmax, ymin, ymax, 
     1  delmax, delmin, delf, siz
      real, dimension(:), allocatable :: f_real, x_real, y_real
      real, dimension(:,:), allocatable :: contourfunc
      logical logs
      data logs/.false./
      character*35 logscale
      data logscale/'Using Logarithmically Scaled Levels'/
                                               
C-----------------------------------------------
C-----------------------------------------------
C   E x t e r n a l   F u n c t i o n s
C-----------------------------------------------
      real, EXTERNAL :: RZtrans
C-----------------------------------------------

*        
*     LOCATE PHYSICAL ORIGIN
*
*     ROUND-OFF AXIS
*
      mxnt=nx
      step = max(rmax - rmin,zmax - zmin)
      exstep = 2. - nint(log10(step))
      fac = 10.**exstep
      nstep = nint(.25*(fac*step)*1.05)
      nrav = nint(.50*(rmax + rmin)*fac)
      nzav = nint(.50*(zmax + zmin)*fac)
      step = nstep/fac


      allocate (f_real(nx*ny+nx), x_real(nx*ny+nx), 
     1          y_real(nx*ny+nx),contourfunc(nx,ny+1))
      f_real = (/real(func),real(func(1:nx))/) ! complete the period
      x_real = (/real(xplot),real(xplot(1:nx))/)
      y_real = (/real(yplot),real(yplot(1:nx))/)

      xmin = minval(x_real)
      xmax = maxval(x_real)
      ymin = minval(y_real)
      ymax = maxval(y_real)
      call pgsci(1)
      call  pgenv (xmin, xmax, ymin, ymax,1,0)      ! define the subplot area
      call pglab(trim(xlab),trim(ylab),trim(zlab))
      call pgmtxt('T',1.0,0.5,0.5,trim(mtitl))
      call pgqch(siz)
      call pgsch(siz-.5)
      if(logs)call pgmtxt('T',0.20,0.5,0.5,trim(logscale))
      call pgmtxt('B',2.85,0.5,0.5,trim(runlabel))
      call pgsch(siz)
      
c         Plot the Boundary -- Last Closed Flux Surface
      l = ny*(ny - 1) + 1
      call  pgscf (2  )                             ! select simple typeface
      call pgpt 
     & (nx,x_real(nx*(ny-1)+1:nx*ny), y_real(nx*(ny-1)+1:nx*ny),-1)
c plot contours 
         phit = 2.0_rprec*pi/real(nfp*nmxnp,kind=rprec)* 
     &    real((mxnp-1),kind=rprec)
      ny1=ny+1
      contourfunc=reshape(f_real,(/nx,ny1/))
      delmax = maxval(contourfunc)
      delmin = minval(contourfunc)
      delf = (delmax - delmin)/ncon
      contrs=0.
      lcontr=0
      klabel=0
      kbold=0
      logs=.false.
      ncont=ncon
      do j=1,ncon
        contrs(j)=delmin +delf*(j-1)
c          lcontr(j)=1+modulo(j,5)
c          if(lcontr(j).eq.2)klabel(j)=1
      enddo
ceal      if(abs((delmax-delmin)/delf).gt.10.)then
ceal         call logint(contrs,delmin,delmax,ncon,kt)
ceal         if(kt.eq.0)logs=.true.
ceal       endif
      call pgsave
      call pgconx(Transpose(contourfunc),
     &ny1,nx,1,ny1,1,nx,contrs,ncon,RZtrans)
      call pgunsa
c         Plot the Magnetic Axis ?
      if (ivar .eq. 0) then
         call pgpt1 ( real(rmagaxis), real(zmagaxis),3)
      endif
 
c         Plot Constant THETA Contours?
      if (ivar .eq. 2) then
         do kt = 1, nx, 6
            do j=1,ny
              rthet(j) = r(kt+nx*(j-1))
              zthet(j) = z(kt+nx*(j-1))
            enddo
            call pgline ( ny, rthet, zthet )
         enddo
      endif
 
      deallocate (f_real, x_real, y_real, contourfunc)
      end subroutine pgpcontour

      subroutine pgptdplotter(rmnb, zmnb, rdum, zdum,ns,iwid)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      use read_wout_mod, only: nfp, rprec
      use Vpltcn2
      use coltabs
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer :: ns
      real(kind=rprec), dimension(ns), intent(in) :: 
     1   rmnb, zmnb, rdum, zdum
C-----------------------------------------------
C   L o c a l   P a r a m e t e r s
C-----------------------------------------------
c
c define a parameter specifying the maximum size of the array required
c for the list of triangles.
c
        integer, parameter :: mtri0=5000
c
c define values of pi, two times pi, and pi over 180.
c
        real, parameter :: pi=3.14159265358979323846,
     1        twopi=2.*pi,dtor=pi/180.
c
c set the values determining the resolution of the grid over which the
c surface is generated.
c
        integer, parameter :: idim = 51
c set the desired minimum and maximum values of u and v (for the grid
c over which the surface is generated).
c
        real, parameter :: umin = 0., umax = twopi
        real, parameter :: vmin = 0., vmax = twopi
c
c set the desired values of parameters determining the eye position.
c ang1 is a bearing angle, ang2 is an elevation angle, and rmul is a
c multiplier of the length of the diagonal of the data box, specifying
c the distance from the center of the box to the eye.
c
        real, parameter :: ang1 = 215., ang2 = 35., rmul = 2.9
c
        integer, parameter :: isrs = 3
c
c declare variables to hold labels.
c
        character*64 :: xnlb,ynlb,znlb,xilb,yilb,zilb
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      real red(3,256), grey(3,256), green(3,256), blue(3,256) 
      real map(3,256)
        real, dimension(3) :: eye,rgbbkg,rgbsrf,p1,p2,light
        real  zshift,xw,shin,polish,difus,alpha
        integer :: k, k1, k2, iwid, maxbuf, pgopen
        integer :: ic1, ic2, ncb, ncol
c        data       rgbbkg /0.25,0.25,0.25/
        data       rgbbkg /1.,1.,0./
        data       rgbsrf /1.00,0.00,0.00/
        data       light /-1.0,-1.0,-1.0/
        integer :: jdim, mtri, ntri, jplt, j, i, jvvmi, jvvma,
     1     iuvmi, iuvma, lnlg, ltri
        integer, dimension(:), allocatable :: itwk
        real, dimension(:,:), allocatable :: rval, hval
        real(kind=rprec), dimension(:), allocatable :: rt,ht
c
c declare a local array to hold the triangle list and a couple of
c temporary variables to be used in sorting the list.
c
        real, dimension(:,:), allocatable :: rtri, rtwk, vert
        real :: xmin, xmax, ymin, ymax, xmid, ymid, zmid,
     1     xeye, yeye, zeye, r, p, h, otep,
     2     xvpl, xvpr, yvpb, yvpt, xwdl, xwdr, ywdb, ywdt,
     3     rv00, pv00, hv00, rv01, pv01, hv01, rv10, pv10, hv10, 
     4     rv11, pv11, hv11, pval, xval, yval, zval
C-----------------------------------------------
c
c define labels for the edges of the box.
c
        data xnlb / ' -4 -3 -2 -1 0 1 2 3 4 ' /
        data ynlb / ' -4 -3 -2 -1 0 1 2 3 4 ' /
        data znlb / ' -4 -3 -2 -1 0 1 2 3 4 ' /
c
        data xilb / 'x coordinate values' /
        data yilb / 'y coordinate values' /
        data zilb / 'z coordinate values' /

c
c define arithmetic statement functions for r, phi, and h as functions
c of u and v.
c
c       rval(u,v)=cos(u)+ a*cos(u-v)+b
        pval(i,j)=vmin+(real(j-1)/real(jdim-1))*(vmax-vmin)
c       hval(u,v)=sin(u)+ a*sin(u-v)
c
c define arithmetic statement functions to transform cylindrical
c coordinates into cartesian coordinates.
c
        xval(r,p,h)=r*cos(p)
        yval(r,p,h)=r*sin(p)
        zval(r,p,h)=h-zshift  ! pgplot convention all z<0
        zshift=1.1*zmax

        jplt = 51/nfp        !!v points per period
        if (jplt .lt. 10) jplt = 10
        jdim = 1 + jplt*nfp
c
c
c set the desired minimum and maximum values of x, y, and z.
c
        xmin =-rmax
        xmax = rmax
        ymin =-rmax
        ymax = rmax
        
        mtri = mtri0 * nfp
        allocate (rtri(10,mtri),rtwk(mtri,2),itwk(mtri), vert(3,3),
     1   rval(idim,2), hval(idim,2), rt(idim+1),ht(idim+1),stat=i)
        if (i .ne. 0) stop 'allocation error in 3dplot'

c
c turn clipping off.
c
c
c double the line width.
c
c
c define colors to use.
c

c
c select font number 25, turn on the outlining of filled fonts, set the
c line width to 1, and turn off the setting of the outline color.
c
c
c make tdpack characters a bit bigger.
c
c
c define tdpack rendering styles 1 through 7, using black-and-white
c shading or colored shading, whichever is selected.  the indices
c 1-7 can then be used as final arguments in calls to tditri, tdstri,
c and tdmtri.
c

c              
c initialize the count of triangles in the triangle list.
c
        ntri=0
c
c for each box on a rectangular grid in the uv plane, generate two
c triangles and add them to the triangle list.  each triangle is
c transformed from cylindrical coordinates to cartesian coordinates.
c
        j=1;rval=0;hval=0
        call totz(idim,1,jplt,j,rt,ht,
     1              rmnb,zmnb,rdum,zdum)
        hval(1:idim,1)=real(ht(1:idim))
        rval(1:idim,1)=real(rt(1:idim))

        do 102 j=1,jdim-1
          call totz(idim,1,jplt,j+1,rt,ht,
     1              rmnb,zmnb,rdum,zdum)
          hval(1:idim,2)=real(ht(1:idim))
          rval(1:idim,2)=real(rt(1:idim))
          jvvmi=1
          jvvma=2
          do 101 i=1,idim-1
            iuvmi=i
            iuvma=i+1
            rv00=rval(iuvmi,jvvmi)
            pv00=pval(iuvmi,j)
            hv00=hval(iuvmi,jvvmi)
            rv01=rval(iuvmi,jvvma)
            pv01=pval(iuvmi,j+1)
            hv01=hval(iuvmi,jvvma)
            rv10=rval(iuvma,jvvmi)
            pv10=pval(iuvma,j)
            hv10=hval(iuvma,jvvmi)
            rv11=rval(iuvma,jvvma)
            pv11=pval(iuvma,j+1)
            hv11=hval(iuvma,jvvma)
            if (ntri.lt.mtri) then
              ntri=ntri+1
              rtri(1,ntri)=xval(rv10,pv10,hv10)
              rtri(2,ntri)=yval(rv10,pv10,hv10)
              rtri(3,ntri)=zval(rv10,pv10,hv10)
              rtri(4,ntri)=xval(rv00,pv00,hv00)
              rtri(5,ntri)=yval(rv00,pv00,hv00)
              rtri(6,ntri)=zval(rv00,pv00,hv00)
              rtri(7,ntri)=xval(rv01,pv01,hv01)
              rtri(8,ntri)=yval(rv01,pv01,hv01)
              rtri(9,ntri)=zval(rv01,pv01,hv01)
              rtri(10,ntri)=real(isrs)
            endif
            if (ntri.lt.mtri) then
              ntri=ntri+1
              rtri(1,ntri)=xval(rv01,pv01,hv01)
              rtri(2,ntri)=yval(rv01,pv01,hv01)
              rtri(3,ntri)=zval(rv01,pv01,hv01)
              rtri(4,ntri)=xval(rv11,pv11,hv11)
              rtri(5,ntri)=yval(rv11,pv11,hv11)
              rtri(6,ntri)=zval(rv11,pv11,hv11)
              rtri(7,ntri)=xval(rv10,pv10,hv10)
              rtri(8,ntri)=yval(rv10,pv10,hv10)
              rtri(9,ntri)=zval(rv10,pv10,hv10)
              rtri(10,ntri)=real(isrs)
            endif

  101     continue
          rval(:,1) = rval(:,2)
          hval(:,1) = hval(:,2)
  102   continue
           if(max(
     &        maxval(rtri(3,1:ntri)),
     &        maxval(rtri(9,1:ntri)),
     &        maxval(rtri(6,1:ntri))).gt.0)stop 'z>0'

c
c find the midpoint of the data box (to be used as the point looked at).
c
        xmid=.5*(xmin+xmax)
        ymid=.5*(ymin+ymax)
        zmid=.5*(zmin+zmax)
c
c determine the distance (r) from which the data box will be viewed and,
c given that, the eye position.
c
        r=rmul*sqrt((xmax-xmin)**2+(ymax-ymin)**2+(zmax-zmin)**2)
c
        xeye=xmid+r*cos(dtor*ang1)*cos(dtor*ang2)
        yeye=ymid+r*sin(dtor*ang1)*cos(dtor*ang2)
        zeye=zmid+r*sin(dtor*ang2)
c
c
c

c solids!
      xw=1.35*xmax
      eye=(/xeye,yeye,2*zeye/)
      light=(/-xeye,yeye,-2*zeye/)
      call pgsave
      call pgpaper(0.0,1.0)
      call pgvport(0.0,1.0,0.0,1.0)
c      call pgswin(-0.95*xw,xw/1.23,-0.95*xw,xw/1.23)
      call pgswin(-1.23*xw,xw/1.23,-1.23*xw,xw/1.23)
      call pgbox('bc',0.0,0,'bc',0.0,0)
      call colint(rgbsrf,16,39,0.5,0.0,1.0)
      alpha=1.0
      call pgqcir(ic1,ic2)
      ncb=5!!(ic2-ic1+1)/6*0
      ncol=256
      shin=0.0
      polish=.5
      difus=.25
      red=0.0
      green=0.0
      blue=0.0
      do i = 1,256
        grey(1,i)=1.0/real(256-1)*(i-1)
        grey(2,i)=1.0/real(256-1)*(i-1)
        grey(3,i)=1.0/real(256-1)*(i-1)
        red(1,i)=1.0/real(256-1)*(i-1)
        green(2,i)=1.0/real(256-1)*(i-1)
        blue(3,i)=1.0/real(256-1)*(i-1)
      enddo
      map = 0.8*red+0.8*green+0.5*blue


      call sbfint(rgbbkg,15,1,iwid,maxbuf)
      call colsrf(map,ncol,alpha,ic1,ic2,ncb,difus,shin,polish)
      do i=1,ntri
         vert=reshape(rtri(1:9,i),(/3,3/))
         call sbplan(eye,3,vert,ic1,ic2,light)
      enddo

      call sbfcls(iwid)
      call pgebuf
      call pgupdt
      call pgunsa
      deallocate (rtri,rtwk,itwk, rval, hval, stat=i)
      end subroutine pgptdplotter


      subroutine pgpplotter(r0, explist, lenlist, input_id, device)
C-----------------------------------------------
CSave as working, has axes3d, offset corrected
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      use read_wout_mod, itor_w=>itor
      use Vpname2
      USE Vpltcn2
      USE Vpltcn6
      USE Vrzarray
      USE Vplotdata
      USE Vmagaxis
      USE Vindat2
      use Toexternal
      use system_mod, only: system
      use vmec_input, only: rbc,rbs,zbc,zbs, lfreeb
      use safe_open_mod

      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer lenlist
      real(kind=rprec) :: r0
      character explist*(*), input_id*(*), device*(*)
C-----------------------------------------------
C   L o c a l   P a r a m e t e r s
C-----------------------------------------------
      real(kind=rprec) :: zero = 0.0_dp , one = 1.0_dp
      integer, parameter :: ntdu = 31, ntdv = 21
      integer, parameter :: nplot1 = 25, ntheta1 = 2, 
     1  nox = 1, noy = 3, lx = -1, ly = 0, iend = 3,
     2  ilog = 1, icart = 0, oneppg = 2, fourppg = 1
      integer, dimension(4) :: ivar = (/0, 1, 2, 3/),
     1  ncon = (/10, 25, 15, 20/)      
      real(kind=rprec), parameter :: grsize1 = 3.5, grsize2 = 2.5, 
     1  grfull = 7.5
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: id1, id2, np, id, pgopen, nzeta, ntheta, ntheta2
      integer :: i, ii, nplots, les, kz, k, kt, j, l, js, kz1, nplt1,
     1   ndeg, ns1, mn, mp, nt, ichar, istat, nznt, nznt1, ipag
      integer :: nsurf , ntht , nphi ,jxbcode
      real(kind=rprec) :: small 
      real(kind=rprec), dimension(ns) :: br, bz, phin
      real(kind=rprec), dimension(2*ns) :: oqmid
      real(kind=rprec), dimension(100) :: time
      real(kind=rprec), dimension(nplot1) :: raxis_v, zaxis_v
      real(kind=rprec), dimension(nfloops + 1) :: delflm
      real(kind=rprec), dimension(nbloops) :: delbc
      real(kind=rprec), dimension(nfloops + 1) :: indflm
      real(kind=rprec), dimension(nbloops) :: indbc
      real(kind=rprec), dimension(:,:), allocatable :: dummy1
      real(kind=rprec), dimension(:), allocatable :: rbndy,zbndy
      real(kind=rprec), dimension(:), allocatable :: modb, sqrt_phim, 
     1  phim, gsqrt, torcur, dummy2, r12, z12, ru12, zu12
      real(kind=rprec) :: dth, denom, bdotgradv0, phiangle, offset,
     1   bdotgradvn, phinorm, t1, a0, an, cosphi, sinphi
      character :: page*10, pagedesc*50, nchar*100, mchar*100, 
     1   pchar*100, ititlet*100, fname*80, fdum*80,
     1   xlabel*100, ylabel*100, zlabel*100, mtitle*40
      character ::device_type*11
      real xspread,xxspread,yspread,yyspread,deltx,siz,
     1 xmin,xmax,ymin,ymax,yzero,ymmax,ymmin,xmmin,xmmax
      integer maxc,ic,nmarks,nspread
      real(kind=rprec), dimension(:), allocatable :: hiota, presb, 
     1   beta_volb, phipb,  phib, bvcob,  bucob , xmb, xnb
      integer , dimension(:), allocatable :: jlistb
      real(kind=rprec), dimension(:,:), allocatable :: 
     1   bmnb, rmnb, zmnb, pmnb
      logical first
      data first/.true./
      real(kind=rprec) :: aspectb, rmax_surfb, rmin_surfb, betaxisb
      integer :: nsb, nfpb, nboz, mboz, mnboz, versionb, 
     1 iunit, ierr, iread, jrad, mb, nb

C-----------------------------------------------
c jxbout columns
c    LK      JSUPU      JSUPV      JSUPS      BSUPU      BSUPV      J X B        
c    p'   J X B - p'     J * B      BSUBU      BSUBV      BSUBS   

      integer :: nx, ny
      integer, dimension(:,:), allocatable :: lka
      real(kind=rprec), dimension(:,:), allocatable :: 
     1  bsupu, bsupv, bsubu, bsubv, bsubs, residual12, xfres12
      real(kind=rprec), dimension(:,:), allocatable :: 
     1  jsupu, jsupv, jcrossb, pprime, bdotj, jsups
      real(kind=rprec), dimension(:), allocatable :: pang, tang,
     1  avforce, hshere, amaxfor, aminfor
      real, dimension(:), allocatable :: xplot,yplot
      logical, dimension(:), allocatable :: iplot
      real x1,x2,y1,y2
      integer itheta,izeta
      logical addon, alldone
C-----------------------------------------------
C   E x t e r n a l   F u n c t i o n s
C-----------------------------------------------
      logical , EXTERNAL :: makeplot
C-----------------------------------------------
      ipag=0


      mn = mnmax*ns
      allocate (dummy1(mnmax,ns), dummy2(nrt), r(nrt), z(nrt), 
     1   ru(nrt), zu(nrt), modb(nrt), sqrt_phim(nrt), phim(nrt), 
     2   gsqrt(nrt),torcur(nrt), dbsubudstz(nrt), bsubutz(nrt), 
     3   bsubvtz(nrt),r12(nrt), z12(nrt), ru12(nrt), zu12(nrt), 
     4   stat = istat)
      if (istat .ne. 0) stop 'allocation error in plotter'
      allocate(rbndy(nthpts),zbndy(nthpts), stat = istat)
      if (istat .ne. 0) stop 'allocation error in plotter'


      dummy1 = 0.
      dummy2 = 0.
 
      noxc = 0
      noyc = noy - 1
      lxc = lx
      lyc = ly
 
*
*                 SETUP PGPLOT GRAPHICS
*
      call pgpap(7.5,1.)
      call pgask(.true.)
      call pgsch(1.85)
      call pgslw(3)
      call pgsubp(1,1)

 
*
*                 COMPUTE R,Z SCALES
*

      nplots = 1
      if (ntor .ne. 0) nplots = 4
      les = 1 + nthpts*(ns - 1)
      do kz = 1, nplots
         call totz(nthpts,ns,nplots,kz,r,z,rmnc,zmns,rmns,zmnc)
         if (kz .eq. 1) then
            rmax = r(les)
            rmin = r(les)
            zmax = z(les)
            zmin = z(les)
         endif
         rmax = max(rmax,maxval(r(les:nrt)))
         rmin = min(rmin,minval(r(les:nrt)))
         zmax = max(zmax,maxval(z(les:nrt)))
         zmin = min(zmin,minval(z(les:nrt)))
      enddo
!
!     3-D Surface
!      
C###    PAGE # 0
      page = '0'
      pagedesc = 'Outer magnetic flux surface'

      if (makeplot(explist,lenlist,page,pagedesc)) then
        call pgsave
        call pgptdplotter(rmnc(1,ns),zmns(1,ns),bmn(1,ns),
     &   rmns(1,ns),zmnc(1,ns),ns,id2)

        call pgqinf('DEV/TYPE',device_type,kz)
        if((device_type(2:4).eq.'/XW').or.!pgplot does not know about
     &   (device_type(2:4).eq.'/XS'))then  ! sbfcls -- fix it here
          write(6,*)trim(device_type),' Type <RETURN> for next page:'
          read(5,fmt='(a)')pchar
        endif
        call pgunsa
      endif
      if(trim(explist).eq.'-0-')goto 8033  !  terminate plotting
      call resetcolor
*       ---Transform from (m,n) Space to (u,v) Space---
      do kz = 1, nplots
         call totz (nthpts,ns,nplots,kz,r,z,rmnc,zmns,rmns,zmnc)
         call totzu(nthpts,ns,nplots,kz,ru,zu,rmnc,zmns,rmns,zmnc)
         call totz (nthpts, ns, nplots, kz, modb, dummy2, bmn, 
     1      zmns, dummy1, dummy1)
         call totz (nthpts, ns, nplots, kz, sqrt_phim, dummy2, 
     1      sqrt_phimod, zmns, dummy1, dummy1)
         call totz (nthpts, ns, nplots, kz, phim, dummy2, phimod, 
     1      zmns, dummy1, dummy1)
         call totz (nthpts, ns, nplots, kz, gsqrt, dummy2, gmn,
     1      zmns, dummy1, dummy1)
         call totz (nthpts, ns, nplots, kz, torcur, dummy2, 
     1      currvmn, zmns, dummy1, dummy1)
         call totz (nthpts, ns, nplots, kz, bsubutz, dummy2, 
     1      bsubumn, zmns, dummy1, dummy1)
         call totz (nthpts, ns, nplots, kz, bsubvtz, dummy2, 
     1      bsubvmn, zmns, dummy1, dummy1)
 
         do kt = 1, nthpts
            r12(kt) = r(kt)
            z12(kt) = z(kt)
c        do this for r1,z1 because they go like sqrt(s) near origin
            r12(kt+nthpts) = .5*(sqrt(2.) - 1.)*(r(kt+nthpts)-r(kt))
            z12(kt+nthpts) = .5*(sqrt(2.) - 1.)*(z(kt+nthpts)-z(kt))
            do j = 2, ns
               l = kt + nthpts*(j - 1)
               r12(l) = 0.5*(r(l) + r(l-nthpts))
               z12(l) = 0.5*(z(l) + z(l-nthpts))
            enddo
         enddo
         rmagaxis = r12(1)
         zmagaxis = z12(1)
c         call bndypts (nthpts,nplots,kz,rbndy,zbndy)
 
         do kt = 1, nthpts
            do j = 2, ns
               l = kt + nthpts*(j - 1)
               ru12(l) = 0.5*(ru(l)+ru(l-nthpts))
               zu12(l) = 0.5*(zu(l)+zu(l-nthpts))
            enddo
         enddo
 
**      Finally ... <J-dot-B> / <B-dot-gradPhi>
        where (bdotgradv .ne. 0.) jdotb = jdotb/bdotgradv
      
         ndeg = nint(360.*(kz - 1)/nplots)
   30    format(a,i3,a)
         noxc = 0
 
         call pgsubp(2,2)

C###    PAGE # 1
         page = '1'

         pagedesc = 'Flux, Mod-B, Mesh, J Contours'
         if (makeplot(explist,lenlist,page,pagedesc)) then
           kz1=kz
           nplt1=nplots
           xlabel='R (m)'
           ylabel='Z (m)'
           zlabel='\(2267)\gF Contours'
           phit = 2.0_rprec*pi/real(nfp*nplt1,kind=rprec)* 
     &       real((kz1-1),kind=rprec)
           write(nchar,'(f5.1)')phit*180/real(pi)*nfp
           mtitle='N\dfp\u\(0647)= '//adjustl(nchar)
           labelformat='(2h L ,1pe9.2)'
           call pgpcontour(r(nthpts+1),
     &         z(nthpts+1), sqrt_phim(nthpts+1),
     &         nthpts,ns-1,ncon(1), ivar(1),
     &         kz1, nplt1, runlabel,
     &         xlabel,ylabel,zlabel,mtitle)
           zlabel='MOD-B CONTOURS'
           call pgpcontour (r(nthpts+1),
     &         z(nthpts+1),  modb(nthpts+1),
     &         nthpts,ns-1,ncon(3), ivar(2), 
     &         kz1, nplt1, runlabel,
     &         xlabel,ylabel,zlabel,mtitle)
           zlabel='\gF and \gH CONTOURS'
           call pgpcontour (r(nthpts+1),
     &         z(nthpts+1),  phim(nthpts+1),
     &         nthpts,ns-1,ncon(1), ivar(3),
     &         kz1, nplt1, runlabel,
     &         xlabel,ylabel,zlabel,mtitle)
         zlabel= 'CONTOURS OF RJ\.\(2266)[\gQ]'
         call pgpcontour (r(nthpts+1),
     &         z(nthpts+1),  torcur(nthpts+1),
     &         nthpts,ns-1,ncon(3), ivar(2),
     &         kz1, nplt1, runlabel,
     &         xlabel,ylabel,zlabel,mtitle)
         endif !makeplot  PAGE # 1
C###    PAGE # 2
         if (page .ne. '1')goto 8020
         page = '2'

         pagedesc = 'Jacobian Contours & Midplane Slices'
         if (.not.makeplot(explist,lenlist,page,pagedesc)) goto 8020
           zlabel='JACOBIAN CONTOURS'
           call pgpcontour (r12(nthpts+1), 
     &         z12(nthpts+1),  gsqrt(nthpts+1),
     &         nthpts,ns-1,ncon(1), ivar(1), 
     &         kz1, nplt1, runlabel,
     &         xlabel,ylabel,zlabel,mtitle)
 
           xlabel='R (m)'
           ylabel='MidPlane Values'
           zlabel= 'CONTOURS OF RJ\.\(2266)[\gQ]'
         call midplpt
     &      (real(r(1:nrt)),real(torcur(1:nrt)),
     &       nthpts,ns,xlabel,ylabel,zlabel,runlabel)
           zlabel='MOD-B CONTOURS'
         call midplpt
     &      (real(r(1:nrt)),real(modb(1:nrt)),
     &       nthpts,ns,xlabel,ylabel,zlabel,runlabel)
           zlabel='JACOBIAN CONTOURS'
         call midplpt
     &      (real(r(1:nrt)),real(gsqrt(1:nrt)),
     &       nthpts,ns,xlabel,ylabel,zlabel,runlabel)
 8020    continue  !  PAGE # 2
C###    PAGE # 3
         page = '3'
         pagedesc = 'Boundary Errors'

         if(.not.lfreeb)goto 8021
         if (.not.makeplot(explist,lenlist,page,pagedesc)) goto 8021

 8021    continue  !PAGE # 3
      enddo !kz
      call newframe
*
*                 COMPUTE EQUILIBRIUM PROFILES
*
 
      phin(:ns) = abs(phi(:ns))
 
C###    PAGE # 4
      page = '4'

      pagedesc = 'Convergence, Magnetic Axis'
      if (makeplot(explist,lenlist,page,pagedesc)) then
      wdot(1) = wdot(2)
      fsqt(1) = fsqt(2)
      itfsq = min(itfsq, 100)
      do j = 1, itfsq
         time(j) = real(niter*(j - 1))/real(itfsq - 1)
      enddo

      noxc = 1
      ndata = 0
      xlabel= 'ITERATIONS'
      ylabel='\(2268)F\u2\d dV '
      zlabel='RESIDUAL FORCE'
      call loggraf1
     &(real(time(1:)),real(fsqt(1:)),
     &itfsq,xlabel,ylabel,zlabel,runlabel)

      xlabel= 'ITERATIONS'
      ylabel='-dW/dt'
      zlabel='ENERGY MINIMIZATION'
      call loggraf1
     &(real(time(1:)),real(wdot(1:)),
     &itfsq,xlabel,ylabel,zlabel,runlabel)


*
*                 COMPUTE R,Z MAGNETIC AXES VS. TOROIDAL ANGLE
*
      if (ntor .ne. 0) then
         ns1 = 1
         do kz = 1, nplot1
            call totz (ntheta1, ns1, nplot1-1, kz, r, z, rmnc, 
     1         zmns, rmns, zmnc)
            time(kz) = real(kz - 1)/real(nplot1-1)
            raxis_v(kz) = r(ntheta1)
            zaxis_v(kz) = z(ntheta1)
         enddo


         zlabel='MAGNETIC AXIS (R)'
         xlabel='N\dfp\u\gF/2\gp' 
         ylabel='R\dM\u(\gF) (m)'
         call graf1
     &      (real(time(1:nplot1)),real(raxis_v(1:nplot1)),
     &       nplot1,xlabel,ylabel,zlabel,runlabel)

         zlabel='MAGNETIC AXIS (Z)'
         xlabel='N\dfp\u\gF/2\gp' 
         ylabel='Z\dM\u(\gF) (m)'
         call graf1
     &    (real(time(1:nplot1)),real(zaxis_v(1:nplot1)),
     &    nplot1,xlabel,ylabel,zlabel,runlabel)

 8022 continue
      endif
         endif !makeplot  PAGE # 4

C###    PAGE # 5
         page = '5'
         pagedesc = 'Stability and Curvatures'
      if (makeplot(explist,lenlist,page,pagedesc)) then

      specw(1) = 2.*specw(2) - specw(3)
      phinorm = maxval(abs(phi(:ns)))
      phin(:ns) = abs(phi(:ns)/phinorm)


      zlabel='SPECTRAL WIDTH'
      ylabel= '<M>'
      xlabel='\gF'
      call graf1
     &  (real(phin(1:)),real(specw(1:)),
     &  ns,xlabel,ylabel,zlabel,runlabel)
 8023 continue


        zlabel='MERCIER'
        ylabel= 'ArcSinh D\dM\u'
        xlabel='\gF'
        dummy2=0
        dummy2(3:ns)=log( dmerc(3:ns) + sqrt( dmerc(3:ns)**2+1 ) )!arcsinh
        call graf1x
     &   (real(phin(3:)),real(dummy2(3:)),
     &   ns-4,xlabel,ylabel,zlabel,runlabel)

        zlabel='SHEAR and WELL'
        ylabel= 'D\dS\u'
        fdum='D\dW\u'
        xlabel='\gF'
        call graf2x
     &  (real(phin(3:)),real(dshear(3:)),real(dwell(3:)),
     &  ns-4,xlabel,ylabel,fdum,zlabel,runlabel)

        zlabel='CURRENT and GEODESIC'
        ylabel= 'D\dcur\u'
        fdum='D\dgeo\u'
        xlabel='\gF'
        call graf2x
     &   (real(phin(3:)),real(dcurr(3:)),real(dgeod(3:)),
     &   ns-4,xlabel,ylabel,fdum,zlabel,runlabel)

      endif  ! makeplot C###    PAGE # 5


C###    PAGE # 6
      page = '6'
      pagedesc = 'Fluxes, Iota, Well'
      if (makeplot(explist,lenlist,page,pagedesc)) then
 
         do j = 1, ns
            br(j) = hs*(j - 1)
         enddo
         ndata = 0
         zlabel='TOROIDAL FLUX'
         ylabel= '\gF'
         xlabel='s'
         call graf1
     &   (real(br(1:)),real(phin(1:)),
     &   ns,xlabel,ylabel,zlabel,runlabel)
         t1 = 0.5*twopi*hs
         do j = 2, ns
            bz(j) = iotas(j)
            br(j) = br(j-1) + t1*phip(j)*(iotas(j)+iotas(j-1))
         enddo
         zlabel='POLOIDAL FLUX'
         ylabel= '\gx'
         xlabel='\gF'
         call graf1
     &    (real(phin(1:)),real(br(1:)),
     &    ns,xlabel,ylabel,zlabel,runlabel)
         a0 = 1.5*bz(2) - .5*bz(3)
         an = 1.5*bz(ns) - .5*bz(ns-1)
CDIR$   IVDEP
         bz(2:ns-1) = .5*(bz(2:ns-1)+bz(3:ns))
         br(2:ns-1) = 1./bz(2:ns-1)
         bz(1) = a0
         if (a0 .ne. 0.) br(1) = 1./a0
         bz(ns) = an
         br(ns) = 1./an
         br(:ns) = abs(br(:ns))
         bz(:ns) = abs(bz(:ns))
         zlabel='IOTA'
         ylabel= '\gi'
         fdum='Safety Factor'
         xlabel='\gF'
         call graf2x
     &     (real(phin(1:)),real(bz(1:)),real(br(1:)),
     &     ns,xlabel,ylabel,fdum,zlabel,runlabel)
         bz(:ns) = (ub(:ns)-ub(1))/ub(1)
         zlabel='MAGNETIC WELL ?? AND INVERSE'
         write(nchar,fmt='(1h'')')
         ylabel= '[V'//nchar(1:1)//nchar(1:1)//'(\gF)- V'
         ylabel=trim(ylabel)//nchar(1:1)//nchar(1:1)//'(0)]'
         ylabel=trim(ylabel)//' \(2770) V'//nchar(1:1)//'(0)'
         fdum='what is this?'
         xlabel='\gF'
         call graf2x
     &     (real(phin(1:)),real(br(1:)),real(bz(1:)),
     &     ns,xlabel,ylabel,fdum,zlabel,runlabel)
 
         endif !makeplot  PAGE # 6


C###    PAGE # 7
      page = '7'
      pagedesc = 'Mass, Pressure, Beta, Pol. Cur vs phi'
      if (makeplot(explist,lenlist,page,pagedesc)) then
C      print *,'VolAvgB, RBtor0, RBtor, Aminor, Rmajor, Volume,itor'
C      print *,VolAvgB, RBtor0, RBtor, Aminor, Rmajor, Volume,itor

            ndata = 0

         zlabel='MASS'
         ylabel= 'M(\gF)'
         xlabel='\gF'
         call graf1
     &     (real(phin(1:)),real(mass(1:)),
     &     ns,xlabel,ylabel,zlabel,runlabel)
         xlabel="('R\(0210)B\dt\u/R=',f5.2,1hT,' A=',f5.2)"
         write(ylabel,fmt=xlabel)RBtor/ Rmajor,  Rmajor/ Aminor
         call pgmtxt('T',0.9,0.5,0.5,trim(ylabel))
 

         zlabel='PRESSURE'
         ylabel= 'P(\gF)'
         xlabel='\gF'
         call graf1
     &     (real(phin(1:)),real(pres(1:)),
     &     ns,xlabel,ylabel,zlabel,runlabel)
         xlabel=
     &  "('R\(0210)B\d1\u=',f5.2,x,'R\(0210)B\d0\u=',f5.2,4h m-T)"
         write(ylabel,fmt=xlabel)RBtor, RBtor0
         call pgmtxt('T',0.9,0.5,0.5,trim(ylabel))

         zlabel='BETA'
         ylabel= '<\gb>'
         xlabel='\gF'
         call graf1
     &     (real(phin(1:)),real(beta_vol(1:)),
     &     ns,xlabel,ylabel,zlabel,runlabel)
         xlabel="('<\gb>=',f5.2,1h%,x,'<B>=',f5.2,1hT)"
         write(ylabel,fmt=xlabel)wp/wb*100.,volavgb
         call pgmtxt('T',0.9,0.5,0.5,trim(ylabel))

         zlabel='POLOIDAL CURRENT DENSITY'
         ylabel= '<J\.\(2266)\gh>'
         xlabel='\gF'
         call graf1
     &     (real(phin(1:)),real(jcuru(1:)),
     &     ns,xlabel,ylabel,zlabel,runlabel)
         xlabel="('<R>=',f5.2,1hm,x,'V=',f5.2,'m\u3\d')"
         write(ylabel,fmt=xlabel)Rmajor,Volume
         call pgmtxt('T',0.9,0.5,0.5,trim(ylabel))
 
         endif !makeplot  PAGE # 7

 

C###    PAGE # 8
      page = '8'
      pagedesc = 'Jtor , J|| & Itor vs phi'
      if (makeplot(explist,lenlist,page,pagedesc)) then
 
         ndata = 0
         zlabel='FLUX-AV. JTOR (A/m\u2\d)'
         ylabel= '<J\.\(2266)\(0647)>\(2770)<R\u-1\d>'
         xlabel='\gF'
         call graf1
     &     (real(phin(1:)),real(jcurv(1:)),
     &     ns,xlabel,ylabel,zlabel,runlabel)


         zlabel='<J\.B>\(2770)<B\.\(2266)\(0647)>'
         ylabel= 'Amps/m'
         xlabel='\gF'
         call graf1
     &     (real(phin(1:)),real(jdotb(1:)),
     &      ns,xlabel,ylabel,zlabel,runlabel)


         zlabel='TOROIDAL CURRENT'
         ylabel= 'I\dTOR\u'
         xlabel='\gF'
         call graf1
     &     (real(phin(1:)),real(itors(1:)),
     &     ns,xlabel,ylabel,zlabel,runlabel)
 
      endif !makeplot  PAGE # 8
      call newframe
 
C###    PAGE # 9
      page = '9'
      pagedesc = 'Local Force Balance'
      if (makeplot(explist,lenlist,page,pagedesc)) goto 3001 ! outdated format
      if (makeplot(explist,lenlist,page,pagedesc)) then
         nzeta=ntor*2+4           ! guess sizes and then check
         ntheta=mpol*2+6
         ntheta2=1+(2*(ntheta/2))/2
         nznt=(1+ntheta2/2)*(nzeta/2)
         nx=ns/2; ny=nzeta*ntheta2/4 +4
         ntht=ntheta2/2+1
         nsurf=ns/2
         nphi=nzeta/2  ! assume old defaults!
         jxbcode=2
         fname='jxbout.'//trim(input_id)
         call read_jxbout(lka, jsupu, jsupv, jsups, 
     1    bsupu, bsupv, jcrossb, pprime, residual12, 
     2    bdotj, bsubu, bsubv, bsubs, 
     3    hshere, avforce, aminfor, amaxfor,
     4    ns, nznt, mpol, ntor, trim(fname),
     5    nsurf , ntht , nphi , jxbcode)
         if (jxbcode.eq.1) then
          nznt1=ntht*nphi
          allocate(bsupu(nsurf,nznt1),bsupv(nsurf,nznt1), 
     1     bsubu(nsurf,nznt1), bsubv(nsurf,nznt1), bsubs(nsurf,nznt1), 
     2     residual12(nsurf,nznt1), bdotj(nsurf,nznt1), 
     3     jsupu(nsurf,nznt1), lka(nsurf,nznt1), jcrossb(nsurf,nznt1),
     4     jsupv(nsurf,nznt1), xfres12(nsurf,nznt1),
     5      pprime(nsurf,nznt1), jsups(nsurf,nznt1))
         allocate(avforce(nsurf), hshere(nsurf),iplot(nsurf), 
     1     amaxfor(nsurf), aminfor(nsurf),xplot(nsurf),yplot(nsurf))
         nx=nsurf; ny=nznt1
         fname='jxbout.'//trim(input_id)
         call read_jxbout(lka, jsupu, jsupv, jsups, 
     1    bsupu, bsupv, jcrossb, pprime, residual12, 
     2    bdotj, bsubu, bsubv, bsubs, 
     3    hshere, avforce, aminfor, amaxfor,
     4    ns, nznt, mpol, ntor, trim(fname),
     5    nsurf , ntht , nphi , jxbcode)
         aminfor=avforce*aminfor/100
         amaxfor=avforce*amaxfor/100

        elseif(jxbcode.eq.3)then
         nsurf=ns/2; nznt1=(1+ntheta2/2)*(nzeta/2)
          allocate(bsupu(nsurf,nznt1),bsupv(nsurf,nznt1), 
     1     bsubu(nsurf,nznt1), bsubv(nsurf,nznt1), bsubs(nsurf,nznt1), 
     2     residual12(nsurf,nznt1), bdotj(nsurf,nznt1), 
     3     jsupu(nsurf,nznt1), lka(nsurf,nznt1), jcrossb(nsurf,nznt1),
     4     jsupv(nsurf,nznt1), xfres12(nsurf,nznt1),
     5      pprime(nsurf,nznt1), jsups(nsurf,nznt1))
         allocate(avforce(nsurf), hshere(nsurf),iplot(nsurf), 
     1     amaxfor(nsurf), aminfor(nsurf),xplot(nsurf),yplot(nsurf))
         fname='jxbout.'//trim(input_id)
         call read_old_jxbout(lka, jsupu, jsupv, jsups, 
     1    bsupu, bsupv, jcrossb, pprime, residual12, 
     2    bdotj, bsubu, bsubv, bsubs, 
     3    hshere, avforce, aminfor, amaxfor,
     4    ns, nznt, ntheta2, nzeta, trim(fname),
     5    nsurf , ntht , nphi , jxbcode)
         nx=nsurf; ny=nznt1
        endif
        if (jxbcode.ne.0)goto 3001
         nzeta=ntor*2+4           ! retuned from read_jxbout
         ntheta=mpol*2+6
         ntheta2=1+(2*(ntheta/2))/2
         nznt=(1+ntheta2/2)*(nzeta/2) ! want this many and have nznt1
        kt=1+(nznt1-1)/((1+ntheta2/2)*(nzeta/2))
C        kt=1+(nznt1-1)/(ntht*nphi)
        kz=max(1+2*(kt/2),5)
        allocate(pang(ntheta2+1),tang(nzeta))
        do i=1,nznt1       
           itheta = 1 + lka(nx/2,i)/nzeta
           izeta = 1 + mod(lka(nx/2,i)-1,nzeta)
           pang(itheta)=pi*float((itheta-1))/ntheta2
           tang(izeta)=2.*pi*(izeta-1)/nzeta/nfp
        enddo
         zlabel='<j\xB Force>'
         ylabel= '\(2229)JxB-p''\(2229)'
         xlabel='s'
         call loggraf3pt
     &   (real(hshere(1:)),
     &    real(abs(aminfor(1:))),
     &    real(abs(avforce(1:))),
     &    real(abs(amaxfor(1:))),
     &    nx,xlabel,'\(2229)\fiMIN\fn\(2229)',ylabel,
     &    '\(2229)\fiMAX\fn\(2229)',zlabel,runlabel)



         zlabel='<j\xB Force>'
         ylabel= 'J\xB-p'''
         xlabel='s'
         call graf1pt
     &     (real(hshere(1:)),real(avforce(1:)),
     &     size(aminfor(1:)),xlabel,ylabel,zlabel,runlabel)
      print *,'hshere ',size(hshere), maxval(hshere), minval(hshere)
      print *,'avforce ',size(avforce), maxval(avforce), minval(avforce)

         zlabel='Min j\xB Force'
         ylabel= 'J\xB-p'''
         xlabel='s'
         call graf1pt
     &     (real(hshere(1:)),real(aminfor(1:)),
     &     size(aminfor(1:)),xlabel,ylabel,zlabel,runlabel)

         zlabel='Max j\xB Force'
         ylabel= 'J\xB-p'''
         xlabel='s'
         call graf1pt
     &     (real(hshere(1:)),real(amaxfor(1:)),
     &     size(aminfor(1:)),xlabel,ylabel,zlabel,runlabel)
CASCADE
        call pgsave
        call pgsubp(1,1)
        call pgpap(9.,8.5/11.)
        xfres12=abs(residual12)
        xmin=0
        xmax=1
        ymin=minval(xfres12)
        ymax=maxval(xfres12)
        xspread=1.
        yspread=maxval(xfres12)-minval(xfres12)
        xxspread=xspread/ntheta2/kt
        yyspread=yspread/ntheta2/kt
        xxspread=xspread/ntht/kt
        yyspread=yspread/ntht/kt
        deltx=real(hshere(2)-hshere(3))
        nspread=nint(xxspread/deltx)
        xxspread=1.*nspread*deltx
        maxc=nznt1
        ymmin=ymin
        ymmax=ymax+maxc*yyspread
        xmmin=0
        xmin=0
        xmax=1
        xmmax=1.6 + maxc*xxspread
        call pgsci(1)
        call pgpage
        call pgsvp(.1,.9,.1,.9) ! set original window size
        call pgswin(xmmin,xmmax,ymmin,ymmax) ! set original data limits
        call pgbox('bc',0.,0,'bc',0.,0) !display world box
        call xywtoxyan(xmin,ymin,x1,y1)  ! make coordinate labels
        call xywtoxyan(xmax,ymax,x2,y2)
        call pgsvp(x1,x2,y1,y2)  ! little box for world units
        call pgswin(xmin,xmax,ymin,ymax) ! limits for world units
        call pgsch(.79)
        call pgbox('BINT',.25,4,'BVINT',1.,2) !box for world units
        call pgsvp(.1,.9,.1,.9) ! reset to original size
        call pgswin(xmmin,xmmax,ymmin,ymmax) ! set world units for full box
        ylabel='Residual'
        zlabel= '2\.|JxB-p''|'
        zlabel=trim(zlabel)//' / [|JxB|+|p''|]'
        xlabel='s'
        call pgqch(siz)
        call pgsch(siz-.1)
        call pgmtxt('B',2.25,0.5,0.5,trim(runlabel))
        call pgsch(siz)
        call pglab(xlabel,ylabel,zlabel)
        write(pchar,fmt='(a,1pe9.2)')'Plane is at ',ymin
        call pgtext(xmmin+2*xxspread,ymmax-2*kt*yyspread,pchar)
        write(pchar,fmt='(a,1pe9.2)')'Maximum Residual is  ',ymax
        call pgtext(xmmin+2*xxspread,ymmax-4*kt*yyspread,pchar)
        write(pchar,fmt='(a)')'(\gh/\gp,\gz/\gp/N\dFP\u) pairs'
        call pgtext(xmmin+2*xxspread,ymmax-8*kt*yyspread,pchar)
        call pgsci(15)
        call pgsch(.68)
        xplot(1)=0.
        yplot(1)=ymin
        xplot(2)=xxspread*maxc
        yplot(2)=maxc*yyspread                         
        xplot(3)=1.+xplot(2)
        yplot(3)=yplot(2)
        xplot(4)=1
        yplot(4)=yplot(1)
        call pgpoly(4,xplot,yplot)  ! draw reference plan, full box
        call pgsci(2)
        call pgsci(1)
        ymmin=ymin
        ymmax=ymax
        do 2500 i=1,nznt1
         itheta = (1 + lka(nx,i)/nzeta)
         izeta = 1 + mod(lka(nx,i)-1,nzeta)
           write(xlabel,fmt='(a,f4.2,a1,f4.2,a1)')
     &    '(',
     &      1.*(itheta-1)/ntheta2,',',2.*(izeta-1)/nzeta/nfp,')'
             xlabel=' ..'//trim(xlabel)
         ic = i - ((i-1) / maxc) * maxc
         yzero = (maxc-i)*yyspread
         xplot(1:nx)=real(hshere(1:nx))+ (maxc-ic)*xxspread
         yplot(1:nx)=(real(xfres12(1:nx,i)+ (maxc-ic)*yyspread))
         call pgsci(1+modulo(i,kz))
         call pgline(nx,xplot,yplot)
         if(1+modulo(i,1+2*(kt/2)).eq.1)
     &     call pgtext(xplot(nx),yzero,trim(xlabel))
2500     continue
        xfres12=abs(residual12)
        ymin=minval(xfres12)
        ymax=maxval(xfres12)
        if(ymin.eq.0.)xfres12=xfres12+1.e-6
        xfres12=log10(xfres12)
        xspread=1.
        yspread=maxval(xfres12)-minval(xfres12)
        xxspread=xspread/ntheta2/kt
        yyspread=yspread/ntheta2/kt
        deltx=real(hshere(2)-hshere(3))
        nspread=nint(xxspread/deltx)
        xxspread=1.*nspread*deltx
        ymax=maxval(xfres12)
        ymin=minval(xfres12)
        ymin=ymax-3  ! set # decades
        maxc=nznt1

        ymmin=ymin
        ymmax=ymax+maxc*yyspread
        xmmin=0
        xmin=0
        xmax=1
        xmmax=1.6 + maxc*xxspread
        call pgsci(1)
        call pgpage
        call pgsvp(.1,.9,.1,.9) ! set original window size
        call pgswin(xmmin,xmmax,ymmin,ymmax) ! set original data limits
        call pgbox('bc',0.,0,'bc',0.,0) !display world box
        call  xywtoxyan(xmin,ymin,x1,y1)  ! make coordinate labels
        call  xywtoxyan(xmax,ymax,x2,y2)
        call pgsvp(x1,x2,y1,y2)  ! little box for world units
        call pgswin(xmin,xmax,ymin,ymax) ! limits for world units
        call pgsch(.79)
        call pgbox('BINT',.25,4,'BVSILNT',0.5,1) !box for world units
        call pgsvp(.1,.9,.1,.9) ! reset to original size
        call pgswin(xmmin,xmmax,ymmin,ymmax) ! set world units for full box
        ylabel='Log\d10\u Residual'
        zlabel= '2\.|JxB-p''|'
        zlabel=trim(zlabel)//' / [|JxB|+|p''|]'
        xlabel='s'
        call pgqch(siz)
        call pgsch(siz-.1)
        call pgmtxt('B',2.25,0.5,0.5,trim(runlabel))
        call pgsch(siz)
        call pglab(xlabel,ylabel,zlabel)
        write(pchar,fmt='(a,1pe9.2)')'Plane is at ',10**ymin
        call pgtext(xmmin+2*xxspread,ymmax-2*kt*yyspread,pchar)
        write(pchar,fmt='(a,1pe9.2)')'Maximum Residual is  ',10**ymax
        call pgtext(xmmin+2*xxspread,ymmax-4*kt*yyspread,pchar)
        write(pchar,fmt='(a)')'(\gh/\gp,\gz/\gp/N\dFP\u) pairs'
        call pgtext(xmmin+2*xxspread,ymmax-8*kt*yyspread,pchar)
        call pgsci(15)
        call pgsch(.68)
        xplot(1)=0.
        yplot(1)=ymin
        xplot(2)=xxspread*maxc
        yplot(2)=ymin+maxc*yyspread                         
        xplot(3)=1.+xplot(2)
        yplot(3)=yplot(2)
        xplot(4)=1
        yplot(4)=yplot(1)
        call pgpoly(4,xplot,yplot)  ! draw reference plan, full box
        call pgsci(2)
        call pgsci(1)
        ymmin=ymin
        ymmax=ymax
        do 3000 i=1,nznt1
         itheta = (1 + lka(nx,i)/nzeta)
         izeta = 1 + mod(lka(nx,i)-1,nzeta)
           write(xlabel,fmt='(a,f4.2,a1,f4.2,a1)')
     &    '(',
     &      1.*(itheta-1)/ntheta2,',',2.*(izeta-1)/nzeta/nfp,')'
             xlabel=' ..'//trim(xlabel)
         ic = i - ((i-1) / maxc) * maxc
         yzero = (maxc-i)*yyspread
         xplot(1:nx)=real(hshere(1:))+ (maxc-ic)*xxspread
         yplot(1:nx)=(real(xfres12(1:nx,i)+ (maxc-ic)*yyspread))
         call pgsci(1+modulo(i,kz))
         ymin=ymmin+(maxc-ic)*yyspread
         ymax=ymmax+(maxc-ic)*yyspread
         iplot=.false.
         where(yplot(1:nx).ge.ymin)
          iplot=.true.
         endwhere

         k=0
         l=k+1
         alldone=.false.
         segments:do
         alldone=.true.
         addon=k+1.lt.nx
         l=k+1
         do j=k+1,nx
            if(addon.and.iplot(j)) then
               addon=.false.
               l=j
            endif
         enddo
         addon=.true.
         do j=l+1,nx
            if(addon.and.iplot(j)) then
               k=j
            else
               addon=.false.
            endif
         enddo
         if(k.gt.l)call pgline(k-l+1,xplot(l:k),yplot(l:k))
         if(alldone.and.l.lt.nx)alldone=.false.
         if(alldone)exit segments
         if(iplot(l) .and. (.not.iplot(l+1)))then
           call pgpt1(xplot(l),yplot(l),-2)
           k=k+1
         endif
         l=k
         enddo segments
         if(1+modulo(i,1+2*(kt/2)).eq.1)
     &     call pgtext(xplot(nx),ymin,trim(xlabel))
3000   continue

CASCADE
         call pgunsa
         call pgsubp(2,2)
         call pgpap(8.5,1.)
         call pgsch(1.85)

      endif          !makeplot  PAGE # 9
      call newframe

 3001 continue

      if(allocated(  tang))deallocate(   tang)       
      if(allocated(  pang))deallocate(   pang)
      if(allocated(bsubu))deallocate(bsubu)
      if(allocated(bsubu))deallocate(bsubu)
      if(allocated(bsubv))deallocate(bsubv)
      if(allocated(bsubs))deallocate(bsubs)
      if(allocated(residual12))deallocate(residual12)
      if(allocated(bdotj))deallocate(bdotj)
      if(allocated(jsupu))deallocate(jsupu)
      if(allocated(lka))deallocate(lka)
      if(allocated(jcrossb))deallocate(jcrossb)
      if(allocated(jsupv))deallocate(jsupv)
      if(allocated(xfres12))deallocate(xfres12)
      if(allocated(pprime))deallocate(pprime)
      if(allocated(jsups))deallocate(jsups)
      if(allocated(avforce))deallocate(avforce)
      if(allocated(hshere))deallocate(hshere)
      if(allocated(iplot))deallocate(iplot)
      if(allocated(amaxfor))deallocate(amaxfor)
      if(allocated(aminfor))deallocate(aminfor)
      if(allocated(xplot))deallocate(xplot)
      if(allocated(yplot))deallocate(yplot)

C###    PAGE # 10
      page = '10'
      pagedesc = '|B| Spectrum'
      if (makeplot(explist,lenlist,page,pagedesc)) then
      iunit=110
      if(ns==0)ns=49
      call safe_open (iunit, istat, 'in_booz.' // trim(input_id), 
     1     'unknown','formatted')
      mboz=17
      nboz=9
      write(iunit,fmt='(2i4.3)')mboz,nboz
      write(iunit,fmt='(a)')trim(input_id)
      write(iunit,fmt='(4(i3.3,x))')2,ns/3,2*ns/3,ns-1
      close(iunit)
      fname='$HOME/bin/xbooz_xform in_booz.' // trim(input_id)//' F'
c      fname=trim(fname)//'; \rm in_booz.' // trim(input_id)
      call system(trim(fname),istat)
      if(istat/=0)stop 'xbooz_xform'
      iunit=120
      call safe_open (iunit, istat, 'boozmn.' // trim(input_id), 'old',
     1     'unformatted')
      if (istat .ne. 0) then
         write(6,*)' istat = ', istat
         stop 'Error opening boozmn file in XBOOZ_XFORM!'
      endif   
      read(iunit, iostat=ierr, err=1000) 
     1   nfpb, nsb, aspectb, rmax_surfb, rmin_surfb, betaxisb

      js=nsb;allocate(hiota(js), presb(js), jlistb(ns),
     1   beta_volb(js), phipb(js),  phib(js), bvcob(js),  bucob(js))

      do js = 2, nsb
         read(iunit, iostat=ierr, err=1000) hiota(js), presb(js), 
     1   beta_volb(js), phipb(js),  phib(js), bvcob(js),  bucob(js)
      enddo
      read(iunit, iostat=istat, err=1000) mboz, nboz, mnboz
      read(iunit, iostat=istat, err=1000) versionb
      allocate ( xmb(mnboz) , xnb(mnboz), bmnb(ns,mnboz), 
     &  rmnb(ns,mnboz), zmnb(ns,mnboz), pmnb(ns,mnboz))
      iread=0
999   read(iunit, iostat=istat, err=1000, end=1010) jrad
      iread=iread+1 ! # surfaces in data file at statement 1010
      jlistb(iread)=jrad
      if(first) then
         first = .false.
         do mn = 1,mnboz
            read(iunit, iostat=istat) nb, mb
            xmb(mn)=one * mb
            xnb(mn)=one * nb
            nb=nb/nfp
         enddo 
       endif
       do mn = 1, mnboz
         read(iunit, iostat=istat) bmnb(jrad,mn), rmnb(jrad,mn), 
     &       zmnb(jrad,mn), pmnb(jrad,mn)
         if(xnb(mn).eq.0..and.abs(xmb(mn)).lt.7.) write(6,
     &  fmt="('n=',i3,' m=',i3,' B=',1pe9.2,' s=',1pe9.2)")
     &  nint(xnb(mn)),nint(xmb(mn)),bmnb(jrad,mn), phi(jrad)/phi(ns)
       enddo
       goto 999
 1010 continue
      call pgpap(8.,1.)
      call pgsubp(2,2)
      do js=1,4
        write(pchar,fmt='(2(a,1pe9.2))')'\gi = ',hiota(jlistb(js)),
     &   ' s = ',phi(jlistb(js))/phi(ns)
        write(mchar,fmt="('B\d0,0\u=',1pe10.3)")bmnb(jlistb(js),1)
       call bdots(js,nfp,jlistb(js),mnboz,real(xnb(1:)),real(xmb(1:)),
     & real(bmnb(jlistb(js),1:)),'n','m',pchar,input_id,mchar)
      enddo
      goto 1111
 1000 continue
      write(6,*) 'reading error'
 1111 continue
      
      endif !          endif !makeplot  PAGE # 10

C###    PAGE # 16    ! differs considerably from the original
      page = '16'
      pagedesc = 'R,Z,Lamba Profiles'
      if (makeplot(explist,lenlist,page,pagedesc)) then
         dummy1(1:mnmax,1)=((/(i,i=1,mnmax)/))
         do i=1,mnmax
           dummy2(i)=abs(maxval(rmnc(i,1:ns))-minval(rmnc(i,1:ns)))
         enddo
         xlabel= 'mode #'
         ylabel='Max[R\dmn\uC\dmode\u]'
         zlabel='Maximum Amplitude'

         call loggrafpt
     &    (real(dummy1(1:mnmax,1)),real(dummy2(1:mnmax)),
     &    mnmax,xlabel,ylabel,zlabel,runlabel)

         dummy1(1:mnmax-1,1)=((/(i,i=2,mnmax)/))
         do i=2,mnmax
           j=i-1
           dummy2(j)=abs(maxval(zmns(i,1:ns))-minval(zmns(i,1:ns)))
         enddo
         if(minval(dummy2(1:mnmax-1)).eq.0.)then
          small=maxval(dummy2(1:mnmax-1))/1.e8
          dummy2(1:mnmax-1)=dummy2(1:mnmax-1)+small
         endif
         xlabel= 'mode #'
         ylabel='Max[Z\dmn\uS\dmode\u]'
         zlabel='Maximum Amplitude'
         call loggrafpt
     &    (real(dummy1(1:mnmax-1,1)),real(dummy2(1:mnmax-1)),
     &    mnmax-1,xlabel,ylabel,zlabel,runlabel)
         if (iasym .eq. 1) then
           dummy1(1:mnmax,1)=((/(i,i=1,mnmax)/))
           do i=1,mnmax
             dummy2(i)=abs(maxval(rmnc(i,1:ns))-minval(rmnc(i,1:ns)))
           enddo
           xlabel= 'mode #'
           ylabel='Max[R\dmn\uC]'
           zlabel='Maximum Amplitude'

           call loggrafpt
     &      (real(dummy1(1:mnmax,1)),real(dummy2(1:mnmax)),
     &       mnmax,xlabel,ylabel,zlabel,runlabel)

           dummy1(1:mnmax,1)=((/(i,i=1,mnmax)/))
           do i=1,mnmax
             dummy2(i)=abs(maxval(zmns(i,1:ns))-minval(zmns(i,1:ns)))
           enddo
           if(minval(dummy2(1:mnmax)).eq.0.)then
             small=maxval(dummy2(1:mnmax))/1.e8
             dummy2(1:mnmax)=dummy2(1:mnmax)+small
           endif
           xlabel= 'mode #'
           ylabel='Max[Z\dmn\uS]'
           zlabel='Maximum Amplitude'
           call loggrafpt
     &       (real(dummy1(1:mnmax,1)),real(dummy2(1:mnmax)),
     &       mnmax,xlabel,ylabel,zlabel,runlabel)
         endif
      endif  !makeplot  PAGE # 16

      if(allocated( dummy1))deallocate( dummy1)
      if(allocated( dummy2))deallocate( dummy2)
      if(allocated(  r))deallocate(  r)
      if(allocated( z))deallocate( z)
      if(allocated( ru))deallocate( ru)
      if(allocated( modb))deallocate( modb)
      if(allocated( sqrt_phim))deallocate( sqrt_phim)
      if(allocated( phim))deallocate( phim)
      if(allocated( gsqrt))deallocate( gsqrt)
      if(allocated( torcur))deallocate( torcur)
      if(allocated( dbsubudstz))deallocate( dbsubudstz)
      if(allocated( bsubutz))deallocate( bsubutz)
      if(allocated( bsubvtz))deallocate( bsubvtz)
      if(allocated(  r12))deallocate(  r12)
      if(allocated( z12))deallocate( z12)
      if(allocated( ru12))deallocate( ru12)
      if(allocated( zu12))deallocate( zu12)

 8033 return

  150 format(a)
      end subroutine pgpplotter
      subroutine bdots
     .  (ipos,nfp,js,mnboz,xnb,xmb,bmnb,lx,ly,lt,runlbl,l2)
      character*(*) lx,ly,lt,runlbl,l2
      character*8 xopt,yopt
      real xnb(*),xmb(*),bmnb(*),r1,r2
      data r1/6./
      integer js,mnboz,nfp,ipos
      if(ipos==1)then
         call pgpap(8.,1.)
      endif
      xnb(1:mnboz)=xnb(1:mnboz)/nfp
      xmin=minval(xnb(1:mnboz))
      xmax=maxval(xnb(1:mnboz))
      ymin=minval(xmb(1:mnboz))
      ymax=maxval(xmb(1:mnboz))
      bmax=maxval(bmnb(1:mnboz))
      bmin=minval(bmnb(1:mnboz))
      ymin=0
      ymax=(xmax-xmin)+1.
         call pgbbuf
         call pgsch(1.5)
         call pgsci(1)
         call pgpage
         call pgvstd
c         call pgswin(xmin,xmax,ymin,ymax)
         call pgwnad(xmin,xmax,ymin,ymax)
         xopt='BCNST';yopt='BCNST'
         call pgbox(trim(xopt),0.,0,trim(yopt),0.,0)
         call pglab(trim(lx),trim(ly),trim(lt))
         call pgmtxt('T',0.9,0.5,0.5,trim(l2))
         call pgqch(siz)
         call pgsch(siz-.5)
         call pgmtxt('B',2.85,0.5,0.5,trim(runlbl))
         call pgsch(siz)
         do mn=1,mnboz
         if(bmnb(mn) < 0.) then
           call pgsci(4)
           call pgsfs(1)
         else
           call pgsci(2)
           call pgsfs(1)
         endif
         r=(r1+log10(abs(bmnb(mn))/bmax))/r1/2
c         if(r > 0)call pgcirc(xnb(mn),xmb(mn),r)
         if(r > 0)call 
     .   pgrect(xnb(mn)-r/2,xnb(mn)+r/2,xmb(mn)-r/2,xmb(mn)+r/2)
         enddo
         call pgebuf
         if(ipos/=4)return
         call xywtoxyan(0.,ymin,x1,y1)
         call xywtoxyan(1.,ymax,x2,y2)
         call xywtoxyan(xmax,ymin,x3,y3)
         call pgsvp(.91,.91+x2-x1,y1,y2)
         call pgswin(0.,1.,ymin,ymax)
         do i=1,7
          r=(r1+log10(1./10.**(i-1)))/r1/2
c          call pgcirc(.5,ymax-(ymax-ymin)*i/8,r)
          call pgrect(
     .    .5-r/2,.5+r/2,
     .    ymax-(ymax-ymin)*i/8-r/2,ymax-(ymax-ymin)*i/8+r/2)
         enddo
         call pgsci(1)
         call pgsch(1.8)
         call pgptxt(1.,ymin+(ymax-ymin)/4,270.,1.,
     /    'decade scale (red is +)')
!         end subroutine bdots
         end

      subroutine putstb
c
c
c     +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!




c     +++ PUTSTB:A subroutine that writes a transfer file FLNMO1    +++
c     +++        used by the EQGRUM equilibrium solver.             +++
c     +++                                                           +++
c     +++   Steve Sabbagh 1/ 3/94 Version 1.1                       +++
c     +++                                                           +++
c     +++        Small changes - status="new" changed to status=    +++
c     +++        "unknown" in open statement (for ATHENA) & now     +++
c     +++        supports 80 character filenames.                   +++
c     +++                                                           +++
c     +++   Steve Sabbagh 7/26/90 Version 1.0                       +++
c     +++                                                           +++
c     +++        Notes: Version 1.0: Writes "standard" stabil file  +++
c     +++           format in which profile are p, q, and psi.      +++
c     +++                                                           +++
c     +++        Adapted from the EQGRUM routine BALDIN by          +++
c     +++        M. Phillips. Serves as a BALDUR equilibrium        +++
c     +++        output file emulator.                              +++
c     +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c
c
c     +++ Dimension and common blocks for EQGRUM variables +++
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      use Vtraneq
      implicit none
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: ioutf, ishot, m, j, k
      real(kind=rprec) :: pad
C-----------------------------------------------
c======               START OF TRANEQ.BLK            =================
C
C   +++ See file EQOUT for definition of variables +++
C   +++                                            +++
C   +++ Note: There are two common blocks, EQCOM,  +++
C   +++  and EQFIL. The former passes numerical    +++
C   +++  data, while the latter passes character   +++
C   +++  data. The common block EQCOM has been     +++
C   +++  broken into parts for documentation       +++
C   +++  purposes. These blocks serve all of the   +++
C   +++  output codes which are interfaced.        +++
C   +++                                            +++
C   +++  Steve Sabbagh 9/11/90 Ver 1.0             +++
C   +++                1/02/91 Ver 1.1             +++
C   +++               12/30/93 Ver 1.2             +++
C   +++               08/30/94 Ver 1.3             +++
C   +++                 (80 character filenames)   +++
C   ++++++++++++++++++++++++++++++++++++++++++++++++++
C
c   +++ EQCOM common block +++
c   +++ 0) EQOUT input variables (number)
c
c   +++ 1) SHARED scalar variables +++
c
c   +++ 2) SHARED vector variables +++
c   +++      Note: r0b is a scalar +++
c
c   +++ 3) EQGRUM scalars +++
c
c   +++ 4) EQGRUM specific array variables +++
c
c   +++ 5) JSOLVER scalars +++
c
c   +++ 6) JSOLVER specific vector variables +++
c
c   +++ EQFIL common block +++
c
c   +++ J Profile & Beta Values
c
c
c     +++ Open output file +++
      open(unit=20, file=flnmo1, status='unknown')
c
c     +++ I/O channels +++
      ioutf = 20                                 ! output file LUN
c
c     +++ Initialize +++
      pad = 0.0                                  !Pad variable
      ishot = int(shotnm)                  !integer value of shot number
c
c     +++ Write EQGRUM transfer file 'stabil'  +++
c     +++ The following is adapted from BALDIN +++
      write (ioutf, 150) nequil, time, nstep
  150 format(' equilibrium',i5,' at time',1pe15.7,' nstep',i5)
c
      write (ioutf, 9060) ishot, time        !These banner lines replace
      write (ioutf, 9070) intord           !the label arrays used in the
      write (ioutf, 9080) thdfil                 !previous routine.
      write (ioutf, 9090)
      write (ioutf, 9100) pfilt1, pfilt2, pfilt3
c
      write (ioutf, 154) njav, mombnd, mom
  154 format(' mjbal=',i5,' mombnd=',i5,' mom=',i5)
c
      write (ioutf, 155) r0b
  155 format(' r0b=',1pe15.7)
c
      write (ioutf, 156) (rmb(m),m=1,mombnd)
  156 format(' rmb=',1p5e15.7)
c
      write (ioutf, 157) (ymb(m),m=1,mombnd)
  157 format(' ymb=',1p5e15.7)
c
      write (ioutf, 158) btor, rtor, eqcamp
  158 format(' btor=',1pe15.7,' rtor=',1pe15.7,' eqcamp=',1pe15.7)
c
      write (ioutf, 160)
  160 format(t3,'j',t10,'psi',t25,'q',t40,'d q / d psi',t55,'p',t70,
     1   'd p / d psi',t83,'<jdotb>/<bdotgradv>',t109,'FF''')
c
c      --- Write profile arrays --- (jdotbc is NEW)
c         Note: First array element is a guard point and will be
c               ignored when read in from STABIL file
      do j = ieqax - 1, ieqedg
         write (ioutf, 162) j, psi(j), q(j), dqdpsi(j), press(j), dpdpsi
     1      (j), jdotbc(j), ggp(j)
      enddo
c
c      --- Write dummy term on the end to satisfy BALDIN routine ---
      k = ieqedg + 1
      write (ioutf, 162) k, pad, pad, pad, pad, pad, pad
  162 format(1x,i4,1p7e15.7)
 
c      --- Write Beta values
      write (ioutf, 168) batot, bapol, bator, baxis
  168 format(' betatot=',1pe15.7,' betapol=',1pe15.7,' betator=',1pe15.7
     1   ,' betaxis=',1pe15.7)
 
c
c      +++ Close Files +++
      close(unit=20)
c
c      +++ Format Block +++
 9060 format(1x,'+++ TFTR Shot ',i6,' at ',1pe10.4,' seconds.  +++')
 9070 format(1x,'+++ TRANSP file:     Interpolation Order: ',i2,' +++')
 9080 format(1x,a80)
 9090 format(1x,'+++ Smoothing (%): Pressure     q      psi   +++')
 9100 format(1x,'+++                 ',f6.2,2x,f6.2,2x,f6.2,'   +++')

      end subroutine putstb

      subroutine read_jxbout(lka, jsupu, jsupv, jsups,
     1 bsupu1, bsupv1, jcrossb, pprime, r12, 
     2 bdotj, bsubua, bsubva, bsubs, 
     3 hs, avforce, aminfor, amaxfor,
     4 ns, nznt, ntheta2, nzeta, jxbout_file,
     5    nsurf , ntht , nphi , jxbcode)
C-----------------------------------------------
C jxbcode:
C -1 -- file not found
C -2 -- nsurf > ns
C -2 -- ntht  > ntheta2
C -2 -- nphi  > nzeta
C +3 -- may be old style file; try read_old_jxbout
C +2 -- reading for table size set to 1 on output
C +1 -- reading table of values
C  0 -- successful reading of data

C-----------------------------------------------
      use kind_spec
      use Vpname1, only: dmu0
      use safe_open_mod

      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer  ns, nznt , ntheta2, nzeta
      integer  nsurf , ntht , nphi , jxbcode
      real(kind=rprec), dimension(nsurf,*) :: 
     1 jsupu, jsupv, jsups, 
     2 bsupu1, bsupv1, jcrossb, pprime, r12, 
     3 bdotj, bsubua, bsubva, bsubs
      real(kind=rprec), dimension(*) :: 
     1 hs, avforce, aminfor, amaxfor
      integer, dimension(nsurf,*) :: lka
      character*(*) jxbout_file
C-----------------------------------------------
C   L o c a l   P a r a m e t e r s
C-----------------------------------------------
      real(kind=rprec), parameter :: p5 = 0.5d0, two = 2.0d0, c1p5=1.5d0
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer lk, lz, lt, k, m, js, j, n, injxbout
      integer :: njxbout, n1, n2
      character*30 :: filename, dummytxt*72
      real(kind=rprec) dum1, dum2 
      real(kind=rprec), dimension(:,:), allocatable ::
     1 bsubuv, bsubvu
      logical newfiletype, exists
C-----------------------------------------------
      if(jxbcode.eq.1)goto 1001
      call get_lun(njxbout)
      call safe_open(njxbout, injxbout, trim(jxbout_file), 'old',
     1     'formatted')
      if (injxbout .ne. 0) then
         write(6,*)' Error opening JXBOUT file in read_jxbout'
         jxbcode=-1
         call free_lun(njxbout)
         return
      endif   
  7    format(/,19x,i3.3,24x,i3.3,24x,i3.3,/,19x,i3.3,19x,i3.3)
      read (njxbout,7,err=1002) nsurf, ntht, nphi, ntheta2, nzeta
      goto 1003
1002    jxbcode=3
        close(njxbout,iostat=injxbout)
        call free_lun(njxbout)
        return
1003    jxbcode=1
        close(njxbout,iostat=injxbout)
        call free_lun(njxbout)
        return  !  for allocation
1001  continue
      allocate(bsubuv(ns,nznt),bsubvu(ns,nznt))
      injxbout=0
      call get_lun(njxbout)
      call safe_open(njxbout, injxbout, trim(jxbout_file), 'old',
     1     'formatted')
      if(injxbout/=0)stop 'jxbreading error'
      do j=1,15
       read (njxbout,fmt='(a)')dummytxt
      enddo

!
!     NOTE: bsubua, bsubva are the ALIASED (truncated Fourier spectrum)
!           versions of bsubu, bsubv. bsubuv, bsubvu are used to compute
!           radial current (should be zero) 
  200 format(/17x,1pe12.3,18x,1p
     1   e12.3,15x,1pe12.3,21x,1pe12.3,/,
     2   44x,sp,0pf6.1,4x,f6.1)
  110 format(i5,12(x,en10.3e2))
      do js = 1, nsurf
            read (njxbout, 200) hs(js), avforce(js)
     1         ,dum1, dum2, amaxfor(js), aminfor(js)
            read (njxbout,fmt='(a10)')dummytxt
            read (njxbout,fmt='(a10)')dummytxt
            read (njxbout,fmt='(a10)')dummytxt
            read (njxbout,fmt='(a10)')dummytxt
            read (njxbout,fmt='(a10)')dummytxt

 
            lk=0
            do lt = 1, ntht
               do lz = 1, nphi
                  lk = lk + 1
                  read (njxbout, 110) lka(js,lk), jsupu(js,lk),
     1              jsupv(js,lk), dum1, bsupu1(js,lk),  
     2              bsupv1(js,lk),jcrossb(js,lk), pprime(js,lk),
     3              dum2, bdotj(js,lk), bsubua(js,lk),
     4              bsubva(js,lk), bsubs(js,lk)
                  jsups(js,lk)=dmu0*dum1
                  r12(js,lk)=2._rprec*dum2/  !  nomalized residual
     1             (abs(jcrossb(js,lk))+abs( pprime(js,lk)))
               enddo
            enddo
      enddo
 
      close (njxbout)
      call free_lun(njxbout)
      deallocate(bsubuv,bsubvu)
      jxbcode=0
      end subroutine read_jxbout

      subroutine read_old_jxbout(lka, jsupu, jsupv, jsups,
     1 bsupu1, bsupv1, jcrossb, pprime, r12, 
     2 bdotj, bsubua, bsubva, bsubs, 
     3 hs, avforce, aminfor, amaxfor,
     4 ns, nznt, ntheta2, nzeta, jxbout_file,
     5    nsurf , ntht , nphi , jxbcode)

      use kind_spec
      use Vpname1, only: dmu0
      use safe_open_mod

      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer  ns, nznt , ntheta2, nzeta
      integer nsurf , ntht , nphi , jxbcode
      real(kind=rprec), dimension(nsurf,*) :: 
     1 jsupu, jsupv, jsups, 
     2 bsupu1, bsupv1, jcrossb, pprime, r12, 
     3 bdotj, bsubua, bsubva, bsubs
      real(kind=rprec), dimension(*) :: 
     1 hs, avforce, aminfor, amaxfor
      integer, dimension(nsurf,*) :: lka
      character*(*) jxbout_file
C-----------------------------------------------
C   L o c a l   P a r a m e t e r s
C-----------------------------------------------
      real(kind=rprec), parameter :: p5 = 0.5d0, two = 2.0d0, c1p5=1.5d0
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer lk, lz, lt, k, m, js, j, n, injxbout
      integer :: njxbout 
      character*30 :: dummytxt, filename
      real(kind=rprec) dum1, dum2 
      real(kind=rprec), dimension(:,:), allocatable ::
     1 bsubuv, bsubvu
      logical lxt,opnd
C-----------------------------------------------
      call get_lun(njxbout)
      call safe_open(njxbout, injxbout, trim(jxbout_file), 'old',
     1     'formatted')
      if (injxbout .ne. 0) then
         write(6,*)' Error opening JXBOUT file in read_jxbout'
         jxbcode=-1
         return
      endif   
      allocate(bsubuv(ns,nznt),bsubvu(ns,nznt))

       read (njxbout,fmt='(a10)')dummytxt
       read (njxbout,fmt='(a10)')dummytxt
       read (njxbout,fmt='(a10)')dummytxt
       read (njxbout,fmt='(a10)')dummytxt



!
!     NOTE: bsubua, bsubva are the ALIASED (truncated Fourier spectrum)
!           versions of bsubu, bsubv. bsubuv, bsubvu are used to compute
!           radial current (should be zero) 

      do js = 1, nsurf
            read (njxbout, 200) hs(js), avforce(js),
     1         dum1, dum2, amaxfor(js), aminfor(js)
            read (njxbout,fmt='(a10)')dummytxt
            read (njxbout,fmt='(a10)')dummytxt
            read (njxbout,fmt='(a10)')dummytxt

*            write (njxbout, 90)
            lk=0
            do lt = 1, ntht
               do lz = 1, nphi
                  lk = lk + 1
                  read (njxbout, 110) lka(js,lk), jsupu(js,lk),
     1              jsupv(js,lk), dum1, bsupu1(js,lk),  
     2              bsupv1(js,lk),jcrossb(js,lk), pprime(js,lk),
     3              dum2, bdotj(js,lk), bsubua(js,lk),
     4              bsubva(js,lk), bsubs(js,lk)
                  jsups(js,lk)=dmu0*dum1
                  r12(js,lk)=2._rprec*dum2/  !  nomalized residual
     1             (abs(jcrossb(js,lk))+abs( pprime(js,lk)))
               enddo
            enddo
      enddo
      close(unit=njxbout)
      call free_lun(njxbout)
  200 format(/16x,1pe12.3,21x,1p
     1   e12.3,13x,1pe12.3,19x,1pe12.3,/,
     2   32x,1pe12.3,
     3   32x,1pe12.3)
c  110 format(i5,1p12e11.3)
  110 format(i5,12(x,en10.3e2))
      deallocate(bsubuv,bsubvu)
      jxbcode=0
      end subroutine read_old_jxbout

      subroutine resetcolor
       character  endchr*1,ename*50,evalue*50
       data endchr/';'/
       logical symbol
       integer ret, overwrite
       call pgscir(0,15)
       ename = 'PGPLOT_FOREGROUND'
       call getenv(ename,evalue)
       symbol = (trim(evalue) .ne. 'black').or.
     & (trim(evalue) .ne. 'BLACK')
       if(symbol) then
#ifndef IRIX64
         ret=putenv(trim(ename),'BLACK')
         if(ret.lt.0)write(6,*) 'ERROR setting ',trim(ename)
         ret=putenv(trim(ename),'WHITE')
         if(ret.lt.0)write(6,*) 'ERROR setting ',trim(ename)
#else
         call pxfsetenv(trim(ename),0,'BLACK',0,overwrite,ret)
         if(ret.ne.0)write(6,*) 'ERROR setting ',trim(ename)
         call pxfsetenv(trim(ename),0,'WHITE',0,overwrite,ret)
         if(ret.ne.0)write(6,*) 'ERROR setting ',trim(ename)
#endif
       endif
       call pgscr( 1   , 0.00, 0.00, 0.00)  !  black & white
       call pgscr( 0   , 1.00, 1.00, 1.00)  !  interchanged
       call pgscr( 2   , 1.00, 0.00, 0.00)
       call pgscr( 3   , 0.00, 1.00, 0.00)
       call pgscr( 4   , 0.00, 0.00, 1.00)
       call pgscr( 5   , 0.00, 1.00, 1.00)
       call pgscr( 6   , 1.00, 0.00, 1.00)
       call pgscr( 7   , 1.00, 1.00, 0.00)
       call pgscr( 8   , 1.00, 0.50, 0.00)
       call pgscr( 9   , 0.50, 1.00, 0.00)
       call pgscr(10   , 0.00, 1.00, 0.50)
       call pgscr(11   , 0.00, 0.50, 1.00)
       call pgscr(12   , 0.50, 0.00, 1.00)
       call pgscr(13   , 1.00, 0.00, 0.50)
       call pgscr(14   , 0.33, 0.33, 0.33)
       call pgscr(15   , 0.66, 0.66, 0.66)

      end subroutine resetcolor

      subroutine RZtrans(visble,x,y,z)
C-----------------------------------------------
C   WARNING do NOT use       call pgsave in this routine !
C-----------------------------------------------
      use kind_spec
      use read_wout_mod, only: ns,mnmax,xm,xn,rmnc,rmns,zmns,zmnc
      use Toexternal
      implicit none
      integer i, jc
      real(kind=rprec)   :: arg
      real x, y, z, rc, zc, rs, zs, xwrld, ywrld
      INTEGER VISBLE, ins, incntr
      character*20 flabel
      data incntr/0/
      do jc=1,ncont
        if(contrs(jc).eq.z)incntr=jc
      enddo
      call pgsci(1+modulo(incntr,5))
      if(kbold(incntr).eq.1) then
          call pgslw(3)
      else
          call pgslw(1)
      endif
      ins= int(x)
      xwrld = 0.0
      ywrld = 0.0
      do i = 1, mnmax
      arg = 2.0_rprec*3.141592654_rprec*((y-1.0)/real(mxnt-1))*xm(i)
     &    -phit*xn(i)
        if (ins .ne. ns) then
          rc=real((rmnc(i,ins+1)-rmnc(i,ins))*(x-real(ins))+rmnc(i,ins))
          rs=real((rmns(i,ins+1)-rmns(i,ins))*(x-real(ins))+rmns(i,ins))
          zc=real((zmnc(i,ins+1)-zmnc(i,ins))*(x-real(ins))+zmnc(i,ins))
          zs=real((zmns(i,ins+1)-zmns(i,ins))*(x-real(ins))+zmns(i,ins))
        else
          rc=rmnc(i,ins)
          rs=rmns(i,ins)
          zc=zmnc(i,ins)
          zs=zmns(i,ins)
        endif  
        xwrld=xwrld+rc*cos(arg)+rs*sin(arg)
        ywrld=ywrld+zc*cos(arg)+zs*sin(arg)
      enddo
      if (visble.eq.0) then
        if(klabel(incntr).ne.0)then
        klabel(incntr)=0.
        write(flabel,fmt=labelformat)contrs(incntr)
        call pgsch(.8)
        call pgsci(1.)
        call pgslw(1)
        call pgscf(2)
        call pgpt1(xwrld,ywrld,-4)!   make a diamond at the labelled contour
        call pgtext(xwrld,ywrld,trim(flabel))
        endif
        call pgmove (xwrld, ywrld)
      else
        call pgdraw (xwrld, ywrld)
      endif
      end

      subroutine splaan(n, x, y, b, c, d)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      use kind_spec
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer n
      real(kind=rprec), dimension(n) :: x, y, b, c, d
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: nm1, ib, i
      real(kind=rprec) :: t
C-----------------------------------------------
c
c  the coefficients b(i), c(i), and d(i), i=1,2,...,n are computed
c  for a cubic interpolating spline for which s-prime(x1)=0.
c
c    s(x) = y(i) + b(i)*(x-x(i)) + c(i)*(x-x(i))**2 + d(i)*(x-x(i))**3
c
c    for  x(i) .le. x .le. x(i+1)
c
c  input..
c
c    n = the number of data points or knots (n.ge.2)
c    x = the abscissas of the knots in strictly increasing order
c    y = the ordinates of the knots
c
c  output..
c
c    b, c, d  = arrays of spline coefficients as defined above.
c
c  using  p  to denote differentiation,
c
c    y(i) = s(x(i))
c    b(i) = sp(x(i))
c    c(i) = spp(x(i))/2
c    d(i) = sppp(x(i))/6  (derivative from the right)
c
ccccccccccccccc
c  the accompanying function subprogram  seval  can be used
c  to evaluate the spline.
c
c
c
      nm1 = n - 1
      if (n < 2) return 
      if (n >= 3) then
c
c  set up tridiagonal system
c
c  b = diagonal, d = offdiagonal, c = right hand side.
c
         d(1) = x(2) - x(1)
         c(2) = (y(2)-y(1))/d(1)
         d(2:nm1) = x(3:nm1+1) - x(2:nm1)
         b(2:nm1) = 2.*(d(:nm1-1)+d(2:nm1))
         c(3:nm1+1) = (y(3:nm1+1)-y(2:nm1))/d(2:nm1)
         c(2:nm1) = c(3:nm1+1) - c(2:nm1)
c
c  end conditions.  third derivatives at  x(1)  and  x(n)
c  obtained from divided differences
c
         b(1) = 2.*d(1)
         b(n) = -d(n-1)
         c(1) = 0.
         c(n) = 0.
         if (n .ne. 3) then
            c(1) = (y(2)-y(1))/d(1)
            c(n) = c(n-1)/(x(n)-x(n-2)) - c(n-2)/(x(n-1)-x(n-3))
            c(n) = -c(n)*d(n-1)**2/(x(n)-x(n-3))
c
c  forward elimination
c
         endif
         do i = 2, n
            t = d(i-1)/b(i-1)
            b(i) = b(i) - t*d(i-1)
            c(i) = c(i) - t*c(i-1)
         enddo
c
c  back substitution
c
         c(n) = c(n)/b(n)
         do ib = 1, nm1
            i = n - ib
            c(i) = (c(i)-d(i)*c(i+1))/b(i)
         enddo
c
c  c(i) is now the sigma(i) of the text
c
c  compute polynomial coefficients
c
         b(n) = (y(n)-y(nm1))/d(nm1) + d(nm1)*(c(nm1)+2.*c(n))
         b(:nm1) = (y(2:nm1+1)-y(:nm1))/d(:nm1) - d(:nm1)*(c(2:nm1+1)+2.
     1      *c(:nm1))
         d(:nm1) = (c(2:nm1+1)-c(:nm1))/d(:nm1)
         c(:nm1) = 3.*c(:nm1)
         c(n) = 3.*c(n)
         d(n) = d(n-1)
         return 
c
      endif
      b(1) = (y(2)-y(1))/(x(2)-x(1))
      c(1) = 0.
      d(1) = 0.
      b(2) = b(1)
      c(2) = 0.
      d(2) = 0.

      end subroutine splaan
 
      subroutine spline(n, x, y, b, c, d)
c       the codes (spline & seval) are taken from:
c       forsythe,malcolm and moler,
c       "computer methods for mathematical computations",
c       prentice-hall, 1977.
c
c       the codes (spleen,splaan & speval) are adaptations
c       by r.m. wieland for special cases ... see comments
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      use kind_spec
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer n
      real(kind=rprec), dimension(n) :: x, y, b, c, d
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: nm1, ib, i
      real(kind=rprec) :: t
C-----------------------------------------------
c
c  the coefficients b(i), c(i), and d(i), i=1,2,...,n are computed
c  for a cubic interpolating spline
c
c    s(x) = y(i) + b(i)*(x-x(i)) + c(i)*(x-x(i))**2 + d(i)*(x-x(i))**3
c
c    for  x(i) .le. x .le. x(i+1)
c
c  input..
c
c    n = the number of data points or knots (n.ge.2)
c    x = the abscissas of the knots in strictly increasing order
c    y = the ordinates of the knots
c
c  output..
c
c    b, c, d  = arrays of spline coefficients as defined above.
c
c  using  p  to denote differentiation,
c
c    y(i) = s(x(i))
c    b(i) = sp(x(i))
c    c(i) = spp(x(i))/2
c    d(i) = sppp(x(i))/6  (derivative from the right)
c
ccccccccccccccc
c  the accompanying function subprogram  seval  can be used
c  to evaluate the spline.
c
c
c
      nm1 = n - 1
      if (n < 2) return 
      if (n >= 3) then
c
c  set up tridiagonal system
c
c  b = diagonal, d = offdiagonal, c = right hand side.
c
         d(1) = x(2) - x(1)
         c(2) = (y(2)-y(1))/d(1)
         d(2:nm1) = x(3:nm1+1) - x(2:nm1)
         b(2:nm1) = 2.*(d(:nm1-1)+d(2:nm1))
         c(3:nm1+1) = (y(3:nm1+1)-y(2:nm1))/d(2:nm1)
         c(2:nm1) = c(3:nm1+1) - c(2:nm1)
c
c  end conditions.  third derivatives at  x(1)  and  x(n)
c  obtained from divided differences
c
         b(1) = -d(1)
         b(n) = -d(n-1)
         c(1) = 0.
         c(n) = 0.
         if (n .ne. 3) then
            c(1) = c(3)/(x(4)-x(2)) - c(2)/(x(3)-x(1))
            c(n) = c(n-1)/(x(n)-x(n-2)) - c(n-2)/(x(n-1)-x(n-3))
            c(1) = c(1)*d(1)**2/(x(4)-x(1))
            c(n) = -c(n)*d(n-1)**2/(x(n)-x(n-3))
c
c  forward elimination
c
         endif
         do i = 2, n
            t = d(i-1)/b(i-1)
            b(i) = b(i) - t*d(i-1)
            c(i) = c(i) - t*c(i-1)
         enddo
c
c  back substitution
c
         c(n) = c(n)/b(n)
         do ib = 1, nm1
            i = n - ib
            c(i) = (c(i)-d(i)*c(i+1))/b(i)
         enddo
c
c  c(i) is now the sigma(i) of the text
c
c  compute polynomial coefficients
c
         b(n) = (y(n)-y(nm1))/d(nm1) + d(nm1)*(c(nm1)+2.*c(n))
         b(:nm1) = (y(2:nm1+1)-y(:nm1))/d(:nm1) - d(:nm1)*(c(2:nm1+1) + 
     1      2.d0*c(:nm1))
         d(:nm1) = (c(2:nm1+1)-c(:nm1))/d(:nm1)
         c(:nm1) = 3.d0*c(:nm1)
         c(n) = 3.d0*c(n)
         d(n) = d(n-1)
         return 
c
      endif
      b(1) = (y(2)-y(1))/(x(2)-x(1))
      c(1) = 0.
      d(1) = 0.
      b(2) = b(1)
      c(2) = 0.
      d(2) = 0.

      end subroutine spline

      subroutine splint(xa, ya, y2a, n, x, y, yp, ndim)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      use kind_spec
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer n, ndim
      real(kind=rprec), dimension(*) :: xa, ya, y2a, x, y, yp
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: i, klo, khi, k
      real(kind=rprec) :: c1o6, deriv, a, b, h, h2, a2, b2, y26lo, y26hi
C-----------------------------------------------
*
*       SPLINE INTERPOLATION ROUTINE (Numerical Recipes, pg. 89)
*       XA: ordered array of length N of ordinates at which function YA=F(XA)
*           is tabulated
*       YA: array of length N , = F(XA)
*       Y2A: array of second derivatives at XA points
*       computed from call to SPLINE
*       X : value at which Y = F(X) is to be computed from splines
*       YP = dY/dX at X
*       NDIM: dimension of X, Y, YP arrays
 
 
      c1o6 = 1.0/6.0
      deriv = yp(1)
      klo = 1
      khi = n
      do i = 1, ndim
 
         do while(khi - klo > 1)
            k = (khi + klo)/2
            if (xa(k) > x(i)) then
               khi = k
            else
               klo = k
            endif
         enddo
 
         h = xa(khi) - xa(klo)
         a = xa(khi) - x(i)
         b = x(i) - xa(klo)
         h2 = h*h
         a2 = a*a
         b2 = b*b
         y26lo = c1o6*y2a(klo)
         y26hi = c1o6*y2a(khi)
         y(i) = (a*(ya(klo)+(a2-h2)*y26lo)+b*(ya(khi)+(b2-h2)*y26hi))/h
         if (deriv .ne. 0.0) yp(i) = (ya(khi)-ya(klo)+y26hi*(3.0*b2-h2)-
     1      y26lo*(3.0*a2-h2))/h
         if (i<ndim .and. x(i+1)>x(i)) then
            khi = n
         else
            klo = 1
         endif
      enddo
      end subroutine splint

      subroutine str_strip(string, inblen)
C
C...       This routine compresses a character string, deleting all blanks
c...       the compressed string is returned in the pkg it came in [STRING]],
c...       together with a label [INBLEN] telling how long it is. (Dick
c
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer inblen
      character string*(*)
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: ilen, ind, j
C-----------------------------------------------
c
 
      ilen = len(string)
      inblen = 0
      if (ilen .eq. 0) return 
c
      ind = 0
      do j = 1, ilen
         if (string(j:j) .ne. ' ') then
            ind = ind + 1
            string(ind:ind) = string(j:j)
         endif
      enddo
      if (ind < ilen) string(ind+1:) = ' '
 
      inblen = ind
 
      end subroutine str_strip

      subroutine bndypts (ntheta,nplots,kz,rb,zb)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      use read_wout_mod, 
     .only: nfp, mnmax, xm, xn, rmnc, zmns, rmns, zmnc, rprec, ns
c      use read_wout_mod, only: nfp, rprec
      use vmec_input, only: rbc,rbs,zbc,zbs, lfreeb, ntor, mpol
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer ntheta, nplots, kz, mpol_mn, ntor_mn
      real(kind=rprec), dimension(*), intent(out) :: rb, zb
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      real(kind=rprec) :: pit, xxm, xxn, arg, u, v, r, z, pi
      real(kind=rprec) :: cosa, sina, r1, z1, r0, z0
      integer :: j, m, n
C-----------------------------------------------
      mpol_mn=nint(maxval(xm))
      ntor_mn=nint(maxval(xn))/nfp
      pi=atan(1.d0)*4.d0
      pit = 2.d0*pi/(ntheta - 1)
      v=pi*(nfp-1)*(kz-1)/nplots
        r1=0;z1=0;m=0;r0=0;z0=0
         do n=-ntor,ntor
          xxm=m;xxn=n
          arg=xxm*u-xxn*v
          cosa=cos(arg);sina=sin(arg)
          r1=r1+rbc(n,m)*cosa+rbs(n,m)*sina
          z1=z1+zbc(n,m)*cosa+zbs(n,m)*sina
         enddo


         do n=1,ntor_mn
          arg=xn(n)/nfp*v
          cosa=cos(arg);sina=sin(arg)
          r0=r0+rmnc(n,ns)*cosa+rmns(n,ns)*sina
          z0=z0+zmnc(n,ns)*cosa+zmns(n,ns)*sina
         enddo
       write(6,fmt='(a,i3.3,a,/4(x,1pe11.4))')
     .  ' phi = ',nint(360*v/2/pi),
     .  ' compare [R,Z]cntrs {mn,bc} ',r0,r1,z0,z1
       do j=1,ntheta
        u=pit*(j-1)
        r=0
        z=0
        do m=0,mpol  
         do n=-ntor,ntor
          xxm=m;xxn=n
          arg=xxm*u-xxn*v
          cosa=cos(arg);sina=sin(arg)
          r=r+rbc(n,m)*cosa+rbs(n,m)*sina
          z=z+zbc(n,m)*cosa+zbs(n,m)*sina
         enddo
        enddo
        rb(j)=r
        zb(j)=z
       enddo

      return
!      end  subroutine bndypts
      end 

      subroutine totz(ntheta, ns1, nplots, kz, r, z, 
     1   rmnc, zmns, rmns, zmnc)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      use read_wout_mod, 
     .only: nfp, mnmax, xm, xn, rprec, mpol, ntor
      use Vpname1, only: nrt
      use Vindat2, only: twopi
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer ntheta, ns1, nplots, kz
      real(kind=rprec), dimension(*), intent(out) :: r, z
      real(kind=rprec), dimension(*), intent(in) :: 
     1   rmnc, zmns, rmns, zmnc

C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: nrth, l, j, jes, mes, mn, kt, m, iarg
      real(kind=rprec) :: pit, piz, xm0, xn0, arg
C-----------------------------------------------
      pit = 1.d0/(ntheta - 1)
      piz = 1.d0/(nfp*nplots)
      nrth = ns1*ntheta
      if (nrth .gt. nrt) stop 'nrth > nrt in totz'

      r(:nrth) = 0.d0
      z(:nrth) = 0.d0
      do j = 1, ns1
         jes = ntheta*(j - 1)
         mes = mnmax*(j - 1)
         do mn = 1, mnmax
            xm0 = xm(mn)*pit
            xn0 = xn(mn)*piz
            do kt = 1, ntheta
               l = kt + jes
               m = mn + mes
               arg = xm0*(kt - 1) - xn0*(kz - 1)
               iarg = arg
               arg = twopi*(arg - iarg)
               r(l) = r(l) + rmnc(m)*cos(arg) + rmns(m)*sin(arg)
               z(l) = z(l) + zmns(m)*sin(arg) + zmnc(m)*cos(arg)
            enddo
         enddo
      enddo
      end subroutine totz

      subroutine totzu(ntheta, ns1, nplots, kz, r, z, 
     1   rmnc, zmns, rmns, zmnc)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      use read_wout_mod, only: rprec, nfp, mnmax, xm, xn
      use Vindat2, only: twopi
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer ntheta, ns1, nplots, kz
      real(kind=rprec), dimension(*), intent(out) :: r, z
      real(kind=rprec), dimension(*), intent(in) :: 
     1  rmnc, zmns, rmns, zmnc
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: nrth, l, j, jes, mes, mn, kt, m, iarg
      real(kind=rprec) :: pit, piz, xm0, xn0, arg
C-----------------------------------------------
      pit = 1.d0/(ntheta - 1)
      piz = 1.d0/(nfp*nplots)
      nrth = ns1*ntheta
      r(:nrth) = 0.
      z(:nrth) = 0.
      do j = 1, ns1
         jes = ntheta*(j - 1)
         mes = mnmax*(j - 1)
         do mn = 1, mnmax
            xm0 = xm(mn)*pit
            xn0 = xn(mn)*piz
            do kt = 1, ntheta
               l = kt + jes
               m = mn + mes
               arg = xm0*(kt - 1) - xn0*(kz - 1)
               iarg = arg
               arg = twopi*(arg - iarg)
               r(l) =r(l) + xm(mn)*(rmns(m)*cos(arg) - rmnc(m)*sin(arg))
               z(l) =z(l) - xm(mn)*(zmnc(m)*sin(arg) - zmns(m)*cos(arg))
            enddo
         enddo
      enddo

      end subroutine totzu
      subroutine totb(ntheta, ns1, nplots, kz, r, z, 
     1   rmnc, zmns, rmns, zmnc)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      use read_wout_mod, 
     .only: nfp, mnmax, xm, xn, rprec, mpol, ntor
      use Vpname1, only: nrt
      use Vindat2, only: twopi
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer ntheta, ns1, nplots, kz
      real(kind=rprec), dimension(*), intent(out) :: r, z
      real(kind=rprec), dimension(*), intent(in) :: 
     1   rmnc, zmns, rmns, zmnc

C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: nrth, l, j, jes, mes, mn, kt, m, iarg
      real(kind=rprec) :: pit, piz, xm0, xn0, arg
C-----------------------------------------------
      pit = 1.d0/(ntheta - 1)
      piz = 1.d0/(nfp*nplots)
      nrth = 1*ntheta
      if (nrth .gt. nrt) stop 'nrth > nrt in totz'

      r(:nrth) = 0.d0
      z(:nrth) = 0.d0
      j = ns1
         jes = ntheta*(j - 1)
         mes = mnmax*(j - 1)
         do mn = 1, mnmax
            xm0 = xm(mn)*pit
            xn0 = xn(mn)*piz
            do kt = 1, ntheta
               l = kt + jes
               m = mn + mes
               arg = xm0*(kt - 1) - xn0*(kz - 1)
               iarg = arg
               arg = twopi*(arg - iarg)
               r(kt) = r(kt) + rmnc(m)*cos(arg) + rmns(m)*sin(arg)
               z(kt) = z(kt) + zmns(m)*sin(arg) + zmnc(m)*cos(arg)
            enddo
         enddo
      end subroutine totb

      subroutine wie_parse(string, n_tokens, tokens, len_tokens)
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer n_tokens
      character string*(*)
      integer, dimension(*) :: len_tokens
      character, dimension(*) :: tokens*(*)
C-----------------------------------------------
C   L o c a l   P a r a m e t e r s
C-----------------------------------------------
      integer, parameter :: nwsp = 3
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: n_tokens_max, i, j, isl, iii, ipos, i_run, ix, sl
      logical :: whitespace
      character :: set*3
      character, dimension(nwsp) :: byteset
C-----------------------------------------------
C   E x t e r n a l   F u n c t i o n s
C-----------------------------------------------
      integer , EXTERNAL :: gen_find_first_in_set
      logical , EXTERNAL :: iswhitespace
C-----------------------------------------------
 
      equivalence (set, byteset)
 
      byteset(1) = char(32)                      !space
      byteset(2) = char(9)                       !tab
      byteset(3) = char(0)                       !null
 
      n_tokens_max = n_tokens
      do i = 1, n_tokens
         tokens(i) = ' '
         len_tokens(i) = 0
      enddo
 
      isl = len_trim(string)
      if (isl .eq. 0) then
         n_tokens = 0
         iii = len(tokens(1))
         tokens(1) = string(1:iii)
         len_tokens(1) = 0
         return 
      endif
 
      i = 1
      ipos = 1
      do while(i .eq. 1)      !UNTIL SOMETHING OTHER THAN sp OR tab OR nul
         i = gen_find_first_in_set(string(ipos:),set)
         ipos = ipos + 1
      enddo
      i_run = ipos - 1
 
      n_tokens = 0
      do while(i_run<=isl .and. n_tokens<n_tokens_max)
         i = gen_find_first_in_set(string(i_run:),set) + i_run - 1
         if (.not.iswhitespace(string(i_run:i_run),byteset,nwsp)) then
            n_tokens = n_tokens + 1
c ... added by alan {
            if (i - 1 >= i_run) then
               tokens(n_tokens) = string(i_run:i-1)
               i_run = i + 1
            else
               tokens(n_tokens) = string(i_run:)
               i_run = isl + 1
            endif
            len_tokens(n_tokens) = len_trim(tokens(n_tokens))
         else
            i_run = i + 1
         endif
c ... }
      enddo
 
      end subroutine wie_parse

      subroutine wrfcn(input_id)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      use read_wout_mod, itor_w=>itor
      use Vpname1
      use Vpname2
      use Vindat2
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      character input_id*(*)
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: iloop, nmax1, mn, n1, j, jp, i
      real(kind=rprec) :: es, tb1, tm1, tv1, tp1, ti1, ub1
      character, dimension(3) :: ichar1*5, ichar2*5
C-----------------------------------------------
 
      data ichar1/'RmnC(', 'ZmnS(', 'LmnS('/
      data ichar2/'RmnS(', 'ZmnC(', 'LmnC('/
      twopi = 8.*atan(1.0)
*
*                 PRINT SYMMETRIC TERMS -- RmnC and ZmnS
*                 INTERPOLATE LAMBDA ONTO FULL MESH FIRST
*

      do mn = 1, mnmax
         if (ixm(mn) .ne. 0) then
            lmns(mn,1) = 0.
         else
            lmns(mn,1) = 1.5*lmns(mn,2) - 0.5*lmns(mn,3)
         endif
      enddo
               
      do j = 2, ns-1
         do mn = 1,mnmax
            lmns(mn,j) = 0.5*(lmns(mn,j) + lmns(mn,j+1))
         enddo         
      enddo   
      
      do mn = 1,mnmax
         lmns(mn,ns) = 2.0*lmns(mn,ns-1) - lmns(mn,ns-2)
      enddo      

      write (39, 200)
      do iloop = 1, 3
         nmax1 = 5
         do mn = 1, mnmax, 6
            if (mn > mnmax - 6) nmax1 = mnmax - mn
            write (39, 210) (ichar1(iloop),ixm(mn+n1),ixn(mn+n1),n1=0,
     1         nmax1)
            do j = 1, ns
               es = (j - 1)*hs
               select case (iloop) 
               case default
                  write (39, 220) es, (rmnc(mn+n1,j),n1=0,nmax1)
                  cycle 
               case (2) 
                  write (39, 220) es, (zmns(mn+n1,j),n1=0,nmax1)
                  cycle 
               case (3) 
                  write (39, 220) es, (lmns(mn+n1,j),n1=0,nmax1)
               end select
            enddo
         enddo
      enddo
 
*
*                 PRINT ASYMMETRIC TERMS -- RmnS and ZmnC
*
      if (iasym .eq. 1) then
         write (39, 200)
         do iloop = 1, 3
            nmax1 = 5
            do mn = 1, mnmax, 6
               if (mn > mnmax - 6) nmax1 = mnmax - mn
               write (39, 210) (ichar2(iloop),ixm(mn+n1),ixn(mn+n1),
     1            n1=0,nmax1)
               do j = 1, ns
                  es = (j - 1)*hs
                  select case (iloop) 
                  case default
                     write (39, 220) es, (rmns(mn+n1,j),n1=0,nmax1)
                     cycle 
                  case (2) 
                     write (39, 220) es, (zmnc(mn+n1,j),n1=0,nmax1)
                     cycle 
                  case (3) 
                     write (39, 220) es, (lmnc(mn+n1,j),n1=0,nmax1)
                  end select
               enddo
            enddo
         enddo
      endif
*
*     DETERMINE RADIAL BETA PROFILE (SURFACE AVERAGED)
*
      phi(1) = 0.
      sqrt_phimod = 0.
      phimod = 0.
      do j = 1, ns
         sqrt_phimod(mn0+mnmax*(j-1)) = sqrt(abs(phi(j)))
         phimod(mn0+mnmax*(j-1)) = phi(j)
      enddo
*     d(BVCO)/ds
      dbzcods(2:ns-1) = (bvco(3:ns)-bvco(2:ns-1))/hs
      dbzcods(ns) = 2*dbzcods(ns-1) - dbzcods(ns-2)
      dbzcods(1) = 2*dbzcods(2) - dbzcods(3)
      beta_vol(1) = 1.5*beta_vol(2) - 0.5*beta_vol(3)
      tb1 = 1.5*beta_vol(ns) - 0.5*beta_vol(ns-1)
      bvco(1) = 1.5*bvco(2) - 0.5*bvco(3)
      buco(1) = 0.
      ub(2:ns) = vp(2:ns)/phip(2:ns)
      mass(2:ns) = mass(2:ns)/abs(phip(2:ns))**gamma
      mass(1) = 1.5*mass(2) - 0.5*mass(3)
      pres(1) = 1.5*pres(2) - 0.5*pres(3)
      vp(1)   = 1.5*vp(2) - 0.5*vp(3)
      tm1 = 1.5*mass(ns) - .5*mass(ns-1)
      tv1 = 1.5*vp(ns) - .5*vp(ns-1)
      tp1 = 1.5*pres(ns) - .5*pres(ns-1)
      ti1 = 1.5*iotas(ns) - .5*iotas(ns-1)
      ub1 = 1.5*ub(ns) - .5*ub(ns-1)
      ub(1) = ub(2)*twopi
CDIR$   IVDEP
      do j = 2, ns - 1
         jp = j + 1
         buco(j) = .5*(buco(jp)+buco(j))
         ub(j) = .5*(ub(jp)+ub(j))*twopi
         vp(j) = .5*(vp(jp)+vp(j))
         mass(j) = .5*(mass(jp)+mass(j))
         pres(j) = 0.5*(pres(jp) + pres(j))
         beta_vol(j) = .5*(beta_vol(jp)+beta_vol(j))
         bvco(j) = .5*(bvco(jp)+bvco(j))
      enddo
      ub(ns) = twopi*ub1
      vp(ns) = tv1
      mass(ns) = tm1
      pres(ns) = tp1
      beta_vol(ns) = tb1
      buco(ns) = 2.*buco(ns) - buco(ns-1)
      bvco(ns) = 2.*bvco(ns) - bvco(ns-1)
      write (39, 230)
*     Normalized FF-Prime : ffp(j)
      do j = 1, ns
         es = (j - 1)*hs
         itor = -twopi*buco(j)
         itors(j) = itor/dmu0
         ipol = twopi*(bvco(j)-bvco(ns))
         ipols(j) = ipol/dmu0
         ffp(j) = bvco(j)*dbzcods(j)/phip(j)/iotaf(j)/
     1      bvco(ns)**2
         write (39, 220) es, bvco(j), buco(j), itor, ipol, ffp(j)
      enddo
      write (39, 240)
      do i = 1, ns
         es = (i - 1)*hs
         write (39, 220) es, twopi**2*vp(i), ub(i), mass(i), pres(i), 
     1      iotaf(i), beta_vol(i)
      enddo
 
      return 
 
*  Do the above before the call to PLOTTER; do the below after
 
      entry wrfcn2 (input_id)
 
      write (39, 260)
      do i = 1, ns
         es = (i - 1)*hs
         write (39, 220) es, jcurv(i), jdotb(i)
      enddo
 
      write (39, 250) beta_vol(1)
 
  200 format(//,40x,'FOURIER COEFFICIENTS X(m,n)',/)
  210 format(//,9x,' S ',4x,6(4x,a5,i1,',',i3,')'),/)
  220 format(1p8e15.3)
  230 format(//,25x,'COVARIANT COMPONENTS OF B',
     1   ' AND INTEGRATED CURRENTS',2/,9x,' S ',10x,'<BZETA>',8x,
     2   '<BTHETA>',8x,'ITOR',11x,'IPOL',8x,'FF''',/)
  240 format(//,9x,' S ',11x,'VP',12x,'dV/dPHI',10x,'MASS',13x,'P',10x,
     1   'IOTA',12x,'BETA',/)
  250 format(//,'  BETA ON AXIS (SUM OVER MODES) = ',1pe10.3)
  260 format(//,9x,' S ',11x,'<JTOR>',2x,'<JdotB>/<bdotgradv>',/,9x,3x
     1   ,11x,'[A/M2]',10x,'[A/M]',/)
 
      end subroutine wrfcn

      subroutine wrstab(ns, psi_in, pres, iota, runid, mnmax, rmnc, 
     1   zmns, rbt, itor, ffp, jdotb, betatot, betapol, betator, 
     2   betaxis)
C-----------------------------------------------
C   M o d u l e s 
C-----------------------------------------------
      use Vtraneq
      implicit none
C-----------------------------------------------
C   D u m m y   A r g u m e n t s
C-----------------------------------------------
      integer ns, mnmax
      real(kind=rprec) :: itor
      real(kind=rprec) :: rbt, betatot, betapol, betator, betaxis
      character runid*(*)
      real(kind=rprec), dimension(*) :: psi_in, iota, ffp 
      real(kind=rprec), dimension(*) :: rmnc, zmns, pres, jdotb
C-----------------------------------------------
C   L o c a l   P a r a m e t e r s
C-----------------------------------------------
      real(kind=rprec), parameter :: dmu0 = 1.256637d-06, zero = 0.d0
C-----------------------------------------------
C   L o c a l   V a r i a b l e s
C-----------------------------------------------
      integer :: i, ishot, itime, mn, mjbal
      real(kind=rprec), dimension(101) :: sp1, sp2, sp3
      real(kind=rprec) :: err
C-----------------------------------------------
c======               START OF TRANEQ.BLK            =================
C
C   +++ See file EQOUT for definition of variables +++
C   +++                                            +++
C   +++ Note: There are two common blocks, EQCOM,  +++
C   +++  and EQFIL. The former passes numerical    +++
C   +++  data, while the latter passes character   +++
C   +++  data. The common block EQCOM has been     +++
C   +++  broken into parts for documentation       +++
C   +++  purposes. These blocks serve all of the   +++
C   +++  output codes which are interfaced.        +++
C   +++                                            +++
C   +++  Steve Sabbagh 9/11/90 Ver 1.0             +++
C   +++                1/02/91 Ver 1.1             +++
C   +++               12/30/93 Ver 1.2             +++
C   +++               08/30/94 Ver 1.3             +++
C   +++                 (80 character filenames)   +++
C   ++++++++++++++++++++++++++++++++++++++++++++++++++
C
c   +++ EQCOM common block +++
c   +++ 0) EQOUT input variables (number)
c
c   +++ 1) SHARED scalar variables +++
c
c   +++ 2) SHARED vector variables +++
c   +++      Note: r0b is a scalar +++
c
c   +++ 3) EQGRUM scalars +++
c
c   +++ 4) EQGRUM specific array variables +++
c
c   +++ 5) JSOLVER scalars +++
c
c   +++ 6) JSOLVER specific vector variables +++
c
c   +++ EQFIL common block +++
c
c   +++ J Profile & Beta Values
c
      read (runid(1:5), '(i5)', err=5) ishot
      shotnm = ishot
      goto 7
    5 continue
      shotnm = zero
      time = zero
      goto 20
    7 continue
      i = index(runid(9:),'t')
      if (i .eq. 0) time = zero
      if (i > 0) read (runid(9+i:9+i+2), '(i3)', err=10) itime
      time = itime/100
      goto 20
   10 continue
      time = zero
   20 continue
      intord = 0
      thdfil = 'wout.'//runid
      flnmo1 = runid(1:len_trim(runid))//'.eqi'
      pfilt1 = zero
      pfilt2 = zero
      pfilt3 = zero
      nequil = 1
      mjbal = ns + 2
      njav = mjbal
      mombnd = mnmax - 1
      mom = 0
      r0b = rmnc(1+mnmax*(ns-1))
      rmb(:mnmax-1) = rmnc(2+mnmax*(ns-1):mnmax*ns)
      ymb(:mnmax-1) = zmns(2+mnmax*(ns-1):mnmax*ns)
      rtor = r0b
      rtor = rtor + sum(rmb(2:mnmax:2))
      btor = abs(rbt)/rtor
      eqcamp = itor/dmu0
      ieqax = 2
      ieqedg = ns + 1
      psi(2:ns+1) = psi_in(:ns)
      q(2:ns+1) = 1./iota(:ns)
      press(2:ns+1) = pres(:ns)/dmu0
      jdotbc(2:ns+1) = jdotb(:ns)
      ggp(2:ns+1) = ffp(:ns)
      psi(1) = psi(3)
      q(1) = q(3)
      press(1) = press(3)
      jdotbc(1) = jdotbc(3)
      ggp(1) = ggp(3)
*
*       calculate derivatives using interpolating cubic splines
*       use Natural BC for q and pres
*
      call spline (ns, psi(ieqax), q(ieqax), sp1, sp2, sp3)
      dqdpsi(ieqax:ns-1+ieqax) = sp1(:ns)
      dqdpsi(ieqax-1) = dqdpsi(ieqax+1)
 
      call spline (ns, psi(ieqax), press(ieqax), sp1, sp2, sp3)
      dpdpsi(ieqax:ns-1+ieqax) = sp1(:ns)
      dpdpsi(ieqax-1) = dpdpsi(ieqax+1)
 
      batot = betatot
      bapol = betapol
      bator = betator
      baxis = betaxis
 
      call putstb
 
      end subroutine wrstab

      subroutine xywtoxyan(xw,yw,xso,yso)
       use pgplotinc, only: pgxscl,pgxorg,pgxsz,pgyscl,pgyorg,pgysz
c       include '/usr/local/pgplot/pgplot.inc' ! might not be there
       integer idx idc
       real xw,yw,xso,yso,xa,ya
         xa(xw,idc)=(xw*pgxscl(idc)+pgxorg(idc))
         ya(yw,idc)=(yw*pgyscl(idc)+pgyorg(idc))
         call pgqid(idx)
         xso=xa(xw,idx)/pgxsz(idx)
         yso=ya(yw,idx)/pgysz(idx)
         return
      end subroutine xywtoxyan

EOF
cat > pgxtalpkg.f << "EOF"

      SUBROUTINE DSQINF(XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                  YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC)
C     ---------------------------------------------------------
C
      DATA BIG,SMALL /1.0E+20,1.0E-20/
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      Obtain some viewport and window information about the current 
C    PGPLOT device, without directly accessing the common blocks in
C    pgplot.inc.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    XPERIN   R*4    O       -      Plot X scale in dots/inch.
C    YPERIN   R*4    O       -      Plot Y scale in dots/inch.
C    XOFF     R*4    O       -      Absolute coord of blc of viewport.
C    YOFF     R*4    O       -      Absolute coord of blc of viewport.
C    XLEN     R*4    O       -      Width of viewport in absolute coord.
C    YLEN     R*4    O       -      Height of viewport in absolute coord.
C    XORG     R*4    O       -      Absolute coord of world X=0.
C    YORG     R*4    O       -      Absolute coord of world Y=0.
C    XSCALE   R*4    O       -      Absolute units per world coord in X.
C    YSCALE   R*4    O       -      Absolute units per world coord in Y.
C    XBLC     R*4    O       -      World X coord at blc of window.
C    XTRC     R*4    O       -      World X coord at trc of window.
C    YBLC     R*4    O       -      World Y coord at blc of window.
C    YTRC     R*4    O       -      World Y coord at trc of window.
C
C Globals
C     None.
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     PGQVP      Inquires about viewport dimensions.
C     PGQWIN     Inquires about world coords of window.
C
C History
C   D. S. Sivia       1 Aug 1996  Initial release.
C-----------------------------------------------------------------------
C
      CALL PGQWIN(XBLC,XTRC,YBLC,YTRC)
      CALL PGQVP(1,XI1,XI2,YI1,YI2)
      CALL PGQVP(3,XOFF,XP2,YOFF,YP2)
      XLEN=ABS(XP2-XOFF)
      YLEN=ABS(YP2-YOFF)
      XPERIN=XLEN/(ABS(XI2-XI1)+SMALL)
      YPERIN=YLEN/(ABS(YI2-YI1)+SMALL)
      XWDIF=XTRC-XBLC
      YWDIF=YTRC-YBLC
      AXWDIF=BIG
      AYWDIF=BIG
      IF (ABS(XWDIF).GT.SMALL) AXWDIF=1.0/XWDIF
      IF (ABS(YWDIF).GT.SMALL) AYWDIF=1.0/YWDIF
      XSCALE=XLEN*AXWDIF
      YSCALE=YLEN*AYWDIF
      XORG=(XOFF*XTRC-XP2*XBLC)*AXWDIF
      YORG=(YOFF*YTRC-YP2*YBLC)*AYWDIF
      END SUBROUTINE DSQINF

      SUBROUTINE PGCELL(A,IDIM,JDIM,I1,I2,J1,J2,FG,BG,TR,NCOLS,R,G,B)
C     ---------------------------------------------------------------
C
      use grpckg1inc
      REAL         A(IDIM,JDIM),TR(6)
      REAL         R(0:NCOLS-1),G(0:NCOLS-1),B(0:NCOLS-1)
      INTEGER      IDIM,JDIM,I1,I2,J1,J2,NCOLS
C
      INTEGER      IR(0:255),IG(0:255),IB(0:255)
      LOGICAL      LPS,LCOLOR,PGNOTO
      CHARACTER*16 TYPE,CHR
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      This subroutine is designed to do the job of CELL_ARRAY in GKS;
C   that is, it shades elements of a rectangular array with the 
C   appropriate colours passed down in the RGB colour-table. Essentially,
C   it is a colour version of PGGRAY. 
C      The colour-index used for particular array pixel is given by:
C         Colour Index = NINT{[A(i,j)-BG/(FG-BG)]*FLOAT(NCOLS-1)} ,
C   with truncation at 0 and NCOLS-1, as necessary.
C      The transform matrix TR is used to calculate the (bottom left) 
C   world coordinates of the cell which represents each array element:
C         X = TR(1) + TR(2)*I + TR(3)*J
C         Y = TR(4) + TR(5)*I + TR(6)*J  .
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    A        R*4    I   IDIMxJDIM  The array to be plotted.
C    IDIM     I*4    I       -      The first dimension of array A.
C    JDIM     I*4    I       -      The second dimension of array A.
C    I1,I2    I*4    I       -      The inclusive range of the first
C                                   index (I) to be plotted.
C    J1,J2    I*4    I       -      The inclusive range of the second
C                                   index (J) to be plotted.
C    FG       R*4    I       -      The array value which is to appear
C                                   with shade 1 ("foreground").
C    BG       R*4    I       -      The array value which is to appear
C                                   with shade 0 ("background").
C    TR       R*4    I       6      Transformation matrix between array
C                                   grid and world coordinates.
C    NCOLS    I*4    I       -      Number of colours in colour-table.
C    R        R*4    I      NCOLS   Red intensity for colour-table.
C    G        R*4    I      NCOLS   Green intensity for colour-table.
C    B        R*4    I      NCOLS   Blue intensity for colour-table.
C
C Globals
C    GRPCKG1.INC
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     PGNOTO     Logical function to test if a PGPLOT device is open.
C     GRBPIC     Sends a "begin picture" command to the device driver.
C     PGQCOL     Inquires about the colour capability.
C     PGQCI      Inquires about the current colour index.
C     PGQINF     Inquires about general PGPLOT information.
C     PGBBUF     Recommended initial call (to start a PGPLOT buffer).
C     PGEBUF     Recommended final call (to end a PGPLOT buffer).
C     PGCLPX     Pixel-device support subroutine for PGCELL.
C     PGCLPS     PostScript support subroutine for PGCELL.
C     GREXEC     Dispatches command to appropriate device driver.
C     DSQINF     Inquires about viewport and window dimensions.
C
C History
C   D. S. Sivia       3 Jul 1992  Initial release.
C   D. S. Sivia       6 Feb 1995  Now uses GRGRAY approach instead of
C                                 PGPOLY, and linearly interpolates.
C   D. S. Sivia       6 Mar 1995  Slight changes for Postscript output.
C   D. S. Sivia       1 Aug 1996  Replaced pgplot.inc with DSQINF!
C   D. S. Sivia      21 Oct 1997  Made slightly friendlier for NT.
C   D. S. Sivia      16 Jul 1999  Added a couple of PGPLOT calls to 
C                                 force proper initialisation.
C-----------------------------------------------------------------------
C
C A PGPLOT initialisation precaution.
C
      IF (PGNOTO('PGCELL')) RETURN
      IF (.NOT.GRPLTD(GRCIDE)) CALL GRBPIC
C
C Find out device-type. If not Postscript, then (i) return if less than
C 16 shades available; (ii) save initial colour index (and hope it's 
C less than ICLOW).
C
      NC=256
      LPS=.TRUE.
      CALL PGQINF('TYPE',TYPE,LCHR)
      IF (TYPE.EQ.'PS' .OR. TYPE.EQ.'VPS') THEN
        LCOLOR=.FALSE.
      ELSEIF (TYPE.EQ.'CPS' .OR. TYPE.EQ.'VCPS') THEN
        LCOLOR=.TRUE.
      ELSE
        LPS=.FALSE.
        CALL PGQCOL(IC1,IC2)
        NC=IC2-IC1+1
        IF (NC.LT.16) THEN
          WRITE(*,*)' *** Not enough colours available on this device!'
          RETURN
        ELSE
          ICLOW=4
          IF (NC.GE.96) ICLOW=16
          IC1=IC1+ICLOW
          NC=NC-ICLOW
        ENDIF
        CALL PGQCI(ICSAVE)
        IF (ICSAVE.GE.IC1) ICSAVE=IC1+1
      ENDIF
      CALL PGBBUF
C
C Activate the colour table. If NCOLS is less than the number of colours
C available, simply assign NCOLS; otherwise, use a linear interpolation.
C
      IF (NCOLS.LE.NC) THEN
        NC=NCOLS
        DO 10 I=0,NCOLS-1
          CALL PGSCR(IC1+I,R(I),G(I),B(I))
          IR(I)=NINT(R(I)*255.0)
          IG(I)=NINT(G(I)*255.0)
          IB(I)=NINT(B(I)*255.0)
  10    CONTINUE
      ELSE
        COL=0.0
        DCOL=0.999*FLOAT(NCOLS-1)/FLOAT(NC-1)
        DO 20 I=0,NC-1
          ICOL=INT(COL)
          DICOL=COL-FLOAT(ICOL)
          RL=R(ICOL)+DICOL*(R(ICOL+1)-R(ICOL))
          GL=G(ICOL)+DICOL*(G(ICOL+1)-G(ICOL))
          BL=B(ICOL)+DICOL*(B(ICOL+1)-B(ICOL))
          CALL PGSCR(IC1+I,RL,GL,BL)
          IR(I)=NINT(RL*255.0)
          IG(I)=NINT(GL*255.0)
          IB(I)=NINT(BL*255.0)
          COL=COL+DCOL
  20    CONTINUE
      ENDIF
      ASCALE=FLOAT(NC-1)/(FG-BG)
C
C Check to see whether a pixel device or Postscript is being used, and 
C call the appropriate PGCELL support subrotuine.
C
      IF (LPS) THEN
        CALL PGCLPS(A,IDIM,JDIM,I1,I2,J1,J2,BG,TR,ASCALE,IR,IG,IB,NC,
     *              LCOLOR)
      ELSE
        NBUF=0
        LCHR=LEN(CHR)
        CALL GREXEC(GRGTYP,4,RBUF,NBUF,CHR,LCHR)
        IF (CHR(7:7).EQ.'P') THEN
          CALL PGCLPX(A,IDIM,JDIM,I1,I2,J1,J2,BG,TR,ASCALE,IC1,NC)
        ELSE
          WRITE(*,*)' Sorry, PGCELL does not support this device!'
        ENDIF
      ENDIF
C
C Reset the initial colour index.
C
      IF (.NOT. LPS) CALL PGSCI(ICSAVE)
      CALL PGEBUF
      END SUBROUTINE PGCELL

      SUBROUTINE PGCLPX(A,IDIM,JDIM,I1,I2,J1,J2,BG,TR,ASCALE,IC1,NC)
C     --------------------------------------------------------------
C
C Light-up the device pixels, with colours determined by a linearly
C interpolating array A.
C
      use grpckg1inc
      REAL      A(IDIM,*),TR(*),BUFFER(2050)
      CHARACTER CHR*16
C
      CALL DSQINF(XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *            YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC)
      IX1=NINT(XOFF)
      IX2=NINT(XOFF+XLEN)
      JY1=NINT(YOFF)
      JY2=NINT(YOFF+YLEN)
      DET=TR(2)*TR(6)-TR(3)*TR(5)
      TR11=+TR(6)/DET
      TR12=-TR(3)/DET
      TR21=-TR(5)/DET
      TR22=+TR(2)/DET
      DX=1.0/XSCALE
      DY=1.0/YSCALE
      X1=(XOFF-XORG)*DX-TR(1)
      Y1=(YOFF-YORG)*DY-TR(4)
      DXX=TR11*DX
      DXY=TR12*DY
      DYX=TR21*DX
      DYY=TR22*DY
      XI1=TR11*X1+TR12*Y1
      YJ1=TR21*X1+TR22*Y1
      DO 40 JY=JY1,JY2
        XI=XI1
        YJ=YJ1
        BUFFER(2)=FLOAT(JY)
        NPIX=2
        DO 30 IX=IX1,IX2
          I=INT(XI)
          J=INT(YJ)
          IF (I.GE.I1 .AND. I.LT.I2 .AND. J.GE.J1 .AND. J.LT.J2) THEN
            IF (NPIX.EQ.2) BUFFER(1)=FLOAT(IX)
            II=I+1
            JJ=J+1
            X=XI-FLOAT(I)
            Y=YJ-FLOAT(J)
            AXY=(1.0-X)*(A(I,J)+Y*(A(I,JJ)-A(I,J)))+
     *               X*(A(II,J)+Y*(A(II,JJ)-A(II,J)))
            K=NINT((AXY-BG)*ASCALE)
            IF (K.LT.0) K=0
            IF (K.GE.NC) K=NC-1
            NPIX=NPIX+1
            BUFFER(NPIX)=FLOAT(K+IC1)
          ENDIF
          XI=XI+DXX
          YJ=YJ+DYX
  30    CONTINUE
        CALL GREXEC(GRGTYP,26,BUFFER,NPIX,CHR,LCHR)
        XI1=XI1+DXY
        YJ1=YJ1+DYY
  40  CONTINUE
      END SUBROUTINE PGCLPX

      SUBROUTINE PGCLPS(A,IDIM,JDIM,I1,I2,J1,J2,BG,TR,ASCALE,IR,IG,IB,
     *                  NC,LCOLOR)
C     -----------------------------------------------------------------
C
C Postscript support subroutine for PGCELL.
C
      use grpckg1inc
      REAL      A(IDIM,*),TR(*)
      INTEGER   IR(0:*),IG(0:*),IB(0:*)
      INTEGER   VALUE(33)
      LOGICAL   LCOLOR
      CHARACTER INLINE*80
C
C Set clipping rectangle in device.
C
      CALL DSQINF(XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *            YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC)
      WRITE (INLINE,100) NINT(XOFF),NINT(YOFF),NINT(XLEN),NINT(YLEN),
     *          -NINT(XLEN)
 100  FORMAT(I6,I6,' moveto ',I6, ' 0 rlineto  0 ',I6,' rlineto ',
     *I6,' 0 rlineto')
      CALL GRTERM
      CALL GRESC(' newpath ')
      CALL GRESC(INLINE)
      CALL GRESC(' closepath ')
C
C Work out the nunmber of X and Y pixels for PS image, with NDOTS per 
C inch, and build an image transformation matrix.
C
      NDOTS=100
C      IF (LCOLOR) NDOTS=50
      NXP=NINT(FLOAT(NDOTS)*XLEN/XPERIN)
      NYP=NINT(FLOAT(NDOTS)*YLEN/YPERIN)
      DXI=FLOAT(I2-I1)/FLOAT(NXP)
      DYJ=FLOAT(J2-J1)/FLOAT(NYP)
      DET=TR(2)*TR(6)-TR(3)*TR(5)
      TR11=+TR(6)/DET
      TR12=-TR(3)/DET
      TR21=-TR(5)/DET
      TR22=+TR(2)/DET
      AT=TR11/(XSCALE*DXI)
      BT=TR21/(XSCALE*DYJ)
      CT=TR12/(YSCALE*DXI)
      DT=TR22/(YSCALE*DYJ)
      TX=-(TR11*(XORG/XSCALE+TR(1))+TR12*(YORG/YSCALE+TR(4))+I1)/DXI
      TY=-(TR21*(XORG/XSCALE+TR(1))+TR22*(YORG/YSCALE+TR(4))+J1)/DYJ
C
C Use a PostScript "image" operator.
C
      WRITE (INLINE, '(A,I5,A)') '/picstr ',NXP,' string def'
      CALL GRESC(INLINE)
      WRITE (INLINE,110) NXP,NYP,AT,BT,CT,DT,TX,TY
 110  FORMAT(2I4,' 8 [',6(1PE10.3,' '),']')
      CALL GRESC(INLINE)
      CALL GRESC('{ currentfile picstr readhexstring pop}')
      IF (LCOLOR) THEN
        CALL GRESC('  false 3 colorimage')
      ELSE
        CALL GRESC('  image')
      ENDIF
C
C Write out the image array in hexadecimal.
C
      ASCALE=ASCALE*255.0/FLOAT(NC-1)
      YJ=FLOAT(J1)
      DO 20 JP=1,NYP
        J=INT(YJ)
        Y=YJ-FLOAT(J)
        JJ=J+1
        IF (JJ.GT.J2) JJ=J2
        XI=FLOAT(I1)
        L=0
        DO 10 IP=1,NXP
          L=L+1
          I=INT(XI)
          X=XI-FLOAT(I)
          II=I+1
          IF (II.GT.I2) II=I2
          AXY=(1.0-X)*(A(I,J)+Y*(A(I,JJ)-A(I,J)))+
     *             X*(A(II,J)+Y*(A(II,JJ)-A(II,J)))
          IC=NINT((AXY-BG)*ASCALE)
          IF (IC.LT.0) IC=0
          IF (IC.GE.NC) IC=NC-1
          IF (LCOLOR) THEN
            VALUE(L)=IR(IC)
            VALUE(L+1)=IG(IC)
            VALUE(L+2)=IB(IC)
            L=L+2
          ELSE
            VALUE(L)=(IR(IC)+IG(IC)+IB(IC))/3
          ENDIF
          IF (L.EQ.33) THEN
            WRITE(INLINE,120) (VALUE(K),K=1,33)
 120        FORMAT(33Z2.2)
            CALL GRESC(INLINE(1:66))
            L=0
          ENDIF
          XI=XI+DXI
   10   CONTINUE
        IF (L.NE.0) THEN
          WRITE(INLINE,120) (VALUE(K),K=1,L)
          CALL GRESC(INLINE(1:2*L))
        ENDIF
        YJ=YJ+DYJ
   20 CONTINUE
      CALL GRESC(' newpath ')
      CALL GRTERM
      END SUBROUTINE PGCLPS

      SUBROUTINE PLOT(X,NX,Y,NY,Z,N1,N2,W,SIZE,IWIDTH,XLBL,YLBL,TITL)
C     ---------------------------------------------------------------
C
      use coltabs
      REAL          X(*),Y(*),Z(N1,N2)
      CHARACTER*(*) XLBL,YLBL,TITL
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C
C Purpose
C      This subroutine plots "data" defined on a regularly-spaced 
C   rectangular grid of points Z(I,J). With the default choice for the 
C   PGCELL routine that is linked, the output is a linearly-interpolated 
C   map (rather than coarse rectangular boxes).
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    Z        R*4    I    N1 x N2   The recatangular "data"-array.
C    Z        R*4    O    N1 x N2   A scaled, and clipped, version of 
C                                   the input array(!).
C    N1       I*4    I       -      The first dimension of array Z.
C    N2       I*4    I       -      The second dimension of array Z.
C    X        R*4    I      NX      Array of X-coordinates.
C    NX       I*4    I       -      Number of X-pixels to be plotted 
C                                  (usually = N1, but must be <= N1).
C    Y        R*4    I      NY      Array of Y-coordinates.
C    NY       I*4    I       -      Number of Y-pixels to be plotted 
C                                  (usually = N2, but must be <= N2).
C    W        R*4    I       -      Dummy parameter (back-compatibility).
C    SIZE     R*4    I       -      Character-size for plot (try 1.5).
C    IWIDTH   I*4    I       -      Line-width for plot (try 2).
C    XLBL     A*1    I     *(*)     Label for X-axis.
C    YLBL     A*1    I     *(*)     Label for Y-axis.
C    TITL     A*1    I     *(*)     Title for plot.
C
C Globals
C    COLTABS.INC
C
C History
C   Initial release.                                    DSS:  3 Jul 1992
C   Minor changes to conform with new PGCELL.           DSS:  6 Feb 1995
C   Put in option to over-lay contours.                 DSS: 21 Feb 1995
C   Now has proper 3-d surface surface rendering.       DSS: 27 Aug 1997
C   Fortran made LINUX-friendly!                        DSS: 15 Sep 1997
C   Choose white background colour for postscript.      DSS:  5 Feb 1999
C-----------------------------------------------------------------------
C
C      INCLUDE  'COLTABS.INC'
      REAL      RGB(3,3),EYE(3),LIGHT(3),LATICE(3,3),LUTUSR(3,256)
      CHARACTER STRING*32,TYPE*16,CHR*16
      LOGICAL   OVRLAY,LSHIN
      DATA      EYE,LIGHT /0.0,0.0,1000.0,-1.0,-1.0,-1.0/
      DATA      RGB /0.0,0.0,1.0,0.35,0.35,0.35,1.0,1.0,1.0/
C
      WRITE(*,*)
      WRITE(*,*)'                (0) Contour'
      WRITE(*,*)'                (1) Surface'
      WRITE(*,*)'                (2) Colour: Grey-Scale'
      WRITE(*,*)'                (3) Colour: Heat'
      WRITE(*,*)'                (4) Colour: Rainbow Spectrum'
      WRITE(*,*)'                (5) Colour: BGYRW'
      WRITE(*,*)'                (6) Colour: Serpent'
      WRITE(*,*)'                (7) Colour: Read in from file'
      WRITE(*,*)
   1  IPLOT=0
      WRITE(*,100)
 100  FORMAT(' PLOT>  Type ?  : ',$)
      CALL FORMTQ(STRING,32,NNN)
      IF (NNN.NE.0) READ(STRING,*,ERR=1) IPLOT
      IF (IPLOT.EQ.0) THEN
        CALL CONTOR(Z,NX,NY,X,Y,N1,N2,SIZE,IWIDTH,.FALSE.)
      ELSEIF (IPLOT.EQ.1) THEN
        IF (N1.NE.NX .OR. N2.NE.NY) THEN
          WRITE(*,*)' Sorry folks, SURFACE option needs N1=NX & N2=NY!'
          WRITE(*,*)
          GOTO 1
        ENDIF
        CALL SRFCOL(RGB,NCB,ICTAB,DIFUS,SHIN,POLISH,LSHIN,3,7)
        CALL EULER(LATICE)
        CALL FMXMN(Z,N1*N2,DHIGH,DLOW,DOFSET)
        CALL PGBEGIN(0,'?',1,1)
        CALL PGPAPER(0.0,1.0)
        CALL PGQCOL(ICMIN,ICMAX)
        NCBAND=MIN(NCB,ICMAX-17+1)
        CALL PGSCH(SIZE)
        CALL PGSLW(IWIDTH)
        CALL PGVPORT(0.0,1.0,0.0,1.0)
        CALL PGWINDOW(-0.87,0.92,-0.87,0.87)
        CALL PGSCI(0)
        CALL PGBOX('BC',0.0,0,'BC',0.0,0)
        CALL PGSCI(1)
        CALL PGQINF('TYPE',TYPE,LCHR)
        IF (TYPE.EQ.'PS' .OR. TYPE.EQ.'VPS' .OR. TYPE.EQ.'CPS' .OR.
     *      TYPE.EQ.'VCPS') THEN
          CALL SBFINT(RGB(1,3),16,1,1,MAXBUF)
        ELSE
          CALL SBFINT(RGB(1,2),16,1,1,MAXBUF)
        ENDIF
        IF (ICTAB.LE.2) THEN
          CALL COLINT(RGB,17,ICMAX,DIFUS,SHIN,POLISH)
        ELSEIF (ICTAB.EQ.3) THEN
          CALL COLSRF(HEAT,256,1.0,17,ICMAX,NCB,DIFUS,SHIN,POLISH)
        ELSEIF (ICTAB.EQ.4) THEN
          CALL COLSRF(SPECTRUM(1,2),255,1.0,17,ICMAX,NCB,DIFUS,SHIN,
     *                POLISH)
        ELSEIF (ICTAB.EQ.5) THEN
          CALL COLSRF(BGYRW,256,1.0,17,ICMAX,NCB,DIFUS,SHIN,POLISH)
        ELSEIF (ICTAB.EQ.6) THEN
          CALL COLSRF(SERP,256,1.0,17,ICMAX,NCB,DIFUS,SHIN,POLISH)
        ELSE
          NCLMAX=256
          CALL LUTIN(LUTUSR,NCLMAX,NCLUSR,IFLAG)
          CALL COLSRF(LUTUSR,NCLUSR,1.0,17,ICMAX,NCB,DIFUS,SHIN,POLISH)
        ENDIF
        CALL SB2SRF(EYE,LATICE,Z,N1-1,N2-1,DLOW,DHIGH,1.0,17,ICMAX,NCB,
     *              LIGHT,LSHIN)
        CALL AXES3D(EYE,LATICE,X(1),X(N1),Y(1),Y(N2),XLBL,YLBL,SIZE,
     *              DLOW,DHIGH,DOFSET,Z(1,1),Z(N1,1),Z(N1,N2),Z(1,N2))
        CALL SBFCLS(1)
        CALL PGMTEXT('T',-1.2,0.5,0.5,TITL)
      ELSEIF (IPLOT.LE.7) THEN
        CALL GREY(Z,NX,NY,X,Y,N1,N2,IPLOT,SIZE,IWIDTH)
      ELSE
        GOTO 1
      ENDIF
      IF (IPLOT.NE.1) CALL PGLABEL(XLBL,YLBL,TITL)
      IF (IPLOT.GT.1) THEN
        WRITE(*,*)
        CALL LOGQYN(' PLOT> Over-lay contours ?','N',OVRLAY)
        IF (OVRLAY) CALL CONTOR(Z,NX,NY,X,Y,N1,N2,SIZE,IWIDTH,OVRLAY)
      ENDIF
      CALL PGEND
      END SUBROUTINE PLOT

      SUBROUTINE FMXMN(Y,N,YMAX,YMIN,YOFSET)
C     --------------------------------------
C
      REAL         Y(*)
      CHARACTER*32 STRING
C
      YMIN1=+1.0E25
      YMAX1=-1.0E25
      DO 10 I=1,N
        YMIN1=MIN(YMIN1,Y(I))
        YMAX1=MAX(YMAX1,Y(I))
  10  CONTINUE
   1  YMIN=YMIN1
      YMAX=YMAX1
      WRITE(*,100) YMIN,YMAX
 100  FORMAT(' Surface>  Zmin & Zmax for plot ? (def=',1pe10.3,
     *       ',',E10.3,')  : ',$)
      CALL FORMTQ(STRING,32,NNN)
      IF (NNN.NE.0) READ(STRING,*,ERR=1) YMIN,YMAX
      IF (YMAX.LE.YMIN) GOTO 1
      YOFSET=MAX(-YMIN,0.0)
      IF (YOFSET.GT.0.0) THEN
        YMIN=YMIN+YOFSET
        YMAX=YMAX+YOFSET
        DO 20 I=1,N
  20      Y(I)=Y(I)+YOFSET
      ENDIF
      END SUBROUTINE FMXMN

      SUBROUTINE EULER(LATICE)
C     ------------------------
C
      CHARACTER*32 STRING
      REAL         LATICE(3,*)
      DATA         PIRAD /0.01745329252/
C
   1  WRITE(*,100)
 100  FORMAT(' Surface> Rotation and tilt ?  (def=45,30 deg) : ',$)
      CALL FORMTQ(STRING,32,NNN)
      IF (NNN.EQ.0) THEN
        SINA=-0.7071067814
        COSA=+0.7071067814
        SINB=-0.5
        COSB=0.866025404
      ELSE
        READ(STRING,*,ERR=1) IA,IB
        SINA=-SIN(FLOAT(IA)*PIRAD)
        COSA=COS(FLOAT(IA)*PIRAD)
        SINB=-SIN(FLOAT(IB)*PIRAD)
        COSB=COS(FLOAT(IB)*PIRAD)
      ENDIF
      CALL ROTY(-0.5,-0.5,+0.5,U,V,W,SINA,COSA)
      CALL ROTX(U,V,W,LATICE(1,1),LATICE(2,1),Z1,SINB,COSB)
      LATICE(3,1)=Z1-1.0
      CALL ROTY(+0.5,-0.5,+0.5,U,V,W,SINA,COSA)
      CALL ROTX(U,V,W,LATICE(1,2),LATICE(2,2),Z2,SINB,COSB)
      LATICE(3,2)=Z2-1.0
      CALL ROTY(-0.5,-0.5,-0.5,U,V,W,SINA,COSA)
      CALL ROTX(U,V,W,LATICE(1,3),LATICE(2,3),Z3,SINB,COSB)
      LATICE(3,3)=Z3-1.0
      END SUBROUTINE EULER

      SUBROUTINE ROTX(X,Y,Z,U,V,W,S,C)
C     --------------------------------
C
      U=X
      V=Y*C+Z*S
      W=-Y*S+Z*C
      END SUBROUTINE ROTX

      SUBROUTINE ROTY(X,Y,Z,U,V,W,S,C)
C     --------------------------------
C
      U=X*C-Z*S
      V=Y
      W=X*S+Z*C
      END SUBROUTINE ROTY

      SUBROUTINE SRFCOL(RGB,NCBAND,ICTAB,DIF,SHIN,POLISH,LSHIN,IC1,IC2)
C     -----------------------------------------------------------------
C
      REAL         RGB(*)
      LOGICAL      LSHIN
      CHARACTER*32 STRING
C
      POLISH=1.0
   1  ICTAB=0
      WRITE(*,100) IC1,IC2,ICTAB
 100  FORMAT(' Surface> Colour table ?  (',I1,'-',I1,',def=',I1,
     *       ') : ',$)
      CALL FORMTQ(STRING,32,NNN)
      IF (NNN.NE.0) READ(STRING,*,ERR=1) ICTAB
      IF (ICTAB.GT.IC2) THEN
        GOTO 1
      ELSEIF (ICTAB.LT.IC1) THEN
        NCBAND=1
   2    RGB(1)=0.0
        RGB(2)=1.0
        RGB(3)=0.0
        WRITE(*,110) (RGB(I),I=1,3)
 110    FORMAT(' Surface> RGB colour ?  (def=',F3.1,',',F3.1,',',
     *    F3.1,') : ',$)
        CALL FORMTQ(STRING,32,NNN)
        IF (NNN.NE.0) READ(STRING,*,ERR=2) (RGB(I),I=1,3)
        IF (RGB(1)+RGB(2)+RGB(3).LE.0.05) GOTO 2 
      ELSE
   3    NCBAND=8
        WRITE(*,120) NCBAND
 120    FORMAT(' Surface> No. of colour-bands ?  (def=',I1,') : ',$)
        CALL FORMTQ(STRING,32,NNN)
        IF (NNN.NE.0) READ(STRING,*,ERR=3) NCBAND
        NCBAND=MAX(MIN(NCBAND,64),1)
      ENDIF
      CALL LOGQYN(' Surface> A shiny gloss ?','N',LSHIN)
      IF (LSHIN) THEN
        SHIN=1.0
        DIF=0.0
      ELSE
        SHIN=0.0
   4    DIF=0.7
        WRITE(*,130) DIF
 130    FORMAT(' Surface> Diffusiveness ?  (def=',F3.1,') : ',$)
        CALL FORMTQ(STRING,32,NNN)
        IF (NNN.NE.0) READ(STRING,*,ERR=4) DIF
        DIFUSE=MAX(MIN(DIF,1.0),0.1)
      ENDIF
      END SUBROUTINE SRFCOL

      SUBROUTINE AXES3D(EYE,LATICE,XMIN,XMAX,YMIN,YMAX,XLBL,YLBL,SIZE,
     *                  DLOW,DHIGH,DOFSET,D00,DX0,DXY,D0Y)
C     ----------------------------------------------------------------
C
      REAL          EYE(*),LATICE(3,*)
      REAL          PIVX(3),PIVY(3),ORX(3,2),ORY(3,2),LATCAB(3,4)
      CHARACTER*(*) XLBL,YLBL
C
      IF (XMAX.LE.XMIN .OR. YMAX.LE.YMIN) RETURN
      SCLA=0.15*SIZE
      AX=LATICE(1,2)-LATICE(1,1)
      AY=LATICE(2,2)-LATICE(2,1)
      AZ=LATICE(3,2)-LATICE(3,1)
      BX=LATICE(1,3)-LATICE(1,1)
      BY=LATICE(2,3)-LATICE(2,1)
      BZ=LATICE(3,3)-LATICE(3,1)
      CX=AY*BZ-BY*AZ
      CY=AZ*BX-BZ*AX
      CZ=AX*BY-BX*AY
      XSIGN=+1.0
      XSCL=-SCLA
      IF (CY*BZ.GT.0.0) THEN
        XSIGN=-1.0
        XSCL=1.0+SCLA
      ENDIF
      ORX(1,1)=XSIGN*AX
      ORX(2,1)=XSIGN*AY
      ORX(3,1)=XSIGN*AZ
      ORX(1,2)=XSIGN*BX
      ORX(2,2)=XSIGN*BY
      ORX(3,2)=XSIGN*BZ
      PIVX(1)=0.5*(LATICE(1,1)+LATICE(1,2))+XSCL*BX
      PIVX(2)=0.5*(LATICE(2,1)+LATICE(2,2))+XSCL*BY
      PIVX(3)=0.5*(LATICE(3,1)+LATICE(3,2))+XSCL*BZ
      CALL SBTEXT(EYE,XLBL,1,PIVX,0.5,ORX,SCLA*0.2)
      CALL AXNUMS(EYE,XMIN,XMAX,PIVX,ORX,SCLA,XSIGN)
      YSIGN=-1.0
      YSCL=-SCLA
      IF (CY*AZ.GT.0.0) THEN
        YSIGN=1.0
        YSCL=1.0+SCLA
      ENDIF
      ORY(1,1)=YSIGN*BX
      ORY(2,1)=YSIGN*BY
      ORY(3,1)=YSIGN*BZ
      ORY(1,2)=-YSIGN*AX
      ORY(2,2)=-YSIGN*AY
      ORY(3,2)=-YSIGN*AZ
      PIVY(1)=0.5*(LATICE(1,1)+LATICE(1,3))+YSCL*AX
      PIVY(2)=0.5*(LATICE(2,1)+LATICE(2,3))+YSCL*AY
      PIVY(3)=0.5*(LATICE(3,1)+LATICE(3,3))+YSCL*AZ
      CALL SBTEXT(EYE,YLBL,1,PIVY,0.5,ORY,SCLA*0.2)
      CALL AXNUMS(EYE,YMIN,YMAX,PIVY,ORY,SCLA,YSIGN)
      LATCAB(1,1)=LATICE(1,2)+BX
      LATCAB(2,1)=LATICE(2,2)+BY
      LATCAB(3,1)=LATICE(3,2)+BZ
      CALL SBLINE(EYE,LATICE(1,1),LATICE(1,2),1,.FALSE.)
      CALL SBLINE(EYE,LATICE(1,2),LATCAB(1,1),1,.FALSE.)
      CALL SBLINE(EYE,LATCAB(1,1),LATICE(1,3),1,.FALSE.)
      CALL SBLINE(EYE,LATICE(1,3),LATICE(1,1),1,.FALSE.)
      ZSCALE=1.0/MAX(DHIGH-DLOW,1.0E-20)
      FRACZ=MAX((D00-DLOW)*ZSCALE,0.0)
      LATCAB(1,2)=LATICE(1,1)+FRACZ*CX
      LATCAB(2,2)=LATICE(2,1)+FRACZ*CY
      LATCAB(3,2)=LATICE(3,1)+FRACZ*CZ
      CALL SBLINE(EYE,LATICE(1,1),LATCAB(1,2),1,.FALSE.)
      CALL VCOPY(LATICE(1,1),LATCAB(1,3),3)
      ZXMIN=LATCAB(1,3)
      FRACZ=MAX((DX0-DLOW)*ZSCALE,0.0)
      LATCAB(1,2)=LATICE(1,2)+FRACZ*CX
      LATCAB(2,2)=LATICE(2,2)+FRACZ*CY
      LATCAB(3,2)=LATICE(3,2)+FRACZ*CZ
      CALL SBLINE(EYE,LATICE(1,2),LATCAB(1,2),1,.FALSE.)
      IF (LATICE(1,2).GT.ZXMIN) THEN
        CALL VCOPY(LATICE(1,2),LATCAB(1,3),3)
        ZXMIN=LATCAB(1,3)
      ENDIF
      FRACZ=MAX((DXY-DLOW)*ZSCALE,0.0)
      LATCAB(1,2)=LATCAB(1,1)+FRACZ*CX
      LATCAB(2,2)=LATCAB(2,1)+FRACZ*CY
      LATCAB(3,2)=LATCAB(3,1)+FRACZ*CZ
      IF (LATCAB(1,1).GT.ZXMIN) THEN
        CALL VCOPY(LATCAB(1,1),LATCAB(1,3),3)
        ZXMIN=LATCAB(1,3)
      ENDIF
      CALL SBLINE(EYE,LATCAB(1,1),LATCAB(1,2),1,.FALSE.)
      FRACZ=MAX((D0Y-DLOW)*ZSCALE,0.0)
      LATCAB(1,2)=LATICE(1,3)+FRACZ*CX
      LATCAB(2,2)=LATICE(2,3)+FRACZ*CY
      LATCAB(3,2)=LATICE(3,3)+FRACZ*CZ
      CALL SBLINE(EYE,LATICE(1,3),LATCAB(1,2),1,.FALSE.)
      IF (LATICE(1,3).GT.ZXMIN) THEN
        CALL VCOPY(LATICE(1,3),LATCAB(1,3),3)
        ZXMIN=LATCAB(1,3)
      ENDIF
      LATCAB(1,4)=LATCAB(1,3)+CX
      LATCAB(2,4)=LATCAB(2,3)+CY
      LATCAB(3,4)=LATCAB(3,3)+CZ
      CALL SBLINE(EYE,LATCAB(1,3),LATCAB(1,4),1,.FALSE.)
      CALL AZNUMS(EYE,DLOW-DOFSET,DHIGH-DOFSET,LATCAB(1,3),SCLA)
      END SUBROUTINE AXES3D

      SUBROUTINE AXNUMS(EYE,XMIN,XMAX,PIVX,ORX,SCLA,XSIGN)
C     ----------------------------------------------------
C
      REAL      EYE(*),PIVX(*),ORX(3,*)
      REAL      END1(3),END2(3),PIVOT(3)
      CHARACTER NLBL*20
      DATA      FRTICK,FRNUM /0.02,0.10/
C
      XR=PGRND(XMAX-XMIN,NSUB)
      DX=XR/FLOAT(NSUB)
      IF (DX.LE.1.0E-20) RETURN
   1  XJ=DX*FLOAT(1+INT(XMIN/DX))
      IF ((XJ+DX).GE.XMAX) THEN
        DX=DX/2.0
        NSUB=NSUB*2
        GOTO 1
      ENDIF
      IF (XMIN.LT.0.0) XJ=XJ-DX
      XN=XSIGN/(XMAX-XMIN)
      XH=0.5*(XMIN+XMAX)
      DO 20 J=1,NSUB
        IF (XJ.GT.XMAX) RETURN
        XF=XN*(XJ-XH)
        DO 10 I=1,3
          END1(I)=PIVX(I)+XF*ORX(I,1)+SCLA*ORX(I,2)
          END2(I)=END1(I)-FRTICK*ORX(I,2)
          PIVOT(I)=END1(I)-FRNUM*ORX(I,2)
  10    CONTINUE
        IPOWER=INT(LOG10(ABS(XJ)+1.0E-10))-5
        IF (XJ.LT.1.0) IPOWER=IPOWER-1
        X=XJ/(10.0**IPOWER)
        IMANTS=NINT(X)
        CALL PGNUMB(IMANTS,IPOWER,0,NLBL,NC)
        CALL SBLINE(EYE,END1,END2,1,.FALSE.)
        CALL SBTEXT(EYE,NLBL,1,PIVOT,0.5,ORX,SCLA*0.15)
        XJ=XJ+DX
  20  CONTINUE
      END SUBROUTINE AXNUMS

      SUBROUTINE AZNUMS(EYE,ZMIN,ZMAX,LATZ,SCLA)
C     ------------------------------------------
C
      REAL      EYE(*),LATZ(3,*)
      REAL      END1(3),END2(3),PIVOT(3),ORIENT(3,3)
      CHARACTER NLBL*20
      DATA      FRTICK,FRNUM /0.05,0.10/
C
      ORIENT(1,1)=SCLA
      ORIENT(2,1)=0.0
      ORIENT(3,1)=0.0
      ZSIGN=+1.0
      IF ((LATZ(2,2)-LATZ(2,1)).LT.0.0) ZSIGN=-1.0
      DO 10 I=1,3
        ORIENT(I,3)=LATZ(I,2)-LATZ(I,1)
        ORIENT(I,2)=ZSIGN*SCLA*ORIENT(I,3)
  10  CONTINUE
      ZR=PGRND(ZMAX-ZMIN,NSUB)
      DZ=ZR/FLOAT(NSUB)
      IF (DZ.LE.1.0E-20) RETURN
   1  ZJ=DZ*FLOAT(1+INT(ZMIN/DZ))
      IF ((ZJ+DZ).GE.ZMAX) THEN
        DZ=DZ/2.0
        NSUB=NSUB*2
        GOTO 1
      ENDIF
      IF (ZMIN.LE.0.0) ZJ=ZJ-DZ
      ZN=1.0/(ZMAX-ZMIN)
      DO 30 J=1,NSUB
        IF (ZJ.GT.ZMAX) RETURN
        ZF=ZN*(ZJ-ZMIN)
        DO 20 I=1,3
          END1(I)=LATZ(I,1)+ZF*ORIENT(I,3)
          END2(I)=END1(I)+FRTICK*ORIENT(I,1)
          PIVOT(I)=END1(I)+FRNUM*ORIENT(I,1)-FRTICK*ORIENT(I,2)
  20    CONTINUE
        IPOWER=INT(LOG10(ABS(ZJ)+1.0E-10))-5
        IF (ZJ.LT.1.0) IPOWER=IPOWER-1
        Z=ZJ/(10.0**IPOWER)
        IMANTS=NINT(Z)
        CALL PGNUMB(IMANTS,IPOWER,0,NLBL,NC)
        CALL SBLINE(EYE,END1,END2,1,.FALSE.)
        CALL SBTEXT(EYE,NLBL,1,PIVOT,0.0,ORIENT,SCLA*0.12)
        ZJ=ZJ+DZ
  30  CONTINUE
      END SUBROUTINE AZNUMS

      SUBROUTINE CONTOR(MAP,NX,NY,X,Y,N1,N2,SIZE,IWIDTH,OVRLAY)
C     ---------------------------------------------------------
C
      REAL    MAP(*),X(*),Y(*)
      REAL    CONT(25,2),TR(6)
      INTEGER NCONT(2),LCOLOR(2),LSTYLE(2),LWIDTH(2)
      LOGICAL OVRLAY
      DATA    LCOLOR,LSTYLE,LWIDTH,NWIND,IDP /1,3,1,1,1,2,1,0/
C
      CALL INIT(X,Y,NX,NY,TR,MAP,DMIN,DMAX,N1*N2)
      IF (OVRLAY) THEN
        CALL AUTCNT(NCONT,CONT,DMIN,DMAX,OVRLAY)
        CALL PGSLW(1)
        CALL PGCONT(MAP,N1,N2,1,NX,1,NY,CONT,NCONT,TR)
        CALL PGSLW(IWIDTH)
        RETURN
      ENDIF
      CALL ASKCNT(NCONT,CONT,DMIN,DMAX)
      CALL PGBEGIN(0,'?',1,1)
      CALL PGPAPER(0.0,1.0)
      CALL PGSCH(SIZE)
      CALL PGSLW(IWIDTH)
      CALL PGENV(X(1),X(NX),Y(1),Y(NY),0,0)
      DO 20 I=1,2
        CALL PGSCI(LCOLOR(I))
        CALL PGSLS(LSTYLE(I))
        LWDTH=2*LWIDTH(I)
        IF (LWDTH.GT.7) LWDTH=7
        CALL PGSLW(LWDTH)
        CALL PGCONT(MAP,N1,N2,1,NX,1,NY,CONT(1,I),NCONT(I),TR)
  20  CONTINUE
      CALL PGSCI(1)
      CALL PGSLW(IWIDTH)
      END SUBROUTINE CONTOR

      SUBROUTINE INIT(X,Y,NX,NY,TR,MAP,DMIN,DMAX,NMAP)
C     ------------------------------------------------
C
      REAL X(*),Y(*),TR(*),MAP(*)
C
      TR(1)=X(1)-(X(NX)-X(1))/FLOAT(NX-1)
      TR(2)=(X(NX)-X(1))/FLOAT(NX-1)
      TR(3)=0.0
      TR(4)=Y(1)-(Y(NY)-Y(1))/FLOAT(NY-1)
      TR(5)=0.0
      TR(6)=(Y(NY)-Y(1))/FLOAT(NY-1)
      DMIN=+1.0E+20
      DMAX=-1.0E+20
      DTOT=0.0
      DO 10 I=1,NMAP
        F=MAP(I)
        DTOT=DTOT+F
        IF (F.GT.DMAX) DMAX=F
        IF (F.LT.DMIN) DMIN=F
  10  CONTINUE
      WRITE(*,*)
      WRITE(*,*)' Minimum value = ',DMIN
      WRITE(*,*)' Maximum value = ',DMAX
      WRITE(*,*)' Total flux    = ',DTOT
      WRITE(*,*)
      END SUBROUTINE INIT

      SUBROUTINE ASKCNT(NCONT,CONT,DMIN,DMAX)
C     ---------------------------------------
C
      REAL           CONT(25,*),C(25)
      INTEGER        NCONT (*)
      LOGICAL        AUTO
      CHARACTER*132 STRING
C
      WRITE(*,*)
      CALL LOGQYN(' Contours>  Autoscale (linear) ?','Y',AUTO)
      IF (AUTO) THEN
        CALL AUTCNT(NCONT,CONT,DMIN,DMAX,.FALSE.)
        RETURN
      ENDIF
      WRITE(*,*)
      WRITE(*,*)'          ***** Contour Values  *****'
      WRITE(*,*)
   1  WRITE(*,100)
 100  FORMAT(' Thin>  ',$)
      READ(*,200,ERR=1) STRING
 200  FORMAT(A)
      CALL FINDNC(STRING,132,NCONT(1))
      READ(STRING,*,ERR=1) (CONT(I,1),I=1,NCONT(1))
      WRITE(*,*)
   2  WRITE(*,110)
 110  FORMAT(' Thick>  ',$)
      READ(*,200,ERR=2) STRING
      CALL FINDNC(STRING,132,NCONT(2))
      READ(STRING,*,ERR=2) (CONT(I,2),I=1,NCONT(2))
      END SUBROUTINE ASKCNT

      SUBROUTINE FINDNC(STRING,NCHARS,NC)
C     -----------------------------------
C
      CHARACTER STRING(*)
C
      DO 10 I=1,NCHARS
  10    IF (STRING(I).NE.' ') GOTO 1
   1  IMIN=I
      DO 20 I=NCHARS,1,-1
  20    IF (STRING(I).NE.' ') GOTO 2
   2  IMAX=I
      IF (IMIN.LE.IMAX) THEN
        NC=1
        J=IMIN
        DO 30 I=IMIN,IMAX
          IF (J.GT.IMAX) RETURN
          IF (STRING(J).EQ.' ' .OR. STRING(J).EQ.',') THEN
            NC=NC+1
   3        IF (STRING(J+1).EQ.' ' .OR. STRING(J+1).EQ.',') THEN
              J=J+1
              GOTO 3
            ENDIF
          ENDIF
          J=J+1
  30    CONTINUE
      ELSE
        NC=0
      ENDIF
      END SUBROUTINE FINDNC

      SUBROUTINE AUTCNT(NCONT,CONT,DMIN,DMAX,OVRLAY)
C     ----------------------------------------------
C
      REAL         CONT(25,*)
      INTEGER      NCONT(*)
      LOGICAL       OVRLAY
      CHARACTER*32 STRING
C
      WRITE(*,*)
   1  WRITE(*,100) DMIN,DMAX
 100  FORMAT(' Autoscale> Range ? (def=',1pe10.3,' to ',e10.3,')  : ',$)
      CALL FORMTQ(STRING,32,NNN)
      IF (NNN.NE.0) READ(STRING,*,ERR=1) DMIN1,DMAX1
      IF (NNN.NE.0) THEN
        DMIN=DMIN1
        DMAX=DMAX1
      ENDIF
   2  N=10
      WRITE(*,110) N
 110  FORMAT(' Autoscale>  No. of contours ?  (def=',I2,') : ',$)
      CALL FORMTQ(STRING,32,NNN)
      IF (NNN.NE.0) READ(STRING,*,ERR=2) N
      N=MAX(MIN(N,50),2)
      NCONT(1)=(N+1)/2
      NCONT(2)=N-NCONT(1)
      IF (OVRLAY) THEN
        IF (N.GT.25) N=25
        NCONT(1)=N
        NCONT(2)=0
      ENDIF
      XINC=(DMAX-DMIN)/FLOAT(N)
      X=DMIN+0.5*XINC
      DO 10 I=1,NCONT(1)
        CONT(I,1)=X
        X=X+XINC
  10  CONTINUE
      DO 20 I=1,NCONT(2)
        CONT(I,2)=X
        X=X+XINC
  20  CONTINUE
      END SUBROUTINE AUTCNT

      SUBROUTINE GREY(MAP,NX,NY,X,Y,N1,N2,IPLOT,SIZE,IWIDTH)
C     ------------------------------------------------------
C
      REAL MAP(*),X(*),Y(*)
      REAL TR(6),TRCOL(6),COLBAR(2,256),LUTUSR(3,256)
      REAL RED(256),GR(256),BL(256)
      DATA TRCOL /0.0,1.0,0.0,0.0,0.0,1.0/
C
      NCOLS=256
      CALL INIT(X,Y,NX,NY,TR,MAP,DMIN,DMAX,N1*N2)
      CALL STGREY(MAP,N1*N2,DMIN,DMAX,COLBAR,NCOLS)
      TRCOL(6)=(DMAX-DMIN)/255.0
      TRCOL(4)=DMIN-TRCOL(6)
      IF (IPLOT.EQ.7) CALL LUTIN(LUTUSR,NCOLS,NCLUSR,IPLOT)
      CALL PGBEGIN(0,'?',1,1)
      CALL PGPAPER(0.0,1.0)
      CALL PGSCH(SIZE)
      CALL PGSLW(IWIDTH)
      CALL PGVPORT(0.86,0.90,0.2,0.90)
      CALL PGWINDOW(1.0,2.0,DMIN,DMAX)
      CALL SETCOL(IPLOT,NCOLS,LUTUSR,RED,GR,BL)
      CALL PGSCH(0.50*SIZE)
      CALL PGBOX('B',0.0,0,'B',0.0,0)
      CALL PGBOX('C',0.0,0,'CMTSVI',0.0,0)
      CALL PGCELL(COLBAR,2,256,1,2,1,256,1.0,0.0,TRCOL,NCOLS,RED,GR,BL)
      CALL PGBOX('B',0.0,0,'B',0.0,0)
      CALL PGBOX('C',0.0,0,'CMTSVI',0.0,0)
      CALL PGSCH(SIZE)
      CALL PGVPORT(0.12,0.82,0.2,0.90)
      XMIN=TR(1)+TR(2)
      XMAX=TR(1)+FLOAT(NX)*TR(2)
      YMIN=TR(4)+TR(6)
      YMAX=TR(4)+FLOAT(NY)*TR(6)
      CALL PGWINDOW(XMIN,XMAX,YMIN,YMAX)
      CALL PGBOX('C',0.0,0,'C',0.0,0)
      CALL PGBOX('BNSTI',0.0,0,'BNSTI',0.0,0)
      CALL PGCELL(MAP,N1,N2,1,NX,1,NY,1.0,0.0,TR,NCOLS,RED,GR,BL)
      CALL PGBOX('C',0.0,0,'C',0.0,0)
      CALL PGBOX('BNSTI',0.0,0,'BNSTI',0.0,0)
      END SUBROUTINE GREY

      SUBROUTINE STGREY(MAP,NMAP,FMIN,FMAX,COLBAR,NCOLS)
C     --------------------------------------------------
C
      REAL         MAP(*),COLBAR(2,*)
      CHARACTER*32 STRING
C
   1  WRITE(*,100) FMIN,FMAX
 100  FORMAT(' >>  Zmin & Zmax for plot ? (def=',1pe10.3,
     *       ',',E10.3,')  : ',$)
      CALL FORMTQ(STRING,32,NNN)
      IF (NNN.NE.0) READ(STRING,*,ERR=1) FMIN2,FMAX2
      IF (NNN.NE.0) THEN
        FMIN=FMIN2
        FMAX=FMAX2
      ENDIF
      IF (ABS(FMAX-FMIN).LT.1.0E-20) GOTO 1
      FNORM=1.0/(FMAX-FMIN)
   2  C=1.0
      WRITE(*,110) C
 110  FORMAT(' >>  Contrast factor ?  (def=',F3.1,')  : ',$)
      CALL FORMTQ(STRING,32,NNN)
      IF (NNN.NE.0) READ(STRING,*,ERR=2) C
      C=MAX(MIN(C,10.0),0.01)
      DO 10 I=1,NMAP
        F=(MAP(I)-FMIN)*FNORM
      IF (F.LE.0.0) THEN
          MAP(I)=0.0
        ELSEIF (F.GE.1.0) THEN
          MAP(I)=1.0
      ELSE
          MAP(I)=F**C
      ENDIF
  10  CONTINUE
      DCOL=0.999/FLOAT(NCOLS-1)
      COL=0.0
      IF (FMAX.LT.FMIN) THEN
        COL=1.0
        DCOL=-DCOL
      ENDIF
      DO 20 I=1,NCOLS
        COLBAR(1,I)=COL**C
        COLBAR(2,I)=COL**C
        COL=COL+DCOL
  20  CONTINUE
      END SUBROUTINE STGREY

      SUBROUTINE LUTIN(LUTUSR,NCOLS,NCLUSR,IPLOT)
C     -------------------------------------------
C
      CHARACTER*72 FILNAM
      REAL LUTUSR(3,NCOLS)
C
   1  WRITE(*,100)
 100  FORMAT(' INPUT> Filename for user colour-table ?  : ',$)
      READ(*,200,ERR=1) FILNAM
 200  FORMAT(A)
      OPEN(UNIT=17,FILE=FILNAM,STATUS='OLD',FORM='FORMATTED',ERR=1)
      DO 10 J=1,NCOLS
  10    READ(17,*,ERR=2,END=2) (LUTUSR(I,J),I=1,3)
   2  CLOSE(UNIT=17)
      NCLUSR=J-1
      WRITE(*,*)' No. of colour indicies read in = ',NCLUSR
      IF (NCLUSR.LE.1) THEN
        IPLOT=2
      ELSE
        NCOLS=NCLUSR
      ENDIF
      END SUBROUTINE LUTIN

      SUBROUTINE SETCOL(IPLOT,NCOLS,LUTUSR,R,G,B)
C     -------------------------------------------
C
      use coltabs
C      INCLUDE 'COLTABS.INC'
      REAL     LUTUSR(3,*),R(*),G(*),B(*)
C
      IF (IPLOT.EQ.2) THEN
        Z=0.0
        DZ=0.999/FLOAT(NCOLS-1)
        DO 10 I=1,NCOLS
          R(I)=Z
          G(I)=Z
          B(I)=Z
          Z=Z+DZ
  10    CONTINUE
      ELSEIF (IPLOT.EQ.3) THEN
        CALL STCOL1(HEAT,R,G,B,NCOLS)
      ELSEIF (IPLOT.EQ.4) THEN
        CALL STCOL1(SPECTRUM,R,G,B,NCOLS)
      ELSEIF (IPLOT.EQ.5) THEN
        CALL STCOL1(BGYRW,R,G,B,NCOLS)
      ELSEIF (IPLOT.EQ.6) THEN
        CALL STCOL1(SERP,R,G,B,NCOLS)
      ELSE
        CALL STCOL1(LUTUSR,R,G,B,NCOLS)
      ENDIF
      END SUBROUTINE SETCOL

      SUBROUTINE STCOL1(LUT,R,G,B,N)
C     ------------------------------
C
      REAL LUT(3,*),R(*),G(*),B(*)
C
      DO 10 I=1,N
        R(I)=LUT(1,I)
        G(I)=LUT(2,I)
        B(I)=LUT(3,I)
  10  CONTINUE
      END SUBROUTINE STCOL1

      SUBROUTINE VCOPY(X,Y,N)
C     -----------------------
C
      REAL X(*),Y(*)
C
      DO 10 I=1,N
  10    Y(I)=X(I)
      END SUBROUTINE VCOPY

      SUBROUTINE VRFILL(X,A,N)
C     ------------------------
C
      REAL X(*)
C
      DO 10 I=1,N
  10    X(I)=A
      END SUBROUTINE VRFILL

      SUBROUTINE LOGQYN(S,D,L)
C     ------------------------
C
      LOGICAL      L,L2
      CHARACTER*1  D,D2,A
      CHARACTER*45 STRING
      CHARACTER    S(*)
C
      IF (D.EQ.'Y') THEN
        L=.TRUE.
        D2='N'
        L2=.FALSE.
      ELSEIF (D.EQ.'N') THEN
        L=.FALSE.
        D2='Y'
        L2=.TRUE.
      ELSE
        WRITE(*,*)' Default should be Y or N !'
        RETURN
      ENDIF
      CALL STPACK(STRING,S,45)
   1  WRITE(*,100) STRING,D
 100  FORMAT(A45,' Y/N (def=',A1,')  : ',$)
      CALL FORMTQ(A,1,NNN)
      IF (NNN.EQ.0) RETURN
      IF (A.EQ.'y' .OR. A.EQ.'T' .OR. A.EQ.'t') A='Y'
      IF (A.EQ.'n' .OR. A.EQ.'F' .OR .A.EQ.'f') A='N'
      IF (A.EQ.D) THEN
        RETURN
      ELSEIF (A.EQ.D2) THEN
        L=L2
        RETURN
      ENDIF
      GOTO 1
      END SUBROUTINE LOGQYN

      SUBROUTINE STPACK(STRING,S,N)
C     -----------------------------
C
      CHARACTER STRING(*),S(*)
C
      DO 10 I=1,N
        STRING(I)=S(I)
        IF (S(I).EQ.'?') GOTO 20
  10  CONTINUE
  20  DO 30 J=I+1,N
  30    STRING(J)=' '
      END SUBROUTINE STPACK

      SUBROUTINE FORMTQ(STRING,NCHAR,NNN)
C     -----------------------------------
C
      CHARACTER*(*) STRING
C
      READ(*,200) STRING
 200  FORMAT(A)
      NNN=0
      DO 10 I=1,NCHAR
  10    IF (STRING(I:I).NE.' ') NNN=NNN+1
      END SUBROUTINE FORMTQ

      SUBROUTINE SBFINT(RGB,IC,IBMODE,IBUF,MAXBUF)
C     --------------------------------------------
C
      use grpckg1inc
      REAL             RGB(*)
C
      CHARACTER*16     TYPE,CHR
      LOGICAL          LPS,LCOLOR,LPSINT,PGNOTO
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
      REAL             RINIT(0:15),GINIT(0:15),BINIT(0:15)
      SAVE             LPSINT
      DATA             LPSINT /.FALSE./
      DATA     RINIT  /1.00,0.00,1.00,0.00,0.00,0.00,1.00,1.00,
     *                 1.00,0.50,0.00,0.00,0.50,1.00,0.33,0.67/
      DATA     GINIT  /1.00,0.00,0.00,1.00,0.00,1.00,0.00,1.00,
     *                 0.50,1.00,1.00,0.50,0.00,0.00,0.33,0.67/
      DATA     BINIT  /1.00,0.00,0.00,0.00,1.00,1.00,1.00,0.00,
     *                 0.00,0.00,0.50,1.00,1.00,0.50,0.33,0.67/
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      Initialises the software buffer for crystal-plotting. It should 
C    be called just once per plot (buffer), after PGWINDOW but before 
C    any crystal-related routines.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    RGB      R*4    I       3      The RGB values for the background.
C    IC       I*4    I       -      The index for the background colour.
C    IBMODE   I*4    I       -      Buffering mode for initialisation:
C                                     1 = Ordinary, default.
C                                     2 = Will want to save later.
C                                     3 = Initialise from saved buffers.
C    IBUF     I*4    I       -      Software buffer to be used (>=1).
C    MAXBUF   I*4    O       -      Maximum number of buffers available.
C
C Globals
C    SFTBUF
C    GRPCKG1.INC
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     PGNOTO     Logical function to test if a PGPLOT device is open.
C     GRBPIC     Sends a "begin picture" command to the device driver.
C     PGQINF     Inquires about general PGPLOT information.
C     GREXEC     Dispatches command to appropriate device driver.
C     COLINT     Sets up a colour table.
C     SBRFIL     Fills a real aray with a constant.
C     SBRCOP     Copies the contents of one real array to another.
C     SBFIN0     Inquires about viewport and window dimensions.
C
C History
C   D. S. Sivia       4 Apr 1995  Initial release.
C   D. S. Sivia      14 Sep 1995  Set up default colour indicies for PS.
C   D. S. Sivia      20 Oct 1995  Ignore NBUNCH and fix to one!
C   D. S. Sivia      15 Nov 1995  Allow initialisation to/from saved 
C                                 buffers.
C   D. S. Sivia       2 Aug 1996  Replaced pgplot.inc with SBFIN0, and
C                                 made appropriate additions to SFTBUF.
C   D. S. Sivia      16 Jul 1999  Added a couple of PGPLOT calls to 
C                                 force proper initialisation.
C-----------------------------------------------------------------------
C
C A PGPLOT initialisation precaution.
C
      IF (PGNOTO('SBFINT')) RETURN
      IF (.NOT.GRPLTD(GRCIDE)) CALL GRBPIC
C
C Begin SBFINT proper.
C
      CALL SBFIN0(XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *            YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC)
      LPS=.TRUE.
      NDOTS=100
      CALL PGQINF('TYPE',TYPE,LCHR)
      IF (TYPE.EQ.'PS' .OR. TYPE.EQ.'VPS') THEN
        LCOLOR=.FALSE.
        NXP=NINT(FLOAT(NDOTS)*XLEN/XPERIN)
        NYP=NINT(FLOAT(NDOTS)*YLEN/YPERIN)
      ELSEIF (TYPE.EQ.'CPS' .OR. TYPE.EQ.'VCPS') THEN
        LCOLOR=.TRUE.
        NXP=NINT(FLOAT(NDOTS)*XLEN/XPERIN)
        NYP=NINT(FLOAT(NDOTS)*YLEN/YPERIN)
      ELSE
        LPS=.FALSE.
        NBUF=0
        LCHR=LEN(CHR)
        CALL GREXEC(GRGTYP,4,RBUF,NBUF,CHR,LCHR)
        IF (CHR(7:7).EQ.'P') THEN
          NXP=1+NINT(XLEN)
          NYP=1+NINT(YLEN)
        ELSE
          STOP' Sorry, SFBINT does not support this device !'
        ENDIF
      ENDIF
      IBFMOD=IBMODE
      NTOT=NXP*NYP
      MAXBUF=INT(2000000/NTOT)-1
      IF (IBFMOD.EQ.2 .OR. IBFMOD.EQ.3) MAXBUF=MAXBUF-2 
      KSTART=NTOT*MAX(MIN(IBUF,MAXBUF),1)
      IF ((KSTART+NTOT).LE.2000000 .AND. MAXBUF.GE.1) THEN
        IF (IBFMOD.EQ.3) THEN
          IZSAVE=NTOT*(1+MAXBUF)+1
          ICSAVE=IZSAVE+NTOT
          CALL SBRCOP(SBBUFF(IZSAVE),SBBUFF(1),NTOT)
          CALL SBRCOP(SBBUFF(ICSAVE),SBBUFF(KSTART+1),NTOT)
        ELSE
          CALL SBRFIL(SBBUFF(1),-1.0E20,NTOT)
          CALL SBRFIL(SBBUFF(KSTART+1),FLOAT(IC),NTOT)
        ENDIF
      ELSE
        STOP' Sorry, the software buffer is too small !'
      ENDIF
      CALL COLINT(RGB,IC,IC,0.5,0.0,1.0)
      IF (LPS .AND. .NOT. LPSINT) THEN
        DO 10 I=0,15
          IF (LCOLOR) THEN
            IR(I)=NINT(255.0*RINIT(I))
            IG(I)=NINT(255.0*GINIT(I))
            IB(I)=NINT(255.0*BINIT(I))
          ELSE
            IR(I)=NINT(85.0*(RINIT(I)+GINIT(I)+BINIT(I)))
          ENDIF
  10    CONTINUE
        LPSINT=.TRUE.
      ENDIF
      END SUBROUTINE SBFINT

      SUBROUTINE SBFIN0(XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                  YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC)
C     ---------------------------------------------------------
C
      DATA BIG,SMALL /1.0E+20,1.0E-20/
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      Obtain some viewport and window information about the current 
C    PGPLOT device, without directly accessing the common blocks in
C    pgplot.inc.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    XPERIN   R*4    O       -      Plot X scale in dots/inch.
C    YPERIN   R*4    O       -      Plot Y scale in dots/inch.
C    XOFF     R*4    O       -      Absolute coord of blc of viewport.
C    YOFF     R*4    O       -      Absolute coord of blc of viewport.
C    XLEN     R*4    O       -      Width of viewport in absolute coord.
C    YLEN     R*4    O       -      Height of viewport in absolute coord.
C    XORG     R*4    O       -      Absolute coord of world X=0.
C    YORG     R*4    O       -      Absolute coord of world Y=0.
C    XSCALE   R*4    O       -      Absolute units per world coord in X.
C    YSCALE   R*4    O       -      Absolute units per world coord in Y.
C    XBLC     R*4    O       -      World X coord at blc of window.
C    XTRC     R*4    O       -      World X coord at trc of window.
C    YBLC     R*4    O       -      World Y coord at blc of window.
C    YTRC     R*4    O       -      World Y coord at trc of window.
C
C Globals
C     None.
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     PGQVP      Inquires about viewport dimensions.
C     PGQWIN     Inquires about world coords of window.
C
C History
C   D. S. Sivia       2 Aug 1996  Initial release.
C-----------------------------------------------------------------------
C
      CALL PGQWIN(XBLC,XTRC,YBLC,YTRC)
      CALL PGQVP(1,XI1,XI2,YI1,YI2)
      CALL PGQVP(3,XOFF,XP2,YOFF,YP2)
      XLEN=ABS(XP2-XOFF)
      YLEN=ABS(YP2-YOFF)
      XPERIN=XLEN/(ABS(XI2-XI1)+SMALL)
      YPERIN=YLEN/(ABS(YI2-YI1)+SMALL)
      XWDIF=XTRC-XBLC
      YWDIF=YTRC-YBLC
      AXWDIF=BIG
      AYWDIF=BIG
      IF (ABS(XWDIF).GT.SMALL) AXWDIF=1.0/XWDIF
      IF (ABS(YWDIF).GT.SMALL) AYWDIF=1.0/YWDIF
      XSCALE=XLEN*AXWDIF
      YSCALE=YLEN*AYWDIF
      XORG=(XOFF*XTRC-XP2*XBLC)*AXWDIF
      YORG=(YOFF*YTRC-YP2*YBLC)*AYWDIF
      END SUBROUTINE SBFIN0

      SUBROUTINE SBFSAV(IBUF)
C     -----------------------
C
      LOGICAL          LPS,LCOLOR
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC

C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      Save a rendered picture-buffer, and its Z-buffer, for subsequent 
C    use in re-initialisation with SBFINT.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    IBUF     I*4    I       -      Software buffer to be saved (>=1).
C
C Globals
C    SFTBUF
C    GRPCKG1.INC
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     SBRCOP     Copies the contents of one real array to another.
C
C History
C   D. S. Sivia      15 Nov 1995  Initial release.
C-----------------------------------------------------------------------
C
      NTOT=NXP*NYP
      MAXBUF=INT(2000000/NTOT)-3
      IBUF1=MAX(IBUF,1)
      IF (IBUF1.GT.MAXBUF) RETURN
      KSTART=NTOT*IBUF1
      IZSAVE=NTOT*(1+MAXBUF)+1
      ICSAVE=IZSAVE+NTOT
      CALL SBRCOP(SBBUFF(1),SBBUFF(IZSAVE),NTOT)
      CALL SBRCOP(SBBUFF(KSTART+1),SBBUFF(ICSAVE),NTOT)
      END SUBROUTINE SBFSAV

      SUBROUTINE COLINT(RGB,IC1,IC2,DIFUSE,SHINE,POLISH)
C     --------------------------------------------------
C
      REAL             RGB(*)
C
      LOGICAL          LPS,LCOLOR
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC

C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      Initialises a colour table for a geometrical object. In general,
C    it is recommended that SHINE = 0.0 if DIFUSE > 0.0 and vice versa.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    RGB      R*4    I       3      Red, green and blue intenisty for 
C                                   fully-lit non-shiny object (0-1).
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for shading.
C    DIFUSE   R*4    I       -      Diffusiveness of object (0-1).
C    SHINE    R*4    I       -      Whiteness of bright spot (0-1).
C    POLISH   R*4    I       -      Controls size of bright spot.
C
C Globals
C    SFTBUF
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     PGQCOL     Inquires about the colour capability.
C     PGSCR      Assigns an RGB value to a colour index.
C
C History
C   D. S. Sivia       4 Apr 1995  Initial release.
C-----------------------------------------------------------------------
C
      IF (RGB(1).LT.0.0 .OR. RGB(1).GT.1.0) RETURN
      IF (RGB(2).LT.0.0 .OR. RGB(2).GT.1.0) RETURN
      IF (RGB(3).LT.0.0 .OR. RGB(3).GT.1.0) RETURN
      IF (DIFUSE.LT.0.0 .OR. DIFUSE.GT.1.0) RETURN
      IF (SHINE.LT.0.0 .OR. SHINE.GT.1.0) RETURN
      IF (IC2.LT.IC1) RETURN
      IF (LPS) THEN
        ICMIN=0
        ICMAX=255
      ELSE
        CALL PGQCOL(ICMIN,ICMAX)
      ENDIF
      IF (IC1.LT.ICMIN .OR. IC2.GT.ICMAX) THEN
        WRITE(*,*)' Invalid colour-indicies for the chosen device !'
        RETURN
      ENDIF
      POLSH2=MAX(POLISH/2.0,0.5)
      NC=IC2-IC1
      IF (NC.EQ.0) THEN
        RED=RGB(1)
        GRN=RGB(2)
        BLU=RGB(3)
      ELSE
        GREY=0.0
        DGREY=1.0/FLOAT(NC)
        DR=DIFUSE*RGB(1)/FLOAT(NC)
        DG=DIFUSE*RGB(2)/FLOAT(NC)
        DB=DIFUSE*RGB(3)/FLOAT(NC)
        RED=MAX(RGB(1)*(1.0-DIFUSE),0.0)
        GRN=MAX(RGB(2)*(1.0-DIFUSE),0.0)
        BLU=MAX(RGB(3)*(1.0-DIFUSE),0.0)
        R=RED
        G=GRN
        B=BLU
      ENDIF
      DO 10 IC=IC1,IC2
        IF (.NOT. LPS) THEN
          CALL PGSCR(IC,RED,GRN,BLU)
        ELSE
          IF (LCOLOR) THEN
            IR(IC)=NINT(255.0*RED)
            IG(IC)=NINT(255.0*GRN)
            IB(IC)=NINT(255.0*BLU)
          ELSE
            IR(IC)=NINT(85.0*(RED+GRN+BLU))
          ENDIF
        ENDIF
        R=R+DR
        G=G+DG
        B=B+DB
        GREY=GREY+DGREY
        POLSHN=SHINE*(GREY**POLSH2)
        RED=MIN(R+POLSHN,1.0)
        GRN=MIN(G+POLSHN,1.0)
        BLU=MIN(B+POLSHN,1.0)
  10  CONTINUE
      END SUBROUTINE COLINT

      SUBROUTINE COLTAB(RGB,NCOL,ALFA,IC1,IC2)
C     ----------------------------------------
C
      REAL             RGB(3,*)
C
      LOGICAL          LPS,LCOLOR
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC

C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      Initialises a colour table for a "grey-scale" map.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    RGB      R*4    I   3 X NCOL   Red, green and blue intenisty for 
C                                   the colour table.
C    NCOL     I*4    I       -      No. of colours in the input table.
C    ALFA     R*4    I       -      Contrast-factor (linear=1).
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for the output.
C
C Globals
C    SFTBUF
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     PGQCOL     Inquires about the colour capability.
C     PGSCR      Assigns an RGB value to a colour index.
C
C History
C   D. S. Sivia      30 Apr 1995  Initial release.
C-----------------------------------------------------------------------
C
      IF (IC2.LE.IC1) RETURN
      IF (LPS) THEN
        ICMIN=0
        ICMAX=255
      ELSE
        CALL PGQCOL(ICMIN,ICMAX)
      ENDIF
      IF (IC1.LT.ICMIN .OR. IC2.GT.ICMAX) THEN
        WRITE(*,*)' Invalid colour-indicies for the chosen device !'
        RETURN
      ENDIF
      NC=IC2-IC1
      COL=0.0
      DCOL=1.0/FLOAT(NC)
      DO 10 I=0,NC
        COLALF=FLOAT(NCOL-1)*MIN(COL**ALFA,0.99999)
        ICOL=INT(COLALF)
        DICOL=COLALF-FLOAT(ICOL)
        RL=RGB(1,ICOL+1)+DICOL*(RGB(1,ICOL+2)-RGB(1,ICOL+1))
        GL=RGB(2,ICOL+1)+DICOL*(RGB(2,ICOL+2)-RGB(2,ICOL+1))
        BL=RGB(3,ICOL+1)+DICOL*(RGB(3,ICOL+2)-RGB(3,ICOL+1))
        R=MIN(MAX(RL,0.0),1.0)
        G=MIN(MAX(GL,0.0),1.0)
        B=MIN(MAX(BL,0.0),1.0)
        IF (LPS) THEN
          IF (LCOLOR) THEN
            IR(IC1+I)=NINT(R*255.0)
            IG(IC1+I)=NINT(G*255.0)
            IB(IC1+I)=NINT(B*255.0)
          ELSE
            IR(IC1+I)=NINT((R+G+B)*85.0)
          ENDIF
        ELSE
          CALL PGSCR(IC1+I,R,G,B)
        ENDIF
        COL=COL+DCOL
  10  CONTINUE
      END SUBROUTINE COLTAB

      SUBROUTINE COLSRF(RGB,NCOL,ALFA,IC1,IC2,NCBAND,DIFUSE,SHINE,
     *                  POLISH)
C     ------------------------------------------------------------
C
      REAL             RGB(3,*)
C
      REAL             RGBOUT(3)
      LOGICAL          LPS,LCOLOR
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC

C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      Initialises a colour table for a 3-D surface rendering of a 2-D 
C   array of "data".
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    RGB      R*4    I   3 X NCOL   Red, green and blue intenisty for 
C                                   the colour table.
C    NCOL     I*4    I       -      No. of colours in the input table.
C    ALFA     R*4    I       -      Contrast-factor (linear=1).
C    IC1,IC2  I*4    I       -      Lowest and highest colour-index to
C                                   be used for the rendering.
C    NCBAND   I*4    I       -      Number of colour-bands for the
C                                   height, so that the number of shades
C                                   per band = (IC2-IC1+1)/NCBAND.
C    DIFUSE   R*4    I       -      Diffusiveness of object (0-1).
C    SHINE    R*4    I       -      Whiteness of bright spot (0-1).
C    POLISH   R*4    I       -      Controls size of bright spot.
C
C Globals
C    SFTBUF
C
C External Calls
!




C   SUBROUTINE   DESCRIPTION
C     PGQCOL     Inquires about the colour capability.
C
C History
C   D. S. Sivia      30 Oct 1995  Initial release.
C-----------------------------------------------------------------------
C
      IF (IC2.LE.IC1) RETURN
      IF (LPS) THEN
        ICMIN=0
        ICMAX=255
      ELSE
        CALL PGQCOL(ICMIN,ICMAX)
      ENDIF
      IF (IC1.LT.ICMIN .OR. IC2.GT.ICMAX) THEN
        WRITE(*,*)' Invalid colour-indicies for the chosen device !'
        RETURN
      ENDIF
      NSHADS=MAX((IC2-IC1+1)/MAX(NCBAND,1),1)
      COL=0.0
      DCOL=1.0/FLOAT(MAX(NCBAND-1,1))
      IC=IC1
      DO 10 I=1,NCBAND
        COLALF=FLOAT(NCOL-1)*MIN(COL**ALFA,0.99999)
        ICOL=INT(COLALF)
        DICOL=COLALF-FLOAT(ICOL)
        RL=RGB(1,ICOL+1)+DICOL*(RGB(1,ICOL+2)-RGB(1,ICOL+1))
        GL=RGB(2,ICOL+1)+DICOL*(RGB(2,ICOL+2)-RGB(2,ICOL+1))
        BL=RGB(3,ICOL+1)+DICOL*(RGB(3,ICOL+2)-RGB(3,ICOL+1))
        RGBOUT(1)=MIN(MAX(RL,0.0),1.0)
        RGBOUT(2)=MIN(MAX(GL,0.0),1.0)
        RGBOUT(3)=MIN(MAX(BL,0.0),1.0)
        CALL COLINT(RGBOUT,IC,IC+NSHADS-1,DIFUSE,SHINE,POLISH)
        IC=IC+NSHADS
        COL=COL+DCOL
  10  CONTINUE
      END SUBROUTINE COLSRF

      SUBROUTINE SBFCLS(IBUF)
C     -----------------------
C
      use grpckg1inc
      REAL            BUFFER(2050),RNDBUF(0:3050)
      INTEGER         VALUE(33)
      LOGICAL         LPS,LCOLOR,LSTART
      CHARACTER       INLINE*80,CHR*16
      SAVE            LSTART,RNDBUF
      COMMON /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
      DATA            LODD,RNDSCL,RNDOFF,NRND /37614625,0.96,-0.5,3000/
      DATA            LSTART /.FALSE./
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      Closes the software buffer for crystal-plotting, by outputing it
C    to the screen or writing out a postscript file (as appropriate).
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    IBUF     I*4    I       -      Software buffer to be output (>=1).
C
C Globals
C    SFTBUF
C    GRPCKG1.INC
C
C External Calls
!




C   SUBROUTINE   DESCRIPTION
C     GREXEC     Dispatches command to appropriate device driver.
C     PGBBUF     Recommended initial call (to start a PGPLOT buffer).
C     PGEBUF     Recommended final call (to end a PGPLOT buffer).
C
C History
C   D. S. Sivia       4 Apr 1995  Initial release.
C   D. S. Sivia      20 Oct 1995  Hardwire assumption that NGANG=1.
C   D. S. Sivia      21 Oct 1997  Made slightly friendlier for NT.
C   D. S. Sivia      30 Jan 1998  Explicitly SAVE array RNDBUF.
C-----------------------------------------------------------------------
C
      NTOT=NXP*NYP
      MAXBUF=INT(2000000/NTOT)-1
      IF (IBFMOD.EQ.2 .OR. IBFMOD.EQ.3) MAXBUF=MAXBUF-2
      IF (IBUF.GT.MAXBUF) RETURN
      KEND=NTOT*MAX(IBUF,1)
      IF (.NOT. LSTART) THEN
        DO 10 I=0,NRND-1
#ifdef CRAY
          CALL RANDOM_NUMBER(HARVEST=RAND)
  10      RNDBUF(I)=RNDSCL*(RAND+RNDOFF)
#elif RISC
  10      RNDBUF(I)=RNDSCL*(erand48(LODD)+RNDOFF)
#else
  10      RNDBUF(I)=RNDSCL*(RAN(LODD)+RNDOFF)
#endif
        LSTART=.TRUE.
      ENDIF
      IF (LPS) THEN
        AT=FLOAT(NXP)/XLEN
        BT=0.0
        CT=0.0
        DT=FLOAT(NYP)/YLEN
        TX=-AT*XOFF
        TY=-DT*YOFF
        WRITE (INLINE,100) NINT(XOFF),NINT(YOFF),NINT(XLEN),NINT(YLEN),
     *                    -NINT(XLEN)
 100    FORMAT(I6,I6,' moveto ',I6, ' 0 rlineto  0 ',I6,' rlineto ',
     *         I6,' 0 rlineto')
        CALL GRTERM
        CALL GRESC(' newpath ')
        CALL GRESC(INLINE)
        CALL GRESC(' closepath ')
        WRITE (INLINE, '(A,I5,A)') '/picstr ',NXP,' string def'
        CALL GRESC(INLINE)
        WRITE (INLINE,110) NXP,NYP,AT,BT,CT,DT,TX,TY
 110    FORMAT(2I4,' 8 [',6(1PE10.3,' '),']')
        CALL GRESC(INLINE)
        CALL GRESC('{ currentfile picstr readhexstring pop}')
        IF (LCOLOR) THEN
          CALL GRESC('  false 3 colorimage')
        ELSE
          CALL GRESC('  image')
        ENDIF
        L=0
        DO 20 K=KEND+1,KEND+NTOT
          L=L+1
          IC=NINT(SBBUFF(K)+RNDBUF(MOD(K,NRND)))
          IF (LCOLOR) THEN
            VALUE(L)=IR(IC)
            VALUE(L+1)=IG(IC)
            VALUE(L+2)=IB(IC)
            L=L+2
          ELSE
            VALUE(L)=IR(IC)
          ENDIF
          IF (L.EQ.33) THEN
            WRITE(INLINE,120) (VALUE(I),I=1,33)
 120        FORMAT(33Z2.2)
            CALL GRESC(INLINE(1:66))
            L=0
          ENDIF
  20    CONTINUE
        IF (L.NE.0) THEN
          WRITE(INLINE,120) (VALUE(I),I=1,L)
          CALL GRESC(INLINE(1:2*L))
        ENDIF
        CALL GRESC(' newpath ')
        CALL GRTERM
      ELSE
        CALL PGBBUF
        NXP2=NXP+2
        K=KEND+1
        RND900=900.0
        BUFFER(1)=FLOAT(NINT(XOFF))
        BUFFER(2)=FLOAT(NINT(YOFF))
        DO 40 J=1,NYP
          L=1+INT(RND900*(RNDBUF(J)-RNDOFF))
          CALL SBCLS0(BUFFER(3),SBBUFF(K),RNDBUF(L),NXP)
          CALL GREXEC(GRGTYP,26,BUFFER,NXP2,CHR,LCHR)
          K=K+NXP
          BUFFER(2)=BUFFER(2)+1.0
  40    CONTINUE
        CALL PGEBUF
      ENDIF
      END SUBROUTINE SBFCLS

      SUBROUTINE SBCLS0(A,B,C,N)
C     --------------------------
C
      REAL A(*),B(*),C(*)
C
      DO 10 I=1,N
  10    A(I)=FLOAT(NINT(B(I)+C(I)))
      END SUBROUTINE SBCLS0

      SUBROUTINE SBBALL(EYE,CENTRE,RADIUS,IC1,IC2,LIGHT,LSHINE,X0,Y0,R0)
C     ------------------------------------------------------------------
C
      REAL            EYE(*),CENTRE(*),LIGHT(*)
      LOGICAL         LSHINE

      REAL            SURF(3)
      REAL*8          ALFA,BETA,GAMA,XMU,A,B,C,DET,Q,DX0H,DY0H
      REAL*8          DZE,DZE2,DGAMZE,DBL1,DBL2,DSMALL
      REAL*8          XL0,XL1,HYP,SINPHI,COSPHI,R1,R2
      LOGICAL         LPS,LCOLOR
      COMMON /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      This subroutine plots a shiny or matt coloured ball. All 
C    (x,y,z) values are taken to be given in world coordinates. The 
C    z-component of the eye-poisition should be positive and that of
C    the ball-centre should be negative (< -radius); the viewing-screen
C    is fixed at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    CENTRE   R*4    I       3      (x,y,z) coordinate of ball-centre.
C    RADIUS   R*4    I       -      Radius of ball.
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for shading.
C    LIGHT    R*4    I       3      (x,y,z) direction of flood-light.
C    LSHINE   L*1    I       -      Shiny ball if .TRUE., else diffuse.
C    X0,Y0    R*4    O       -      Centre of projected ball.
C    R0       R*4    O       -      Average radius of projected ball.
C
C Globals 
C    SFTBUF
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     SBGLOS     Works out colour-shade for surface of ball.
C
C History
C   D. S. Sivia       7 Apr 1995  Initial release.
C-----------------------------------------------------------------------
C
C Some initial checks.
C
      SMALL=1.0E-20
      DSMALL=DBLE(SMALL)
      IF (EYE(3).LE.0.0) RETURN
      IF (RADIUS.LE.0.0) RETURN
      IF (CENTRE(3).GT.-RADIUS) RETURN
C
C Calculate parameters of projected ellipse.
C
      DZE=DBLE(EYE(3))
      DZE2=DZE**2
      ALFA=DBLE(EYE(1)-CENTRE(1))
      BETA=DBLE(EYE(2)-CENTRE(2))
      GAMA=DBLE(EYE(3)-CENTRE(3))
      XMU=DBLE(RADIUS**2)-(ALFA**2+BETA**2+GAMA**2)
      A=XMU*(XMU+ALFA**2)
      B=XMU*ALFA*BETA
      C=XMU*(XMU+BETA**2)
      DET=ABS(A*C-B**2)+DSMALL
      DX0H=GAMA*XMU*DZE*(ALFA*C-BETA*B)/DET
      DY0H=GAMA*XMU*DZE*(BETA*A-ALFA*B)/DET
      Q=A*DX0H**2+2.0*B*DX0H*DY0H+C*DY0H**2-XMU*(XMU+GAMA**2)*DZE2
      X0H=SNGL(DX0H)
      Y0H=SNGL(DY0H)
      DX=(XTRC-XBLC)/FLOAT(NXP-1)
      DY=(YTRC-YBLC)/FLOAT(NYP-1)
      XDIF=SNGL(SQRT(ABS(C*Q/DET)+DSMALL))
      XMIN=X0H-XDIF+EYE(1)
      XMAX=X0H+XDIF+EYE(1)
      IXMIN=INT((XMIN-XBLC)/DX)+2
      IXMAX=INT((XMAX-XBLC)/DX)+1
      IF (IXMIN.GT.NXP .OR. IXMAX.LT.1) RETURN
      YDIF=(SQRT(ABS(A*Q/DET)+DSMALL))
      YMIN=Y0H-YDIF+EYE(2)
      YMAX=Y0H+YDIF+EYE(2)
      JYMIN=INT((YMIN-YBLC)/DY)+2
      JYMAX=INT((YMAX-YBLC)/DY)+1
      IF (JYMIN.GT.NYP .OR. JYMAX.LT.1) RETURN
      IF (JYMIN.LT.1) JYMIN=1
      IF (JYMAX.GT.NYP) JYMAX=NYP
      ZMAX=CENTRE(3)+RADIUS
      X0=X0H+EYE(1)
      Y0=Y0H+EYE(2)
      COREL=SNGL(SQRT(ABS((B*B)/(A*C))+DSMALL))
      IF (COREL.GT.0.0001) THEN
        XL0=(A+C)/2.0D0
        XL1=XL0-SQRT(ABS(XL0*XL0-DET)+DSMALL)
        HYP=SQRT((XL1-A)**2+B**2+DSMALL)
        SINPHI=(XL1-A)/HYP
        COSPHI=B/HYP
      ELSE
        SINPHI=0.0D0
        COSPHI=1.0D0
      ENDIF
      R1=SQRT(Q/(A*COSPHI*COSPHI+SINPHI*(C*SINPHI+2.0*B*COSPHI)))
      R2=SQRT(Q/(A*SINPHI*SINPHI+COSPHI*(C*COSPHI-2.0*B*SINPHI)))
      R0=SNGL((R1+R2)/2.0D0)
C
C Fill the inside of the projected ellipse with the right colours.
C
      NC=IC2-IC1
      COL0=FLOAT(IC1)
      COLSCL=FLOAT(NC)
      XL2=LIGHT(1)**2+LIGHT(2)**2+LIGHT(3)**2
      XN2=RADIUS**2
      XNL2=1.0/SQRT(XN2*XL2+SMALL)
      XN3=1.0/(XN2+SMALL)
      YH=YBLC+DY*FLOAT(JYMIN-1)-EYE(2)
      DGAMZE=GAMA*DZE
      BA=SNGL(B/A)
      DO 20 JY=JYMIN,JYMAX
        YH2=YH**2
        BETAYH=BETA*YH
        YDIF=YH-Y0H
        XDIF=SNGL(SQRT(ABS(A*Q-DET*DBLE(YDIF**2))+DSMALL)/A)
        XMIN=X0H-BA*YDIF-XDIF+EYE(1)
        XMAX=X0H-BA*YDIF+XDIF+EYE(1)
        IXMIN=INT((XMIN-XBLC)/DX)+2
        IXMAX=INT((XMAX-XBLC)/DX)+1
        IF (IXMIN.LE.NXP .AND. IXMAX.GE.1) THEN
          IF (IXMIN.LT.1) IXMIN=1
          IF (IXMAX.GT.NXP) IXMAX=NXP
          XH=XBLC+DX*FLOAT(IXMIN-1)-EYE(1)
          K=(JY-1)*NXP+IXMIN
          DO 10 IX=IXMIN,IXMAX
            IF (ZMAX.GT.SBBUFF(K)) THEN
              XH2=XH**2
              ALFAXH=ALFA*XH
              DBL1=DBLE(ALFAXH+BETAYH)-DGAMZE
              DBL2=DBLE(XH2+YH2)+DZE2
              XLM=SNGL((-DBL1-SQRT(ABS(DBL1**2+XMU*DBL2)+DSMALL))/DBL2)
              SURF(3)=EYE(3)*(1.0-XLM)
              IF (SURF(3).GT.SBBUFF(K)) THEN
                SBBUFF(K)=SURF(3)
                IF (NC.EQ.0) THEN
                  SBBUFF(KSTART+K)=COL0
                ELSE
                  SURF(2)=EYE(2)+YH*XLM
                  SURF(1)=EYE(1)+XH*XLM
                  CALL SBGLOS(EYE,CENTRE,LIGHT,SURF,XNL2,XN3,SMALL,
     *                        LSHINE,COLOUR)
                  SBBUFF(KSTART+K)=COL0+COLOUR*COLSCL
                ENDIF
              ENDIF
            ENDIF
            K=K+1
            XH=XH+DX
  10      CONTINUE
        ENDIF
        YH=YH+DY
  20  CONTINUE
      END SUBROUTINE SBBALL

      SUBROUTINE SBGLOS(EYE,CENTRE,LIGHT,SURF,XNL2,XN3,SMALL,LSHINE,
     *                  COLOUR)
C     --------------------------------------------------------------
C
!




C Support subroutine for SBBALL, to work out colour-shade.
C
      REAL    EYE(*),CENTRE(*),LIGHT(*),SURF(*)
      LOGICAL LSHINE
      REAL    NORMAL(3),REFLEC(3),VIEW(3)
C
      COLOUR=0.0
      XNL=0.0
      DO 10 I=1,3
        NORMAL(I)=SURF(I)-CENTRE(I)
        XNL=XNL+NORMAL(I)*LIGHT(I)
  10  CONTINUE
      IF (XNL.GE.0.0) RETURN
      IF (LSHINE) THEN
        RFNORM=(XNL+XNL)*XN3
        XRV=0.0
        DO 20 I=1,3
          VIEW(I)=EYE(I)-SURF(I)
          REFLEC(I)=LIGHT(I)-RFNORM*NORMAL(I)
          XRV=XRV+REFLEC(I)*VIEW(I)
  20    CONTINUE
        IF (XRV.LT.0.0) RETURN
        REF2=0.0
        VIEW2=0.0
        DO 30 I=1,3
          REF2=REF2+REFLEC(I)**2
          VIEW2=VIEW2+VIEW(I)**2
  30    CONTINUE
        COLOUR=MIN(XRV**2/(ABS(REF2*VIEW2)+SMALL),1.0)
      ELSE
        COLOUR=MIN(-XNL*XNL2,1.0)
      ENDIF
      END SUBROUTINE SBGLOS

      SUBROUTINE SBLINE(EYE,END1,END2,ICOL,LDASH)
C     -------------------------------------------
C
      REAL             EYE(*),END1(*),END2(*)
      LOGICAL          LDASH
C
      LOGICAL          LPS,LCOLOR
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
      DATA             NDASH1,NDASH2 /7,3/
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
!




C      This subroutine draws a straight line between two points. All 
C    (x,y,z) values are taken to be given in world coordinates. The 
C    z-component of the eye-poisition should be positive, while that 
C    of both the ends should be negative; the viewing-screen is fixed
C    at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    END1     R*4    I       3      (x,y,z) coordinate of end-1.
C    END2     R*4    I       3      (x,y,z) coordinate of end-2.
C    ICOL     I*4    I       -      Colour-index for line.
C    LDASH    L*1    I       -      Dashed line if .TRUE. (else cont.).
C
C Globals 
C    SFTBUF
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     SBLIN1     Calculates the projection of (x,y,z) on viewing screen.
C
C History
C   D. S. Sivia       4 Apr 1995  Initial release.
C   D. S. Sivia      25 Oct 1997  Prevent occasional Z-coordinate bug.
C-----------------------------------------------------------------------
C
C Some initial checks and clipping.
C
      SMALL=1.0E-10
      IF (EYE(3).LE.0.0) RETURN
      IF (END1(3).GE.0.0 .OR. END2(3).GE.0.0) RETURN
      CALL SBLIN1(EYE,END1(1),END1(2),END1(3),XW1,YW1)
      CALL SBLIN1(EYE,END2(1),END2(2),END2(3),XW2,YW2)
      XDIF=XW2-XW1
      YDIF=YW2-YW1
      IF ((ABS(XDIF)+ABS(YDIF)).LT.SMALL) RETURN
      IF (ABS(XDIF).LT.SMALL) XDIF=SMALL
      IF (ABS(YDIF).LT.SMALL) YDIF=SMALL
      IF (XW1.LE.XBLC) THEN
        IF (XW2.LE.XBLC) RETURN
        XLAM=(XBLC-XW1)/XDIF
        XW1=XW1+XLAM*XDIF
        YW1=YW1+XLAM*YDIF
      ELSEIF (XW1.GE.XTRC) THEN
        IF (XW2.GE.XTRC) RETURN
        XLAM=(XTRC-XW1)/XDIF
        XW1=XW1+XLAM*XDIF
        YW1=YW1+XLAM*YDIF
      ENDIF
      IF (YW1.LE.YBLC) THEN
        IF (YW2.LE.YBLC) RETURN
        YLAM=(YBLC-YW1)/YDIF
        XW1=XW1+YLAM*XDIF
        YW1=YW1+YLAM*YDIF
      ELSEIF (YW1.GE.YTRC) THEN
        IF (YW2.GE.YTRC) RETURN
        YLAM=(YTRC-YW1)/YDIF
        XW1=XW1+YLAM*XDIF
        YW1=YW1+YLAM*YDIF
      ENDIF
      IF (XW2.LE.XBLC) THEN
        XLAM=(XBLC-XW1)/XDIF
        XW2=XW1+XLAM*XDIF
        YW2=YW1+XLAM*YDIF
      ELSEIF (XW2.GE.XTRC) THEN
        XLAM=(XTRC-XW1)/XDIF
        XW2=XW1+XLAM*XDIF
        YW2=YW1+XLAM*YDIF
      ENDIF
      IF (YW2.LE.YBLC) THEN
        YLAM=(YBLC-YW1)/YDIF
        XW2=XW1+YLAM*XDIF
        YW2=YW1+YLAM*YDIF
      ELSEIF (YW2.GE.YTRC) THEN
        YLAM=(YTRC-YW1)/YDIF
        XW2=XW1+YLAM*XDIF
        YW2=YW1+YLAM*YDIF
      ENDIF
C
      COLOUR=FLOAT(ICOL)
      DX=FLOAT(NXP-1)/(XTRC-XBLC)
      X1=1.0+(XW1-XBLC)*DX
      X2=1.0+(XW2-XBLC)*DX
      XDIF=X2-X1
      DY=FLOAT(NYP-1)/(YTRC-YBLC)
      Y1=1.0+(YW1-YBLC)*DY
      Y2=1.0+(YW2-YBLC)*DY
      YDIF=Y2-Y1
      ZW1=END1(3)
      IF (ABS(XDIF).GE.ABS(YDIF)) THEN
        IF (ABS(XDIF).LT.SMALL) RETURN
        IF (X1.LE.X2) THEN
          A=EYE(3)-END1(3)
          B=EYE(3)*(EYE(1)-END1(1))
          C=END2(3)-END1(3)
          D=EYE(3)*(END2(1)-END1(1))
        ELSE
          X3=X1
          Y3=Y1
          X1=X2
          Y1=Y2
          X2=X3
          Y2=Y3
          ZW1=END2(3)
          A=EYE(3)-END2(3)
          B=EYE(3)*(EYE(1)-END2(1))
          C=END1(3)-END2(3)
          D=EYE(3)*(END1(1)-END2(1))
        ENDIF
        IF (ABS(C).LT.SMALL) C=SMALL
        D=D/C
        IF (ABS(D).LT.SMALL) D=SMALL
        DYJ=YDIF/XDIF
        IX1=NINT(X1)
        IX2=NINT(X2)
        YJ=Y1+DYJ*(FLOAT(IX1)-X1)
        DXX=1.0/DX
        IF (LDASH) THEN
          DYJJ=(NDASH1-NDASH2-1)*DYJ
          DO 20 II=IX1,IX2,NDASH1
            III=MIN(II+NDASH2,IX2)
            XX=XBLC-EYE(1)+DXX*FLOAT(II-1)
            DO 10 I=II,III
              K=NXP*(NINT(YJ)-1)+I
              Z=ZW1+(A*XX+B)/(XX+D)
              IF (Z.GT.SBBUFF(K)) THEN
                SBBUFF(K)=Z
                SBBUFF(KSTART+K)=COLOUR
              ENDIF
              YJ=YJ+DYJ
              XX=XX+DXX
  10        CONTINUE
            YJ=YJ+DYJJ
  20      CONTINUE
        ELSE
          XX=XBLC-EYE(1)+DXX*FLOAT(IX1-1)
          DO 30 I=IX1,IX2
            K=NXP*(NINT(YJ)-1)+I
            Z=ZW1+(A*XX+B)/(XX+D)
            IF (Z.GT.SBBUFF(K)) THEN
              SBBUFF(K)=Z
              SBBUFF(KSTART+K)=COLOUR
            ENDIF
            YJ=YJ+DYJ
            XX=XX+DXX
  30      CONTINUE
        ENDIF
      ELSE
        IF (ABS(YDIF).LT.SMALL) RETURN
        IF (Y1.LE.Y2) THEN
          A=EYE(3)-END1(3)
          B=EYE(3)*(EYE(2)-END1(2))
          C=END2(3)-END1(3)
          D=EYE(3)*(END2(2)-END1(2))
        ELSE
          X3=X1
          Y3=Y1
          X1=X2
          Y1=Y2
          X2=X3
          Y2=Y3
          ZW1=END2(3)
          A=EYE(3)-END2(3)
          B=EYE(3)*(EYE(2)-END2(2))
          C=END1(3)-END2(3)
          D=EYE(3)*(END1(2)-END2(2))
        ENDIF
        IF (ABS(C).LT.SMALL) C=SMALL
        D=D/C
        IF (ABS(D).LT.SMALL) D=SMALL
        DXI=XDIF/YDIF
        JY1=NINT(Y1)
        JY2=NINT(Y2)
        XI=X1+DXI*(FLOAT(JY1)-Y1)
        DYY=1.0/DY
        IF (LDASH) THEN
          DXII=(NDASH1-NDASH2-1)*DXI
          DO 50 JJ=JY1,JY2,NDASH1
            JJJ=MIN(JJ+NDASH2,JY2)
            YY=YBLC-EYE(2)+DYY*FLOAT(JJ-1)
            DO 40 J=JJ,JJJ
              K=NXP*(J-1)+NINT(XI)
              Z=ZW1+(A*YY+B)/(YY+D)
              IF (Z.GT.SBBUFF(K)) THEN
                SBBUFF(K)=Z
                SBBUFF(KSTART+K)=COLOUR
              ENDIF
              XI=XI+DXI
              YY=YY+DYY
  40        CONTINUE
            XI=XI+DXII
  50      CONTINUE
        ELSE
          YY=YBLC-EYE(2)+DYY*FLOAT(JY1-1)
          DO 60 J=JY1,JY2
            K=NXP*(J-1)+NINT(XI)
            Z=ZW1+(A*YY+B)/(YY+D)
            IF (Z.GT.SBBUFF(K)) THEN
              SBBUFF(K)=Z
              SBBUFF(KSTART+K)=COLOUR
            ENDIF
            XI=XI+DXI
            YY=YY+DYY
  60      CONTINUE
        ENDIF
      ENDIF
      END SUBROUTINE SBLINE

      SUBROUTINE SBLIN1(EYE,X,Y,Z,XW,YW)
C     ----------------------------------
C
      REAL EYE(*)
C
      XLAM=EYE(3)/(EYE(3)-Z)
      XW=EYE(1)+XLAM*(X-EYE(1))
      YW=EYE(2)+XLAM*(Y-EYE(2))
      END SUBROUTINE SBLIN1

      SUBROUTINE SBPLAN(EYE,NV,VERT,IC1,IC2,LIGHT)
C     --------------------------------------------
C
      REAL             EYE(*),VERT(3,*),LIGHT(*)
C
      REAL*8           XLNORM,ZZ,DZZ
      REAL             XW(400),YW(400)
      LOGICAL          LPS,LCOLOR
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      This subroutine plots a diffusively-lit coloured plane; the user 
C    must ensure that all the verticies lie in a flat plane, and that 
C    the bounding polygon be convex (so that the angle at any vertex
C    <= 180 degs). All (x,y,z) values are taken to be given in world 
C    coordinates. The z-component of the eye-poisition should be 
C    positive and that of the vertices should be negative; the viewing-
C    screen is fixed at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    NV       R*4    I       -      No. of verticies (>=3).
C    VERT     R*4    I     3 x NV   (x,y,z) coordinate of verticies.
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for the shading.
C    LIGHT    R*4    I       3      (x,y,z) direction of flood-light.
C
C Globals 
C    SFTBUF
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     SBLIN1     Calculates the projection of (x,y,z) on viewing screen.
C
C History
C   D. S. Sivia       4 Apr 1995  Initial release.
C   D. S. Sivia      24 Oct 1997 "Safe-guarded" some rounding errors.
C-----------------------------------------------------------------------
C
C Carry out some initial checks and calculate the coordinates of the 
C projected polygon.
C
      SMALL=1.0E-10
      SMALL2=SMALL**2
      IF (EYE(3).LE.SMALL) RETURN
      IF (NV.LT.3 .OR. NV.GT.400) RETURN
      DO 10 I=1,NV
  10    IF (VERT(3,I).GE.0.0) RETURN
      XMIN=+1.0E20
      XMAX=-1.0E20
      YMIN=+1.0E20
      YMAX=-1.0E20
      DO 20 I=1,NV
        CALL SBLIN1(EYE,VERT(1,I),VERT(2,I),VERT(3,I),XW(I),YW(I))
        IF (XW(I).LT.XMIN) THEN
          XMIN=XW(I)
          ILEFT=I
        ENDIF
        IF (YW(I).LT.YMIN) THEN
          YMIN=YW(I)
          JBOTOM=I
        ENDIF
        XMAX=MAX(XW(I),XMAX)
        YMAX=MAX(YW(I),YMAX)
  20  CONTINUE
      IF (XMIN.GE.XTRC .OR. XMAX.LE.XBLC) RETURN
      IF (YMIN.GE.YTRC .OR. YMAX.LE.YBLC) RETURN
C
C Find the outward normal seen by the eye, and activate the appropriate 
C colour.
C
      AX=VERT(1,2)-VERT(1,1)
      AY=VERT(2,2)-VERT(2,1)
      AZ=VERT(3,2)-VERT(3,1)
      BX=VERT(1,1)-VERT(1,NV)
      BY=VERT(2,1)-VERT(2,NV)
      BZ=VERT(3,1)-VERT(3,NV)
      XN=BY*AZ-AY*BZ
      YN=BZ*AX-AZ*BX
      ZN=BX*AY-AX*BY
      TEN=XN*(EYE(1)-VERT(1,1))+YN*(EYE(2)-VERT(2,1))
     *   +ZN*(EYE(3)-VERT(3,1))
      COLOUR=FLOAT(IC1)
      NC=IC2-IC1
      IF (NC.GT.0) THEN
        TNL=XN*LIGHT(1)+YN*LIGHT(2)+ZN*LIGHT(3)
        IF (TEN.LT.0.0) TNL=-TNL
        COSDIF=0.0
        IF (TNL.LT.0.0) THEN
          TN2=XN**2+YN**2+ZN**2
          TL2=LIGHT(1)**2+LIGHT(2)**2+LIGHT(3)**2
          COSDIF=MIN(-TNL/SQRT(TN2*TL2+SMALL2),1.0)
        ENDIF
        COLOUR=COLOUR+COSDIF*FLOAT(NC)
      ENDIF
C
C Plot the projected polygon.
C
      XLNORM=DBLE(EYE(3))*DBLE(TEN)
      EYENRM=XN*EYE(1)+YN*EYE(2)+ZN*EYE(3)
      DX=FLOAT(NXP-1)/(XTRC-XBLC)
      DY=FLOAT(NYP-1)/(YTRC-YBLC)
      DYJ=1.0/DY
      DXI=1.0/DX
      SAFER=0.0001
      IF ((XMAX-XMIN).GT.(YMAX-YMIN)) THEN
        JYMIN=INT((YMIN-YBLC)*DY)+2
        JYMAX=MIN(INT((YMAX-YBLC)*DY)+1,NYP)
        IF (JYMIN.GT.JYMAX) RETURN
        YJ=YBLC+(FLOAT(JYMIN-1)+SAFER)*DYJ
        NVL2=JBOTOM
        NVR2=JBOTOM
        J1=JYMIN
        DO 50 IVERT=1,NV
          IF (YJ.GT.YW(NVL2)) THEN
   1        NVL1=NVL2
            NVL2=NVL1-1
            IF (NVL2.LT.1) NVL2=NV
            IF (NVL2.EQ.JBOTOM) RETURN
            IF (YJ.GT.YW(NVL2)) GOTO 1
            YDIFL=YW(NVL2)-YW(NVL1)
            IF (ABS(YDIFL).LT.SMALL) YDIFL=SMALL
            GRADL=(XW(NVL2)-XW(NVL1))/YDIFL
          ENDIF
          IF (YJ.GT.YW(NVR2)) THEN
   2        NVR1=NVR2
            NVR2=NVR1+1
            IF (NVR2.GT.NV) NVR2=1
            IF (NVR2.EQ.JBOTOM) RETURN
            IF (YJ.GT.YW(NVR2)) GOTO 2
            YDIFR=YW(NVR2)-YW(NVR1)
            IF (ABS(YDIFR).LT.SMALL) YDIFR=SMALL
            GRADR=(XW(NVR2)-XW(NVR1))/YDIFR
          ENDIF
          IF (YW(NVL2).LT.YW(NVR2)) THEN
            J2=MIN(INT((YW(NVL2)-YBLC)*DY)+1,JYMAX)
          ELSE
            J2=MIN(INT((YW(NVR2)-YBLC)*DY)+1,JYMAX)
          ENDIF
          DO 40 J=J1,J2
            IF (J.GE.1) THEN
              XL=XW(NVL1)+GRADL*(YJ-YW(NVL1))
              XR=XW(NVR1)+GRADR*(YJ-YW(NVR1))
              ISTEP=1
              IX1=MAX(INT((XL-XBLC)*DX)+2,1)
              IX2=MIN(INT((XR-XBLC)*DX)+1,NXP)
              IF (IX1.GT.IX2) THEN
                ISTEP=-1
                IX1=MIN(IX1-1,NXP)
                IX2=MAX(IX2+1,1)
              ENDIF
              DZZ=DBLE(FLOAT(ISTEP)*DXI*XN)
              ZZ=DBLE(EYENRM-(XBLC+FLOAT(IX1-1)*DXI)*XN-YJ*YN)
              K=(J-1)*NXP+IX1
              DO 30 I=IX1,IX2,ISTEP
                Z=EYE(3)-SNGL(XLNORM/ZZ)
                IF (Z.GT.SBBUFF(K)) THEN
                  SBBUFF(K)=Z
                  SBBUFF(KSTART+K)=COLOUR
                ENDIF
                ZZ=ZZ-DZZ
                K=K+ISTEP
  30          CONTINUE
            ENDIF
            YJ=YJ+DYJ
  40      CONTINUE
          J1=J2+1
          IF (J1.GT.JYMAX) RETURN
  50    CONTINUE
      ELSE
        IXMIN=INT((XMIN-XBLC)*DX)+2
        IXMAX=MIN(INT((XMAX-XBLC)*DX)+1,NXP)
        IF (IXMIN.GT.IXMAX) RETURN
        XI=XBLC+(FLOAT(IXMIN-1)+SAFER)*DXI
        NVL2=ILEFT
        NVR2=ILEFT
        I1=IXMIN
        DO 80 IVERT=1,NV
          IF (XI.GT.XW(NVL2)) THEN
   3        NVL1=NVL2
            NVL2=NVL1-1
            IF (NVL2.LT.1) NVL2=NV
            IF (NVL2.EQ.ILEFT) RETURN
            IF (XI.GT.XW(NVL2)) GOTO 3
            XDIFL=XW(NVL2)-XW(NVL1)
            IF (ABS(XDIFL).LT.SMALL) XDIFL=SMALL
            GRADL=(YW(NVL2)-YW(NVL1))/XDIFL
          ENDIF
          IF (XI.GT.XW(NVR2)) THEN
   4        NVR1=NVR2
            NVR2=NVR1+1
            IF (NVR2.GT.NV) NVR2=1
            IF (NVR2.EQ.ILEFT) RETURN
            IF (XI.GT.XW(NVR2)) GOTO 4
            XDIFR=XW(NVR2)-XW(NVR1)
            IF (ABS(XDIFR).LT.SMALL) XDIFR=SMALL
            GRADR=(YW(NVR2)-YW(NVR1))/XDIFR
          ENDIF
          IF (XW(NVL2).LT.XW(NVR2)) THEN
            I2=MIN(INT((XW(NVL2)-XBLC)*DX)+1,IXMAX)
          ELSE
            I2=MIN(INT((XW(NVR2)-XBLC)*DX)+1,IXMAX)
          ENDIF
          DO 70 I=I1,I2
            IF (I.GE.1) THEN
              YL=YW(NVL1)+GRADL*(XI-XW(NVL1))
              YR=YW(NVR1)+GRADR*(XI-XW(NVR1))
              ISTEP=1
              JY1=MAX(INT((YL-YBLC)*DY)+2,1)
              JY2=MIN(INT((YR-YBLC)*DY)+1,NYP)
              IF (JY1.GT.JY2) THEN
                ISTEP=-1
                JY1=MIN(JY1-1,NYP)
                JY2=MAX(JY2+1,1)
              ENDIF
              DZZ=DBLE(FLOAT(ISTEP)*DYJ*YN)
              ZZ=DBLE(EYENRM-(YBLC+FLOAT(JY1-1)*DYJ)*YN-XI*XN)
              K=(JY1-1)*NXP+I
              KSTEP=ISTEP*NXP
              DO 60 J=JY1,JY2,ISTEP
                Z=EYE(3)-SNGL(XLNORM/ZZ)
                IF (Z.GT.SBBUFF(K)) THEN
                  SBBUFF(K)=Z
                  SBBUFF(KSTART+K)=COLOUR
                ENDIF
                ZZ=ZZ-DZZ
                K=K+KSTEP
  60          CONTINUE
            ENDIF
            XI=XI+DXI
  70      CONTINUE
          I1=I2+1
          IF (I1.GT.IXMAX) RETURN
  80    CONTINUE
      ENDIF
      END SUBROUTINE SBPLAN

      SUBROUTINE SBROD(EYE,END1,END2,RADIUS,IC1,IC2,LIGHT,NSIDES,LEND)
C     ----------------------------------------------------------------
C
      REAL     EYE(*),END1(*),END2(*),LIGHT(*)
      LOGICAL  LEND
C
      LOGICAL  LEND1,LSTART
      REAL     ENDVRT(3,361),SIDVRT(3,4)
      REAL     SINROT(361),COSROT(361)
      SAVE     LSTART,NROT0,SINROT,COSROT,SCLNRM
      DATA     NRTMAX,PI,LSTART /361,3.141592654,.FALSE./
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
!




C      This subroutine plots a diffusively-shaded coloured rod. All 
C    (x,y,z) values are taken to be given in world coordinates. The 
C    z-component of the eye-poisition should be positive and that of
C    the rod-ends should be negative (< -radius); the viewing-screen
C    is fixed at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    END1     R*4    I       3      (x,y,z) coordinate of rod-end 1.
C    END2     R*4    I       3      (x,y,z) coordinate of rod-end 2.
C    RADIUS   R*4    I       -      Radius of cylinderical rod.
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for the shading.
C    LIGHT    R*4    I       3      (x,y,z) direction of flood-light.
C    NSIDES   I*4    I       -      The order of the polygon to be used
C                                   for the cross-section of the rod.
C    LEND     L*1    I       -      If true, plot the end of the rod.
C
C External Calls
C     SBLINE     Draws a straight line between two points.
C     SBPLAN     Plots a coloured plane.
C     SBROD1     Initialises the array of sines and coses, if necessary.
C     SBRCOP     Copies one real array to another.
C
C History
C   D. S. Sivia       4 Apr 1995  Initial release.
C   D. S. Sivia      22 Oct 1997  Increased NRTMAX from 73 to 361.
C-----------------------------------------------------------------------
C
C Some initial checks.
C
      IF (NSIDES.LE.2) THEN
        CALL SBLINE(EYE,END1,END2,IC2,.FALSE.)
        RETURN
      ENDIF
      SMALL=1.0E-20
      IF (EYE(3).LE.0.0) RETURN
      IF (RADIUS.LE.0.0) RETURN
      IF (END1(3).GT.-RADIUS .OR. END2(3).GT.-RADIUS) RETURN
      XL=END2(1)-END1(1)
      YL=END2(2)-END1(2)
      ZL=END2(3)-END1(3)
      RLENG2=XL**2+YL**2+ZL**2
      IF (RLENG2.LT.SMALL) RETURN
C
C Find out which end of the rod, if any, can be seen.
C
      LEND1=.FALSE.
      X0=END1(1)
      Y0=END1(2)
      Z0=END1(3)
      EYEND=XL*(EYE(1)-X0)+YL*(EYE(2)-Y0)+ZL*(EYE(3)-Z0)
      IF (EYEND.LT.0.0) THEN
        LEND1=.TRUE.
      ELSE
        X0=END2(1)
        Y0=END2(2)
        Z0=END2(3)
        XL=-XL
        YL=-YL
        ZL=-ZL
        EYEND=XL*(EYE(1)-X0)+YL*(EYE(2)-Y0)+ZL*(EYE(3)-Z0)
        IF (EYEND.LT.0.0) LEND1=.TRUE.
      ENDIF
      SINTHT=0.0
      COSTHT=1.0
      SINPHI=0.0
      COSPHI=1.0
      RXY2=XL**2+YL**2
      IF (RXY2.GT.SMALL) THEN
        RLENG=SQRT(RLENG2)
        RXY=SQRT(RXY2)
        SINTHT=+RXY/RLENG
        COSTHT=-ZL/RLENG  
        SINPHI=-YL/RXY
        COSPHI=-XL/RXY
      ENDIF
      IF (.NOT. LEND) LEND1=.FALSE.
C
C Sweep around the rod and plot the shaded surface.
C
      NROT=MIN(NSIDES+1,NRTMAX)
      CALL SBROD1(LSTART,NROT0,NROT,SINROT,COSROT,PI,SCLNRM)
      DO 10 I=1,NROT
        X=RADIUS*COSROT(I)
        Y=RADIUS*SINROT(I)
        ENDVRT(1,I)=X0+X*COSTHT*COSPHI-Y*SINPHI
        ENDVRT(2,I)=Y0+X*COSTHT*SINPHI+Y*COSPHI
        ENDVRT(3,I)=Z0-X*SINTHT
  10  CONTINUE
      DO 20 J=2,NROT
        I=J-1
        XN=SCLNRM*(ENDVRT(1,I)+ENDVRT(1,J)-X0-X0)
        YN=SCLNRM*(ENDVRT(2,I)+ENDVRT(2,J)-Y0-Y0)
        ZN=SCLNRM*(ENDVRT(3,I)+ENDVRT(3,J)-Z0-Z0)
        ENN2=(EYE(1)-X0-XN)*XN+(EYE(2)-Y0-YN)*YN+(EYE(3)-Z0-ZN)*ZN
        IF (ENN2.GT.0.0) THEN
          CALL SBRCOP(ENDVRT(1,I),SIDVRT(1,1),3)
          SIDVRT(1,2)=ENDVRT(1,I)+XL
          SIDVRT(2,2)=ENDVRT(2,I)+YL
          SIDVRT(3,2)=ENDVRT(3,I)+ZL
          SIDVRT(1,3)=ENDVRT(1,J)+XL
          SIDVRT(2,3)=ENDVRT(2,J)+YL
          SIDVRT(3,3)=ENDVRT(3,J)+ZL
          CALL SBRCOP(ENDVRT(1,J),SIDVRT(1,4),3)
          CALL SBPLAN(EYE,4,SIDVRT,IC1,IC2,LIGHT)
        ENDIF
  20  CONTINUE
      IF (LEND1) CALL SBPLAN(EYE,NROT-1,ENDVRT,IC1,IC2,LIGHT)
      END SUBROUTINE SBROD

      SUBROUTINE SBROD1(LSTART,NROT0,NROT,SINROT,COSROT,PI,SCLNRM)
C     ------------------------------------------------------------
C
      REAL    COSROT(*),SINROT(*)
      LOGICAL LSTART
C
      IF (LSTART .AND. NROT.EQ.NROT0) RETURN
      ROT=0.0
      DROT=2.0*PI/FLOAT(NROT-1)
      DO 10 I=1,NROT
        SINROT(I)=SIN(ROT)
        COSROT(I)=COS(ROT)
        ROT=ROT+DROT
  10  CONTINUE
      SCLNRM=0.5/COS(DROT/2.0)
      LSTART=.TRUE.
      NROT0=NROT
      END SUBROUTINE SBROD1

      SUBROUTINE SBCONE(EYE,BASE,APEX,RADIUS,IC1,IC2,LIGHT,NSIDES)
C     ------------------------------------------------------------
C
      REAL     EYE(*),BASE(*),APEX(*),LIGHT(*)
C
      LOGICAL  LBASE,LSTART
      REAL     BASVRT(3,361),SIDVRT(3,3)
      REAL     SINROT(361),COSROT(361)
      SAVE     LSTART,NROT0,SINROT,COSROT,SCLNRM
      DATA     NRTMAX,PI,LSTART /361,3.141592654,.FALSE./
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      This subroutine plots a diffusively-shaded coloured right-angular
C    cone. All (x,y,z) values are taken to be given in world coordinates.
C    The z-component of the eye-poisition should be positive and that of
C    the base and appex of the cone should be negative (< -radius); the 
C    viewing-screen is fixed at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    BASE     R*4    I       3      (x,y,z) coordinate of the centre of
C                                   the base of the cone.
C    APEX     R*4    I       3      (x,y,z) coordinate of the apex.
C    RADIUS   R*4    I       -      Radius of the base of the cone.
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for the shading.
C    LIGHT    R*4    I       3      (x,y,z) direction of flood-light.
C    NSIDES   I*4    I       -      The order of the polygon to be used
C                                   for the cross-section of the cone.
C
C External Calls
C     SBLINE     Draws a straight line between two points.
C     SBPLAN     Plots a coloured plane.
C     SBROD1     Initialises the array of sines and coses, if necessary.
C     SBRCOP     Copies one real array to another.
C
C History
C   D. S. Sivia      29 Jun 1995  Initial release.
C   D. S. Sivia      22 Oct 1997  Increased NRTMAX from 73 to 361.
C-----------------------------------------------------------------------
C
C Some initial checks.
C
      SMALL=1.0E-20
      IF (NSIDES.LE.2) RETURN
      IF (EYE(3).LE.0.0) RETURN
      IF (RADIUS.LE.0.0) RETURN
      IF (BASE(3).GT.-RADIUS .OR. APEX(3).GE.0.0) RETURN
      XL=APEX(1)-BASE(1)
      YL=APEX(2)-BASE(2)
      ZL=APEX(3)-BASE(3)
      RLENG2=XL**2+YL**2+ZL**2
      IF (RLENG2.LT.SMALL) RETURN
C
C Find out whether the base of the cone can be seen.
C
      LBASE=.FALSE.
      X0=BASE(1)
      Y0=BASE(2)
      Z0=BASE(3)
      EYEND=XL*(EYE(1)-X0)+YL*(EYE(2)-Y0)+ZL*(EYE(3)-Z0)
      IF (EYEND.LT.0.0) LBASE=.TRUE.
      SINTHT=0.0
      COSTHT=1.0
      SINPHI=0.0
      COSPHI=1.0
      RXY2=XL**2+YL**2
      IF (RXY2.GT.SMALL) THEN
        RLENG=SQRT(RLENG2)
        RXY=SQRT(RXY2)
        SINTHT=+RXY/RLENG
        COSTHT=-ZL/RLENG  
        SINPHI=-YL/RXY
        COSPHI=-XL/RXY
      ENDIF
C
C Sweep around the rod and plot the shaded surface.
C
      NROT=MIN(NSIDES+1,NRTMAX)
      CALL SBROD1(LSTART,NROT0,NROT,SINROT,COSROT,PI,SCLNRM)
      DO 10 I=1,NROT
        X=RADIUS*COSROT(I)
        Y=RADIUS*SINROT(I)
        BASVRT(1,I)=X0+X*COSTHT*COSPHI-Y*SINPHI
        BASVRT(2,I)=Y0+X*COSTHT*SINPHI+Y*COSPHI
        BASVRT(3,I)=Z0-X*SINTHT
  10  CONTINUE
      IF (LBASE) CALL SBPLAN(EYE,NROT-1,BASVRT,IC1,IC2,LIGHT)
      CALL SBRCOP(APEX,SIDVRT(1,3),3)
      DO 20 J=1,NROT-1
        CALL SBRCOP(BASVRT(1,J),SIDVRT(1,1),6)
        CALL SBPLAN(EYE,3,SIDVRT,IC1,IC2,LIGHT)
  20  CONTINUE
      END SUBROUTINE SBCONE

      SUBROUTINE SBSLIC(EYE,LATICE,DENS,N1,N2,N3,DLOW,DHIGH,IC1,IC2,
     *                  SLNORM,APOINT,ICEDGE)
C     --------------------------------------------------------------
C
      REAL             EYE(*),LATICE(3,*),DENS(0:N1,0:N2,0:N3)
      REAL             SLNORM(*),APOINT(*)
C
      REAL*8           XLNORM,ZZ,DZZ
      REAL             BAS(3,3),MTRX(3,3)
      REAL             END1(3),END2(3),VERT(3,12),XW(20),YW(20)
      LOGICAL          LPS,LCOLOR,LVERT(12)
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
!




C      This subroutine plots a "grey-scale" slice through a unit-cell
C    of density. All (x,y,z) values are taken to be given in world 
C    coordinates. The z-component of the eye-poisition should be 
C    positive and that of all the lattice-vertices should be negative; 
C    the viewing-screen is fixed at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    LATICE   R*4    I     3 x 4    (x,y,z) coordinates of the origin
C                                   and the a, b & C lattice-vertices.
C    DENS     R*4    I     (N1+1)   The density at regular points within
C                        x (N2+1)   the unit cell, wrapped around so
C                        x (N3+1)   that DENS(0,J,K)=DENS(N1,J,K) etc..
C    N1,N2,N3 I*4    I       -      The dimensions of the unit-cell grid.
C    DLOW     R*4    I       -      Density for the lowest colour-index.
C    DHIGH    R*4    I       -      Density for the highest colour-index.
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for the shading.
C    SLNORM   R*4    I       3      (x,y,z) direction of the normal to 
C                                   the slice to be "grey-scaled".
C    APONIT   R*4    I       3      (x,y,z) coordinate of a point within
C                                   the slice to be "grey-scaled".
C    ICEDGE   I*4    I       -      If >=0, it's the colour-index for the
C                                   boundary of the "grey-scaled" slice.
C
C Globals 
C    SFTBUF
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     SBSLC1     Plots a side of the unit cell and sees if it is cut by
C                the slice to be "grey-scaled".
C     SBSLC2     Calculates the coordinates of the projected polygon.
C     SLSLC3     Calculates the appropriate colour for a given pixel.
C     SBLIN1     Calculates the projection of (x,y,z) on viewing screen.
C
C History
C   D. S. Sivia      30 Apr 1995  Initial release.
C   D. S. Sivia       7 Jul 1995  Fixed some bug.
C   D. S. Sivia      24 Oct 1997 "Safe-guarded" some rounding errors.
C-----------------------------------------------------------------------
C
C Carry out some initial checks.
C
      SMALL=1.0E-10
      SMALL2=SMALL**2
      IF (EYE(3).LE.SMALL) RETURN
      IF (N1.LT.1 .OR. N2.LT.1 .OR. N3.LT.1) RETURN
      SNRM=1.0/SQRT(SLNORM(1)**2+SLNORM(2)**2+SLNORM(3)**2+SMALL2)
      XN=SLNORM(1)*SNRM
      YN=SLNORM(2)*SNRM
      ZN=SLNORM(3)*SNRM
      XAE=EYE(1)-APOINT(1)
      YAE=EYE(2)-APOINT(2)
      ZAE=EYE(3)-APOINT(3)
      XLNORM=DBLE(XN*XAE)+DBLE(YN*YAE)+DBLE(ZN*ZAE)
      COSNRM=SNGL(XLNORM/SQRT(DBLE(XAE**2)+DBLE(YAE**2)+DBLE(ZAE**2)
     *      +DBLE(SMALL2)))
      IF (ABS(COSNRM).LT.0.001) RETURN
      DO 10 J=1,3
        BAS(1,J)=LATICE(1,J+1)-LATICE(1,1)
        BAS(2,J)=LATICE(2,J+1)-LATICE(2,1)
        BAS(3,J)=LATICE(3,J+1)-LATICE(3,1)
        BAS2J=BAS(1,J)**2+BAS(2,J)**2+BAS(3,J)**2
        IF (BAS2J.LT.SMALL2) RETURN
  10  CONTINUE
      COL0=FLOAT(IC1)
      CSCL=FLOAT(IC2-IC1)
      COLNRM=DHIGH-DLOW
      IF (ABS(COLNRM).LT.SMALL) RETURN
      DCOL=1.0/COLNRM
C
C Set up matrix for real-space to lattice-index transformation.
C
      DET=BAS(1,1)*BAS(2,2)*BAS(3,3)+BAS(1,2)*BAS(2,3)*BAS(3,1)
     *   +BAS(1,3)*BAS(2,1)*BAS(3,2)-BAS(3,1)*BAS(2,2)*BAS(1,3)
     *   -BAS(3,2)*BAS(2,3)*BAS(1,1)-BAS(3,3)*BAS(2,1)*BAS(1,2)
      IF (ABS(DET).LT.SMALL2) RETURN
      DETNRM=1.0/DET
      MTRX(1,1)=DETNRM*(BAS(2,2)*BAS(3,3)-BAS(2,3)*BAS(3,2))
      MTRX(1,2)=DETNRM*(BAS(2,3)*BAS(3,1)-BAS(2,1)*BAS(3,3))
      MTRX(1,3)=DETNRM*(BAS(2,1)*BAS(3,2)-BAS(2,2)*BAS(3,1))
      MTRX(2,1)=DETNRM*(BAS(3,2)*BAS(1,3)-BAS(3,3)*BAS(1,2))
      MTRX(2,2)=DETNRM*(BAS(3,3)*BAS(1,1)-BAS(3,1)*BAS(1,3))
      MTRX(2,3)=DETNRM*(BAS(3,1)*BAS(1,2)-BAS(3,2)*BAS(1,1))
      MTRX(3,1)=DETNRM*(BAS(1,2)*BAS(2,3)-BAS(1,3)*BAS(2,2))
      MTRX(3,2)=DETNRM*(BAS(1,3)*BAS(2,1)-BAS(1,1)*BAS(2,3))
      MTRX(3,3)=DETNRM*(BAS(1,1)*BAS(2,2)-BAS(1,2)*BAS(2,1))
C
C Draw the frame of the unit cell and calculate the coordinates of the 
C projected polygon.
C
      NVERT=0
      II=0
      DO 20 L=1,12,4
        I=II+2
        J=MOD(II+1,3)+2
        K=MOD(II+2,3)+2
        CALL SBSLC1(LATICE,LATICE(1,K),XN,YN,ZN,APOINT,LVERT(L),
     *              VERT(1,L),NVERT)
        END1(1)=LATICE(1,I)+LATICE(1,J)-LATICE(1,1)
        END1(2)=LATICE(2,I)+LATICE(2,J)-LATICE(2,1)
        END1(3)=LATICE(3,I)+LATICE(3,J)-LATICE(3,1)
        CALL SBSLC1(LATICE(1,I),END1,XN,YN,ZN,APOINT,LVERT(L+1),
     *              VERT(1,L+1),NVERT)
        CALL SBSLC1(LATICE(1,J),END1,XN,YN,ZN,APOINT,LVERT(L+2),
     *              VERT(1,L+2),NVERT)
        END2(1)=END1(1)+LATICE(1,K)-LATICE(1,1)
        END2(2)=END1(2)+LATICE(2,K)-LATICE(2,1)
        END2(3)=END1(3)+LATICE(3,K)-LATICE(3,1)
        CALL SBSLC1(END1,END2,XN,YN,ZN,APOINT,LVERT(L+3),
     *              VERT(1,L+3),NVERT)
        II=II+1
  20  CONTINUE
      IF (NVERT.LT.3) RETURN
      CALL SBSLC2(EYE,LVERT,VERT,NVERT,XN,YN,ZN,XW,YW,ICEDGE,ZDLINE)
C
C Paint the projected polygon slice.
C
      XMIN=+1.0E20
      XMAX=-1.0E20
      YMIN=+1.0E20
      YMAX=-1.0E20
      DO 30 I=1,NVERT
        IF (XW(I).LT.XMIN) THEN
          XMIN=XW(I)
          ILEFT=I
        ENDIF
        IF (YW(I).LT.YMIN) THEN
          YMIN=YW(I)
          JBOTOM=I
        ENDIF
        XMAX=MAX(XW(I),XMAX)
        YMAX=MAX(YW(I),YMAX)
  30  CONTINUE
      IF (XMIN.GE.XTRC .OR. XMAX.LE.XBLC) RETURN
      IF (YMIN.GE.YTRC .OR. YMAX.LE.YBLC) RETURN
C
      EYENRM=XN*EYE(1)+YN*EYE(2)+ZN*EYE(3)
      DX=FLOAT(NXP-1)/(XTRC-XBLC)
      DY=FLOAT(NYP-1)/(YTRC-YBLC)
      DYJ=1.0/DY
      DXI=1.0/DX
      SAFER=0.0001
      IF ((XMAX-XMIN).GT.(YMAX-YMIN)) THEN
        JYMIN=INT((YMIN-YBLC)*DY)+2
        JYMAX=MIN(INT((YMAX-YBLC)*DY)+1,NYP)
        IF (JYMIN.GT.JYMAX) RETURN
        YJ=YBLC+(FLOAT(JYMIN-1)+SAFER)*DYJ
        NVL2=JBOTOM
        NVR2=JBOTOM
        J1=JYMIN
        DO 60 IVERT=1,NVERT
          IF (YJ.GT.YW(NVL2)) THEN
   1        NVL1=NVL2
            NVL2=NVL1-1
            IF (NVL2.LT.1) NVL2=NVERT
            IF (NVL2.EQ.JBOTOM) RETURN
            IF (YJ.GT.YW(NVL2)) GOTO 1
            YDIFL=YW(NVL2)-YW(NVL1)
            IF (ABS(YDIFL).LT.SMALL) YDIFL=SMALL
            GRADL=(XW(NVL2)-XW(NVL1))/YDIFL
          ENDIF
          IF (YJ.GT.YW(NVR2)) THEN
   2        NVR1=NVR2
            NVR2=NVR1+1
            IF (NVR2.GT.NVERT) NVR2=1
            IF (NVR2.EQ.JBOTOM) RETURN
            IF (YJ.GT.YW(NVR2)) GOTO 2
            YDIFR=YW(NVR2)-YW(NVR1)
            IF (ABS(YDIFR).LT.SMALL) YDIFR=SMALL
            GRADR=(XW(NVR2)-XW(NVR1))/YDIFR
          ENDIF
          IF (YW(NVL2).LT.YW(NVR2)) THEN
            J2=MIN(INT((YW(NVL2)-YBLC)*DY)+1,JYMAX)
          ELSE
            J2=MIN(INT((YW(NVR2)-YBLC)*DY)+1,JYMAX)
          ENDIF
          DO 50 J=J1,J2
            IF (J.GE.1) THEN
              XL=XW(NVL1)+GRADL*(YJ-YW(NVL1))
              XR=XW(NVR1)+GRADR*(YJ-YW(NVR1))
              ISTEP=1
              IX1=MAX(INT((XL-XBLC)*DX)+2,1)
              IX2=MIN(INT((XR-XBLC)*DX)+1,NXP)
              IF (IX1.GT.IX2) THEN
                ISTEP=-1
                IX1=MIN(IX1-1,NXP)
                IX2=MAX(IX2+1,1)
              ENDIF
              XI=XBLC+FLOAT(IX1-1)*DXI
              SDXI=FLOAT(ISTEP)*DXI
              DZZ=DBLE(SDXI*XN)
              ZZ=DBLE(EYENRM-XI*XN-YJ*YN)
              K=(J-1)*NXP+IX1
              DO 40 I=IX1,IX2,ISTEP
                XLAMDA=SNGL(XLNORM/ZZ)
                Z=EYE(3)*(1.0-XLAMDA)
                IF ((Z-SBBUFF(K)).GT.ZDLINE) THEN
                  SBBUFF(K)=Z
                  X=EYE(1)+XLAMDA*(XI-EYE(1))-LATICE(1,1)
                  Y=EYE(2)+XLAMDA*(YJ-EYE(2))-LATICE(2,1)
                  Z=Z-LATICE(3,1)
                  CALL SBSLC3(DENS,N1,N2,N3,X,Y,Z,MTRX,DLOW,DCOL,COLOUR)
                  SBBUFF(KSTART+K)=COL0+CSCL*COLOUR
                ENDIF
                XI=XI+SDXI
                ZZ=ZZ-DZZ
                K=K+ISTEP
  40          CONTINUE
            ENDIF
            YJ=YJ+DYJ
  50      CONTINUE
          J1=J2+1
          IF (J1.GT.JYMAX) RETURN
  60    CONTINUE
      ELSE
        IXMIN=INT((XMIN-XBLC)*DX)+2
        IXMAX=MIN(INT((XMAX-XBLC)*DX)+1,NXP)
        IF (IXMIN.GT.IXMAX) RETURN
        XI=XBLC+(FLOAT(IXMIN-1)+SAFER)*DXI
        NVL2=ILEFT
        NVR2=ILEFT
        I1=IXMIN
        DO 90 IVERT=1,NVERT
          IF (XI.GT.XW(NVL2)) THEN
   3        NVL1=NVL2
            NVL2=NVL1-1
            IF (NVL2.LT.1) NVL2=NVERT
            IF (NVL2.EQ.ILEFT) RETURN
            IF (XI.GT.XW(NVL2)) GOTO 3
            XDIFL=XW(NVL2)-XW(NVL1)
            IF (ABS(XDIFL).LT.SMALL) XDIFL=SMALL
            GRADL=(YW(NVL2)-YW(NVL1))/XDIFL
          ENDIF
          IF (XI.GT.XW(NVR2)) THEN
   4        NVR1=NVR2
            NVR2=NVR1+1
            IF (NVR2.GT.NVERT) NVR2=1
            IF (NVR2.EQ.ILEFT) RETURN
            IF (XI.GT.XW(NVR2)) GOTO 4
            XDIFR=XW(NVR2)-XW(NVR1)
            IF (ABS(XDIFR).LT.SMALL) XDIFR=SMALL
            GRADR=(YW(NVR2)-YW(NVR1))/XDIFR
          ENDIF
          IF (XW(NVL2).LT.XW(NVR2)) THEN
            I2=MIN(INT((XW(NVL2)-XBLC)*DX)+1,IXMAX)
          ELSE
            I2=MIN(INT((XW(NVR2)-XBLC)*DX)+1,IXMAX)
          ENDIF
          DO 80 I=I1,I2
            IF (I.GE.1) THEN
              YL=YW(NVL1)+GRADL*(XI-XW(NVL1))
              YR=YW(NVR1)+GRADR*(XI-XW(NVR1))
              ISTEP=1
              JY1=MAX(INT((YL-YBLC)*DY)+2,1)
              JY2=MIN(INT((YR-YBLC)*DY)+1,NYP)
              IF (JY1.GT.JY2) THEN
                ISTEP=-1
                JY1=MIN(JY1-1,NYP)
                JY2=MAX(JY2+1,1)
              ENDIF
              YJ=YBLC+FLOAT(JY1-1)*DYJ
              SDYJ=FLOAT(ISTEP)*DYJ
              DZZ=DBLE(SDYJ*YN)
              ZZ=DBLE(EYENRM-YJ*YN-XI*XN)
              K=(JY1-1)*NXP+I
              KSTEP=ISTEP*NXP
              DO 70 J=JY1,JY2,ISTEP
                XLAMDA=SNGL(XLNORM/ZZ)
                Z=EYE(3)*(1.0-XLAMDA)
                IF ((Z-SBBUFF(K)).GT.ZDLINE) THEN
                  SBBUFF(K)=Z
                  X=EYE(1)+XLAMDA*(XI-EYE(1))-LATICE(1,1)
                  Y=EYE(2)+XLAMDA*(YJ-EYE(2))-LATICE(2,1)
                  Z=Z-LATICE(3,1)
                  CALL SBSLC3(DENS,N1,N2,N3,X,Y,Z,MTRX,DLOW,DCOL,COLOUR)
                  SBBUFF(KSTART+K)=COL0+CSCL*COLOUR
                ENDIF
                YJ=YJ+SDYJ
                ZZ=ZZ-DZZ
                K=K+KSTEP
  70          CONTINUE
            ENDIF
            XI=XI+DXI
  80      CONTINUE
          I1=I2+1
          IF (I1.GT.IXMAX) RETURN
  90    CONTINUE
      ENDIF
      END SUBROUTINE SBSLIC

      SUBROUTINE SBSLC1(END1,END2,XN,YN,ZN,APOINT,LVERT,VERT,NVERT)
C     -------------------------------------------------------------
C
      REAL    END1(*),END2(*),APOINT(*),VERT(*)
      LOGICAL LVERT
C
      LVERT=.FALSE.
      X12=END2(1)-END1(1)
      Y12=END2(2)-END1(2)
      Z12=END2(3)-END1(3)
      DENOM=XN*X12+YN*Y12+ZN*Z12
      COSNRM=DENOM/SQRT(X12**2+Y12**2+Z12**2+1.0E-20)
      IF (ABS(COSNRM).LT.0.001) RETURN
      XLAM=(XN*(APOINT(1)-END1(1))+YN*(APOINT(2)-END1(2))
     *     +ZN*(APOINT(3)-END1(3)))/DENOM
      IF (XLAM.GE.0.0 .AND. XLAM.LE.1.0) THEN
        LVERT=.TRUE.
        NVERT=NVERT+1
        VERT(1)=END1(1)+XLAM*X12
        VERT(2)=END1(2)+XLAM*Y12
        VERT(3)=END1(3)+XLAM*Z12
        IF (VERT(3).GE.0.0) NVERT=-1000
      ENDIF
      END SUBROUTINE SBSLC1

      SUBROUTINE SBSLC2(EYE,LVERT,VERT,NVERT,XN,YN,ZN,XW,YW,ICOL,ZDIF)
C     ----------------------------------------------------------------
C
      REAL    EYE(*),VERT(3,*),XW(*),YW(*),ANGLE(12)
      INTEGER ISORT(12)
      LOGICAL LVERT(*)
C
      IV1=0
      XBAR=0.0
      YBAR=0.0
      ZBAR=0.0
      ZMIN=+1.0E20
      ZMAX=-1.0E20
      DO 10 K=1,12
        ZMIN=MIN(ZMIN,VERT(3,K))
        ZMAX=MAX(ZMAX,VERT(3,K))
        IF (LVERT(K)) THEN
          IF (IV1.LE.0) IV1=K
          XBAR=XBAR+VERT(1,K)
          YBAR=YBAR+VERT(2,K)
          ZBAR=ZBAR+VERT(3,K)
        ENDIF
  10  CONTINUE
      ZDIF=(ZMAX-ZMIN)/5000.0
      XBAR=XBAR/FLOAT(NVERT)
      YBAR=YBAR/FLOAT(NVERT)
      ZBAR=ZBAR/FLOAT(NVERT)
      XREF=VERT(1,IV1)-XBAR
      YREF=VERT(2,IV1)-YBAR
      ZREF=VERT(3,IV1)-ZBAR
      REFNRM=1.0/SQRT(XREF**2+YREF**2+ZREF**2+1.0E-20)
      XREF=XREF*REFNRM
      YREF=YREF*REFNRM
      ZREF=ZREF*REFNRM
      XNRM=YREF*ZN-YN*ZREF
      YNRM=ZREF*XN-ZN*XREF
      ZNRM=XREF*YN-XN*YREF
      J=1
      ANGLE(J)=0.0
      ISORT(J)=IV1
      CALL SBLIN1(EYE,VERT(1,IV1),VERT(2,IV1),VERT(3,IV1),XW(J),YW(J))
      DO 40 K=IV1+1,12
        IF (LVERT(K)) THEN
          J=J+1
          XVEC=VERT(1,K)-XBAR
          YVEC=VERT(2,K)-YBAR
          ZVEC=VERT(3,K)-ZBAR
          X=XVEC*XREF+YVEC*YREF+ZVEC*ZREF
          Y=XVEC*XNRM+YVEC*YNRM+ZVEC*ZNRM
          ANGJ=ATAN2(Y,X)
          CALL SBLIN1(EYE,VERT(1,K),VERT(2,K),VERT(3,K),XWJ,YWJ)
          DO 20 I=1,J-1
  20        IF (ANGJ.LT.ANGLE(I)) GOTO 1
   1      II=I
           DO 30 I=J,II+1,-1
            XW(I)=XW(I-1)
            YW(I)=YW(I-1)
            ANGLE(I)=ANGLE(I-1)
            ISORT(I)=ISORT(I-1)
  30      CONTINUE
          XW(II)=XWJ
          YW(II)=YWJ
          ANGLE(II)=ANGJ
          ISORT(II)=K
        ENDIF
  40  CONTINUE
      IF (ICOL.GE.0.0) THEN
        DO 50 I=1,NVERT-1
          J=ISORT(I)
          K=ISORT(I+1)
          CALL SBLINE(EYE,VERT(1,J),VERT(1,K),ICOL,.FALSE.)
  50    CONTINUE
        CALL SBLINE(EYE,VERT(1,K),VERT(1,ISORT(1)),ICOL,.FALSE.)
      ENDIF
      END SUBROUTINE SBSLC2

      SUBROUTINE SBSLC3(DENS,N1,N2,N3,X,Y,Z,BAS,DLOW,DCOL,COLOUR)
C     -----------------------------------------------------------
C
      REAL DENS(0:N1,0:N2,0:N3),BAS(3,*)
      DATA RMIN,RMAX /0.00001,0.99999/
C
      XI=MIN(MAX(X*BAS(1,1)+Y*BAS(2,1)+Z*BAS(3,1),RMIN),RMAX)*FLOAT(N1)
      YJ=MIN(MAX(X*BAS(1,2)+Y*BAS(2,2)+Z*BAS(3,2),RMIN),RMAX)*FLOAT(N2)
      ZK=MIN(MAX(X*BAS(1,3)+Y*BAS(2,3)+Z*BAS(3,3),RMIN),RMAX)*FLOAT(N3)
      I=INT(XI)
      J=INT(YJ)
      K=INT(ZK)
      II=I+1
      JJ=J+1
      KK=K+1
      DX=XI-FLOAT(I)
      DY=YJ-FLOAT(J)
      DZ=ZK-FLOAT(K)
      D1=(1.0-DX)*(DENS(I,J,K)+DY*(DENS(I,JJ,K)-DENS(I,J,K)))
     *       +DX*(DENS(II,J,K)+DY*(DENS(II,JJ,K)-DENS(II,J,K)))
      D2=(1.0-DX)*(DENS(I,J,KK)+DY*(DENS(I,JJ,KK)-DENS(I,J,KK)))
     *       +DX*(DENS(II,J,KK)+DY*(DENS(II,JJ,KK)-DENS(II,J,KK)))
      COLOUR=MIN(MAX((D1+DZ*(D2-D1)-DLOW)*DCOL,RMIN),RMAX)
      END SUBROUTINE SBSLC3

      SUBROUTINE SBSURF(EYE,LATICE,DENS,N1,N2,N3,DSURF,IC1,IC2,LIGHT,
     *                  LSHINE)
C     ---------------------------------------------------------------
C
      REAL             EYE(*),LATICE(3,*),DENS(0:N1,0:N2,0:N3),LIGHT(*)
      LOGICAL          LSHINE
C
      REAL*8           XLNORM,PNEYE(3),DSMAL2
      REAL             BAS(3,3),MTRX
      REAL             XYZ(3),DXYZ(3,3),FRCXYZ(12),DDXYZ(3,12,2)
      REAL             DLOCAL(8),VERT(3,12),GRDSCL(3)
      LOGICAL          LPS,LCOLOR,LEMPTY
      INTEGER          IVERT(8)
      COMMON  /SRFCOM/ GRDCUB(3,8),MTRX(3,3),ORIG(3),XL2,COL0,COLSCL
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      This subroutine plots an iso-surface through a unit-cell of
C    density. All (x,y,z) values are taken to be given in world 
C    coordinates. The z-component of the eye-poisition should be 
C    positive and that of all the lattice-vertices should be negative; 
C    the viewing-screen is fixed at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    LATICE   R*4    I     3 x 4    (x,y,z) coordinates of the origin
C                                   and the a, b & C lattice-vertices.
C    DENS     R*4    I     (N1+1)   The density at regular points within
C                        x (N2+1)   the unit cell, wrapped around so
C                        x (N3+1)   that DENS(0,J,K)=DENS(N1,J,K) etc..
C    N1,N2,N3 I*4    I       -      The dimensions of the unit-cell grid.
C    DSURF    R*4    I       -      Density for the iso-surface.
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for the shading.
C    LIGHT    R*4    I       3      (x,y,z) direction of flood-light.
C    LSHINE   L*1    I       -      Shiny surface if TRUE, else diffuse.
C
C Globals 
C    SFTBUF
C    SRFCOM
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     SBSRF0     A quick check in case there are no iso-surafces.
C     SBSRF1     Anlayses a 2-d box in the surface of the unit-cell.
C     SBSRF2     Paints a 2-d box in the surface of the unit-cell.
C     SBSRF3     Analyses a 3-d box within the unit-cell.
C     SBSRF4     Initialises the gradients for a 3-d box.
C     SBSRF5     Breaks up the iso-surface in a 3-d box into triangles.
C     SBSRF6     Paints a triangular patch of an iso-surface.
C
C History
C   D. S. Sivia       3 May 1995  Initial release.
C   D. S. Sivia       7 Jul 1995  Fixed bug in determinant calculation.
C   D. S. Sivia      20 Oct 1995  Speeded up computations slightly.
C   D. S. Sivia      13 Dec 1995  A bit more tinkering for speed.
C   D. S. Sivia      14 Jun 1996  Completely new algorithm!
C   D. S. Sivia      24 Oct 1997 "Safe-guarded" some rounding errors.
C-----------------------------------------------------------------------
C
C Carry out some initial checks.
C
      SMALL=1.0E-10
      SMALL2=SMALL**2
      DSMAL2=DBLE(SMALL2)
      IF (EYE(3).LE.SMALL) RETURN
      IF (N1.LT.1 .OR. N2.LT.1 .OR. N3.LT.1) RETURN
      XL2=LIGHT(1)**2+LIGHT(2)**2+LIGHT(3)**2
      IF (XL2.LT.SMALL) RETURN
      IF (LATICE(3,1).GE.0.0) RETURN
      ZFAR=LATICE(3,2)+LATICE(3,3)+LATICE(3,4)-2.0*LATICE(3,1)
      IF (ZFAR.GE.0.0) RETURN
      DO 10 J=1,3
        IF (LATICE(3,J+1).GE.0.0) RETURN
        BAS(1,J)=LATICE(1,J+1)-LATICE(1,1)
        BAS(2,J)=LATICE(2,J+1)-LATICE(2,1)
        BAS(3,J)=LATICE(3,J+1)-LATICE(3,1)
        IF ((ZFAR-BAS(3,J)).GE.0.0) RETURN
        BAS2J=BAS(1,J)**2+BAS(2,J)**2+BAS(3,J)**2
        IF (BAS2J.LT.SMALL2) RETURN
  10  CONTINUE
      NTOT=(N1+1)*(N2+1)*(N3+1)
      CALL SBSRF0(DENS,NTOT,DSURF,LEMPTY)
      IF (LEMPTY) RETURN
C
C Set up matrix for real-space to lattice-index transformation.
C
      XN1=0.99999*FLOAT(N1)
      XN2=0.99999*FLOAT(N2)
      XN3=0.99999*FLOAT(N3)
      DET=BAS(1,1)*BAS(2,2)*BAS(3,3)+BAS(1,2)*BAS(2,3)*BAS(3,1)
     *   +BAS(1,3)*BAS(2,1)*BAS(3,2)-BAS(3,1)*BAS(2,2)*BAS(1,3)
     *   -BAS(3,2)*BAS(2,3)*BAS(1,1)-BAS(3,3)*BAS(2,1)*BAS(1,2)
      IF (ABS(DET).LT.SMALL2) RETURN
      DETNRM=1.0/DET
      MTRX(1,1)=XN1*DETNRM*(BAS(2,2)*BAS(3,3)-BAS(2,3)*BAS(3,2))
      MTRX(1,2)=XN2*DETNRM*(BAS(2,3)*BAS(3,1)-BAS(2,1)*BAS(3,3))
      MTRX(1,3)=XN3*DETNRM*(BAS(2,1)*BAS(3,2)-BAS(2,2)*BAS(3,1))
      MTRX(2,1)=XN1*DETNRM*(BAS(3,2)*BAS(1,3)-BAS(3,3)*BAS(1,2))
      MTRX(2,2)=XN2*DETNRM*(BAS(3,3)*BAS(1,1)-BAS(3,1)*BAS(1,3))
      MTRX(2,3)=XN3*DETNRM*(BAS(3,1)*BAS(1,2)-BAS(3,2)*BAS(1,1))
      MTRX(3,1)=XN1*DETNRM*(BAS(1,2)*BAS(2,3)-BAS(1,3)*BAS(2,2))
      MTRX(3,2)=XN2*DETNRM*(BAS(1,3)*BAS(2,1)-BAS(1,1)*BAS(2,3))
      MTRX(3,3)=XN3*DETNRM*(BAS(1,1)*BAS(2,2)-BAS(1,2)*BAS(2,1))
      CALL SBRCOP(LATICE,ORIG,3)
C
C Some general initialisations.
C
      DDSURF=MAX(ABS(DSURF),SMALL)
      IF (DSURF.LT.0.0) DDSURF=-DDSURF
      GRDSCL(1)=-0.5/(DDSURF*FLOAT(N1))
      GRDSCL(2)=-0.5/(DDSURF*FLOAT(N2))
      GRDSCL(3)=-0.5/(DDSURF*FLOAT(N3))
      COL0=FLOAT(IC1)
      COLSCL=FLOAT(IC2-IC1)
      DO 30 I=1,3
        DXYZ(I,1)=BAS(I,1)/FLOAT(N1)
        DXYZ(I,2)=BAS(I,2)/FLOAT(N2)
        DXYZ(I,3)=BAS(I,3)/FLOAT(N3)
        DDXYZ(I,1,1)=0.0
        DDXYZ(I,1,2)=DXYZ(I,1)
        DDXYZ(I,2,1)=DDXYZ(I,1,1)+DDXYZ(I,1,2)
        DDXYZ(I,2,2)=DXYZ(I,2)
        DDXYZ(I,3,1)=DDXYZ(I,2,1)+DDXYZ(I,2,2)
        DDXYZ(I,3,2)=-DXYZ(I,1)
        DDXYZ(I,4,1)=DDXYZ(I,3,1)+DDXYZ(I,3,2)
        DDXYZ(I,4,2)=-DXYZ(I,2)
        DO 20 J=1,4
          DDXYZ(I,J+4,1)=DDXYZ(I,J,1)
          DDXYZ(I,J+4,2)=DXYZ(I,3)
          DDXYZ(I,J+8,1)=DDXYZ(I,J,1)+DXYZ(I,3)
          DDXYZ(I,J+8,2)=DDXYZ(I,J,2)
  20    CONTINUE
  30  CONTINUE
C
C First paint the edges of the lattice.
C
      DO 60 IFACE=1,3
        I=IFACE
        J=MOD(IFACE,3)+1
        K=MOD(J,3)+1
        IF (IFACE.EQ.1) THEN
          IN=N1
          JN=N2
        ELSEIF (IFACE.EQ.2) THEN
          IN=N2
          JN=N3
        ELSE
          IN=N3
          JN=N1
        ENDIF
        KK=0
        XN=BAS(2,J)*BAS(3,I)-BAS(2,I)*BAS(3,J)
        YN=BAS(3,J)*BAS(1,I)-BAS(3,I)*BAS(1,J)
        ZN=BAS(1,J)*BAS(2,I)-BAS(1,I)*BAS(2,J)
        DNRM=SQRT(XN**2+YN**2+ZN**2+SMALL2)
        PNEYE(1)=DBLE(EYE(1)-0.5*(LATICE(1,I+1)+LATICE(1,J+1)))
        PNEYE(2)=DBLE(EYE(2)-0.5*(LATICE(2,I+1)+LATICE(2,J+1)))
        PNEYE(3)=DBLE(EYE(3)-0.5*(LATICE(3,I+1)+LATICE(3,J+1)))
        DEYE=SNGL(SQRT(PNEYE(1)**2+PNEYE(2)**2+PNEYE(3)**2+DSMAL2))
        XLNORM=DBLE(XN)*PNEYE(1)+DBLE(YN)*PNEYE(2)+DBLE(ZN)*PNEYE(3)
        COSSEE=SNGL(XLNORM)/(DEYE*DNRM)
        IF (COSSEE.LT.0.001) THEN
          KK=N3
          IF (IFACE.EQ.2) KK=N1
          IF (IFACE.EQ.3) KK=N2
          PNEYE(1)=PNEYE(1)+DBLE(BAS(1,K))
          PNEYE(2)=PNEYE(2)+DBLE(BAS(2,K))
          PNEYE(3)=PNEYE(3)+DBLE(BAS(3,K))
          DEYE=SNGL(SQRT(PNEYE(1)**2+PNEYE(2)**2+PNEYE(3)**2+DSMAL2))
          XLNORM=DBLE(XN)*PNEYE(1)+DBLE(YN)*PNEYE(2)+DBLE(ZN)*PNEYE(3)
          COSSEE=-SNGL(XLNORM)/(DEYE*DNRM)
        ENDIF
        IF (COSSEE.GT.0.001) THEN
          XYZ1=FLOAT(KK)*DXYZ(1,K)+LATICE(1,1)
          XYZ2=FLOAT(KK)*DXYZ(2,K)+LATICE(2,1)
          XYZ3=FLOAT(KK)*DXYZ(3,K)+LATICE(3,1)
          DO 50 J1=1,JN
            J0=J1-1
            DO 40 I1=1,IN
              I0=I1-1
              IF (IFACE.EQ.1) THEN
                DLOCAL(1)=DENS(I0,J0,KK)-DSURF
                DLOCAL(2)=DENS(I1,J0,KK)-DSURF
                DLOCAL(3)=DENS(I1,J1,KK)-DSURF
                DLOCAL(4)=DENS(I0,J1,KK)-DSURF
              ELSEIF (IFACE.EQ.2) THEN
                DLOCAL(1)=DENS(KK,I0,J0)-DSURF
                DLOCAL(2)=DENS(KK,I1,J0)-DSURF
                DLOCAL(3)=DENS(KK,I1,J1)-DSURF
                DLOCAL(4)=DENS(KK,I0,J1)-DSURF
              ELSE
                DLOCAL(1)=DENS(J0,KK,I0)-DSURF
                DLOCAL(2)=DENS(J0,KK,I1)-DSURF
                DLOCAL(3)=DENS(J1,KK,I1)-DSURF
                DLOCAL(4)=DENS(J1,KK,I0)-DSURF
              ENDIF
              CALL SBSRF1(DLOCAL,IBSIDE,FRCXYZ)
              IF (IBSIDE.NE.0) THEN
                XYZ(1)=XYZ1+DXYZ(1,I)*FLOAT(I0)
                XYZ(2)=XYZ2+DXYZ(2,I)*FLOAT(I0)
                XYZ(3)=XYZ3+DXYZ(3,I)*FLOAT(I0)
                CALL SBSRF2(XYZ,DXYZ(1,I),DXYZ(1,J),IBSIDE,FRCXYZ,VERT,
     *                      EYE,LIGHT,LSHINE)
              ENDIF
  40        CONTINUE
            XYZ1=XYZ1+DXYZ(1,J)
            XYZ2=XYZ2+DXYZ(2,J)
            XYZ3=XYZ3+DXYZ(3,J)
  50      CONTINUE
        ENDIF
  60  CONTINUE
C
C Step through each "cube" in the lattice, and paint any isosurfaces
C found therein.
C
      X00K=LATICE(1,1)
      Y00K=LATICE(2,1)
      Z00K=LATICE(3,1)
      DO 90 K1=1,N3
        K0=K1-1
        DO 80 J1=1,N2
          J0=J1-1
          X0JK=X00K+DXYZ(1,2)*FLOAT(J0)
          Y0JK=Y00K+DXYZ(2,2)*FLOAT(J0)
          Z0JK=Z00K+DXYZ(3,2)*FLOAT(J0)
          DO 70 I1=1,N1
            I0=I1-1
            DLOCAL(1)=DENS(I0,J0,K0)-DSURF
            DLOCAL(2)=DENS(I1,J0,K0)-DSURF
            DLOCAL(3)=DENS(I1,J1,K0)-DSURF
            DLOCAL(4)=DENS(I0,J1,K0)-DSURF
            DLOCAL(5)=DENS(I0,J0,K1)-DSURF
            DLOCAL(6)=DENS(I1,J0,K1)-DSURF
            DLOCAL(7)=DENS(I1,J1,K1)-DSURF
            DLOCAL(8)=DENS(I0,J1,K1)-DSURF
            CALL SBSRF3(DLOCAL,IVERT,FRCXYZ,ISUMV,ISUMF)
            IF (ISUMV.NE.0) THEN
              XYZ(1)=X0JK+DXYZ(1,1)*FLOAT(I0)
              XYZ(2)=Y0JK+DXYZ(2,1)*FLOAT(I0)
              XYZ(3)=Z0JK+DXYZ(3,1)*FLOAT(I0)
              CALL SBSRF4(DENS,N1,N2,N3,I0,J0,K0,GRDSCL,BAS,GRDCUB)
              CALL SBSRF5(XYZ,DDXYZ,ISUMV,ISUMF,IVERT,FRCXYZ,VERT,EYE,
     *                    LIGHT,LSHINE)
            ENDIF
  70      CONTINUE
  80    CONTINUE
        X00K=X00K+DXYZ(1,3)
        Y00K=Y00K+DXYZ(2,3)
        Z00K=Z00K+DXYZ(3,3)
  90  CONTINUE
      END SUBROUTINE SBSURF

      SUBROUTINE SBSRF0(DENS,NTOT,DSURF,LEMPTY)
C     -----------------------------------------
C
      REAL    DENS(*)
      LOGICAL LEMPTY
C
      LEMPTY=.TRUE.
      DO 10 I=1,NTOT
        IF (DENS(I).GT.DSURF) THEN
          LEMPTY=.FALSE.
          RETURN
        ENDIF
  10  CONTINUE
      END SUBROUTINE SBSRF0
      SUBROUTINE SBSRF1(D,IB,DF)
C     --------------------------
C
      REAL D(*),DF(*)
      DATA SMALL /1.0E-20/
C
      IB=0
      IF (D(1).GE.0.0) IB=1
      IF (D(2).GE.0.0) IB=IB+2
      IF (D(3).GE.0.0) IB=IB+4
      IF (D(4).GE.0.0) IB=IB+8
      IF (IB.EQ.0 .OR. IB.EQ.15) RETURN
      DO 10 I=1,4
        J=1+MOD(I,4)
        IF (D(I)*D(J).LT.-SMALL) THEN
          DI=ABS(D(I))
          DF(I)=DI/(DI+ABS(D(J)))
        ENDIF
  10  CONTINUE
      END SUBROUTINE SBSRF1

      SUBROUTINE SBSRF2(XYZ,D1,D2,IB,FRC,VERT,EYE,LIGHT,LSHINE)
C     ---------------------------------------------------------
C
      REAL    XYZ(*),D1(*),D2(*),FRC(*),VERT(3,*),EYE(*),LIGHT(*)
      LOGICAL LSHINE
C
      IF (IB.EQ.15) THEN
        DO 10 I=1,3
          VERT(I,1)=XYZ(I)
          VERT(I,2)=XYZ(I)+D1(I)
          VERT(I,3)=VERT(I,2)+D2(I)
          VERT(I,4)=XYZ(I)+D2(I)
  10    CONTINUE
        CALL SBSRF6(EYE,4,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.1) THEN
        DO 20 I=1,3
          VERT(I,1)=XYZ(I)
          VERT(I,2)=VERT(I,1)+FRC(1)*D1(I)
          VERT(I,3)=XYZ(I)+(1.0-FRC(4))*D2(I)
  20    CONTINUE
        CALL SBSRF6(EYE,3,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.2) THEN
        DO 30 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)
          VERT(I,2)=VERT(I,1)+FRC(2)*D2(I)
          VERT(I,3)=XYZ(I)+FRC(1)*D1(I)
  30    CONTINUE
        CALL SBSRF6(EYE,3,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.4) THEN
        DO 40 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)+D2(I)
          VERT(I,2)=VERT(I,1)-FRC(3)*D1(I)
          VERT(I,3)=VERT(I,1)-(1.0-FRC(2))*D2(I)
  40    CONTINUE
        CALL SBSRF6(EYE,3,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.8) THEN
        DO 50 I=1,3
          VERT(I,1)=XYZ(I)+D2(I)
          VERT(I,2)=VERT(I,1)-FRC(4)*D2(I)
          VERT(I,3)=VERT(I,1)+(1.0-FRC(3))*D1(I)
  50    CONTINUE
        CALL SBSRF6(EYE,3,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.7) THEN
        DO 60 I=1,3
          VERT(I,1)=XYZ(I)
          VERT(I,2)=VERT(I,1)+D1(I)
          VERT(I,3)=VERT(I,2)+D2(I)
          VERT(I,4)=VERT(I,3)-FRC(3)*D1(I)
          VERT(I,5)=XYZ(I)+(1.0-FRC(4))*D2(I)
  60    CONTINUE
        CALL SBSRF6(EYE,5,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.14) THEN
        DO 70 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)
          VERT(I,2)=VERT(I,1)+D2(I)
          VERT(I,3)=XYZ(I)+D2(I)
          VERT(I,4)=XYZ(I)+(1.0-FRC(4))*D2(I)
          VERT(I,5)=XYZ(I)+FRC(1)*D1(I)
  70    CONTINUE
        CALL SBSRF6(EYE,5,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.13) THEN
        DO 80 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)+D2(I)
          VERT(I,2)=XYZ(I)+D2(I)
          VERT(I,3)=XYZ(I)
          VERT(I,4)=XYZ(I)+FRC(1)*D1(I)
          VERT(I,5)=XYZ(I)+D1(I)+FRC(2)*D2(I)
  80    CONTINUE
        CALL SBSRF6(EYE,5,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.11) THEN
        DO 90 I=1,3
          VERT(I,1)=XYZ(I)+D2(I)
          VERT(I,2)=XYZ(I)
          VERT(I,3)=XYZ(I)+D1(I)
          VERT(I,4)=VERT(I,3)+FRC(2)*D2(I)
          VERT(I,5)=VERT(I,1)+(1.0-FRC(3))*D1(I)
  90    CONTINUE
        CALL SBSRF6(EYE,5,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.3) THEN
        DO 100 I=1,3
          VERT(I,1)=XYZ(I)
          VERT(I,2)=XYZ(I)+D1(I)
          VERT(I,3)=VERT(I,2)+FRC(2)*D2(I)
          VERT(I,4)=XYZ(I)+(1.0-FRC(4))*D2(I)
 100    CONTINUE
        CALL SBSRF6(EYE,4,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.6) THEN
        DO 110 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)
          VERT(I,2)=VERT(I,1)+D2(I)
          VERT(I,3)=VERT(I,2)-FRC(3)*D1(I)
          VERT(I,4)=XYZ(I)+FRC(1)*D1(I)
 110    CONTINUE
        CALL SBSRF6(EYE,4,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.12) THEN
        DO 120 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)+D2(I)
          VERT(I,2)=XYZ(I)+D2(I)
          VERT(I,3)=VERT(I,2)-FRC(4)*D2(I)
          VERT(I,4)=XYZ(I)+D1(I)+FRC(2)*D2(I)
 120    CONTINUE
        CALL SBSRF6(EYE,4,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.9) THEN
        DO 130 I=1,3
          VERT(I,1)=XYZ(I)+D2(I)
          VERT(I,2)=XYZ(I)
          VERT(I,3)=XYZ(I)+FRC(1)*D1(I)
          VERT(I,4)=VERT(I,1)+(1.0-FRC(3))*D1(I)
 130    CONTINUE
        CALL SBSRF6(EYE,4,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.5) THEN
        DO 140 I=1,3
          VERT(I,1)=XYZ(I)
          VERT(I,2)=VERT(I,1)+FRC(1)*D1(I)
          VERT(I,3)=XYZ(I)+(1.0-FRC(4))*D2(I)
          VERT(I,4)=XYZ(I)+D1(I)+D2(I)
          VERT(I,5)=VERT(I,4)-FRC(3)*D1(I)
          VERT(I,6)=VERT(I,4)-(1.0-FRC(2))*D2(I)
 140    CONTINUE
        CALL SBSRF6(EYE,3,VERT,LSHINE,LIGHT,0) 
        CALL SBSRF6(EYE,3,VERT(1,4),LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.10) THEN
        DO 150 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)
          VERT(I,2)=VERT(I,1)+FRC(2)*D2(I)
          VERT(I,3)=XYZ(I)+FRC(1)*D1(I)
          VERT(I,4)=XYZ(I)+D2(I)
          VERT(I,5)=VERT(I,4)-FRC(4)*D2(I)
          VERT(I,6)=VERT(I,4)+(1.0-FRC(3))*D1(I)
 150    CONTINUE
        CALL SBSRF6(EYE,3,VERT,LSHINE,LIGHT,0) 
        CALL SBSRF6(EYE,3,VERT(1,4),LSHINE,LIGHT,0) 
      ENDIF
      END SUBROUTINE SBSRF2

      SUBROUTINE SBSRF3(D,IVERT,DF,ISUMV,ISUMF)
C     -----------------------------------------
C
      REAL    D(*),DF(*)
      INTEGER IVERT(*),IC(8)
      DATA    SMALL /1.0E-20/
C
      ISUMV=0
      DO 10 I=1,8
        IF (D(I).LT.0.0) THEN
          IC(I)=0
        ELSE
          IC(I)=1
          ISUMV=ISUMV+1
        ENDIF
  10  CONTINUE
      IF (ISUMV.EQ.0 .OR. ISUMV.EQ.8) THEN
        ISUMV=0
        RETURN
      ENDIF
      IF (ISUMV.GT.4) THEN
        ISUMV=8-ISUMV
        DO 20 I=1,8
  20      IC(I)=MOD(IC(I)+1,2)
      ENDIF
      J=0
      DO 30 I=1,8
        IF (IC(I).EQ.1) THEN
          J=J+1
          IVERT(J)=I
        ENDIF
  30  CONTINUE
      ISUMF=0
      DO 40 I=1,4
        J=1+MOD(I,4)
        IF (D(I)*D(J).LT.-SMALL) THEN
          DI=ABS(D(I))
          DF(I)=DI/(DI+ABS(D(J)))
          ISUMF=ISUMF+1
        ENDIF
        K=I+4
        IF (D(I)*D(K).LT.-SMALL) THEN
          DI=ABS(D(I))
          DF(K)=DI/(DI+ABS(D(K)))
          ISUMF=ISUMF+1
        ENDIF
        L=J+4
        IF (D(K)*D(L).LT.-SMALL) THEN
          DK=ABS(D(K))
          DF(I+8)=DK/(DK+ABS(D(L)))
          ISUMF=ISUMF+1
        ENDIF
  40  CONTINUE
      END SUBROUTINE SBSRF3

      SUBROUTINE SBSRF4(DENS,N1,N2,N3,I0,J0,K0,GRDSCL,BAS,GRD)
C     --------------------------------------------------------
C
      REAL DENS(0:N1,0:N2,0:N3),GRDSCL(*),BAS(3,*),GRD(3,*)
      REAL G(3,8)
C
      IM=I0-1
      IF (IM.LT.0) IM=N1
      JM=J0-1
      IF (JM.LT.0) JM=N2
      KM=K0-1
      IF (KM.LT.0) KM=N3
      I1=I0+1
      J1=J0+1
      K1=K0+1
      IP=I1+1
      IF (IP.GT.N1) IP=0
      JP=J1+1
      IF (JP.GT.N2) JP=0
      KP=K1+1
      IF (KP.GT.N3) KP=0
      G(1,1)=GRDSCL(1)*(DENS(I1,J0,K0)-DENS(IM,J0,K0))
      G(2,1)=GRDSCL(2)*(DENS(I0,J1,K0)-DENS(I0,JM,K0))
      G(3,1)=GRDSCL(3)*(DENS(I0,J0,K1)-DENS(I0,J0,KM))
      G(1,2)=GRDSCL(1)*(DENS(IP,J0,K0)-DENS(I0,J0,K0))
      G(2,2)=GRDSCL(2)*(DENS(I1,J1,K0)-DENS(I1,JM,K0))
      G(3,2)=GRDSCL(3)*(DENS(I1,J0,K1)-DENS(I1,J0,KM))
      G(1,3)=GRDSCL(1)*(DENS(IP,J1,K0)-DENS(I0,J1,K0))
      G(2,3)=GRDSCL(2)*(DENS(I1,JP,K0)-DENS(I1,J0,K0))
      G(3,3)=GRDSCL(3)*(DENS(I1,J1,K1)-DENS(I1,J1,KM))
      G(1,4)=GRDSCL(1)*(DENS(I1,J1,K0)-DENS(IM,J1,K0))
      G(2,4)=GRDSCL(2)*(DENS(I0,JP,K0)-DENS(I0,J0,K0))
      G(3,4)=GRDSCL(3)*(DENS(I0,J1,K1)-DENS(I0,J1,KM))
      G(1,5)=GRDSCL(1)*(DENS(I1,J0,K1)-DENS(IM,J0,K1))
      G(2,5)=GRDSCL(2)*(DENS(I0,J1,K1)-DENS(I0,JM,K1))
      G(3,5)=GRDSCL(3)*(DENS(I0,J0,KP)-DENS(I0,J0,K0))
      G(1,6)=GRDSCL(1)*(DENS(IP,J0,K1)-DENS(I0,J0,K1))
      G(2,6)=GRDSCL(2)*(DENS(I1,J1,K1)-DENS(I1,JM,K1))
      G(3,6)=GRDSCL(3)*(DENS(I1,J0,KP)-DENS(I1,J0,K0))
      G(1,7)=GRDSCL(1)*(DENS(IP,J1,K1)-DENS(I0,J1,K1))
      G(2,7)=GRDSCL(2)*(DENS(I1,JP,K1)-DENS(I1,J0,K1))
      G(3,7)=GRDSCL(3)*(DENS(I1,J1,KP)-DENS(I1,J1,K0))
      G(1,8)=GRDSCL(1)*(DENS(I1,J1,K1)-DENS(IM,J1,K1))
      G(2,8)=GRDSCL(2)*(DENS(I0,JP,K1)-DENS(I0,J0,K1))
      G(3,8)=GRDSCL(3)*(DENS(I0,J1,KP)-DENS(I0,J1,K0))
      DO 20 J=1,8
        DO 10 I=1,3
  10      GRD(I,J)=G(1,J)*BAS(I,1)+G(2,J)*BAS(I,2)+G(3,J)*BAS(I,3)
  20  CONTINUE
      END SUBROUTINE SBSRF4

      SUBROUTINE SBSRF5(XYZ,DXYZ,ISV,ISF,IV,FRC,VERT,EYE,LIGHT,LSHINE)
C     ----------------------------------------------------------------
C
      REAL    XYZ(*),DXYZ(3,12,*),FRC(*),VERT(3,*),EYE(*),LIGHT(*)
      INTEGER IV(*),IV4MAP(12)
      LOGICAL LSHINE
      DATA    IV4MAP /12,8,4,3,11,7,6,2,10,9,5,1/
C
      IF (ISV.EQ.1) THEN
        CALL SBSF5A(XYZ,DXYZ,FRC,VERT,IV(1),EYE,LSHINE,LIGHT)
      ELSEIF (ISV.EQ.2) THEN
        IF (ISF.EQ.6) THEN
          CALL SBSF5A(XYZ,DXYZ,FRC,VERT,IV(1),EYE,LSHINE,LIGHT)
          CALL SBSF5A(XYZ,DXYZ,FRC,VERT,IV(2),EYE,LSHINE,LIGHT)
        ELSE
          IJDIF=IV(2)-IV(1)
          IF (IV(1).LE.4) THEN
            IF (IV(2).LE.4) THEN
              K2=IV(1)
              IF (IJDIF.EQ.3) K2=IV(2)
            ELSE
              K2=IV(2)
            ENDIF
          ELSE
            K2=IV(1)+4
            IF (IJDIF.EQ.3) K2=IV(2)+4
          ENDIF
          CALL SBSF5B(XYZ,DXYZ,FRC,VERT,K2,EYE,LSHINE,LIGHT,1)
        ENDIF
      ELSEIF (ISV.EQ.3) THEN
        IF (ISF.EQ.9) THEN
          DO 10 I=1,3
  10        CALL SBSF5A(XYZ,DXYZ,FRC,VERT,IV(I),EYE,LSHINE,LIGHT)
        ELSEIF (ISF.EQ.6) THEN
          DO 20 I1=1,3
            I2=1+MOD(I1,3)
            I=MIN(I1,I2)
            J=MAX(I1,I2)
            K2=0
            IJDIF=IV(J)-IV(I)
            IF (IV(I).LE.4) THEN
              IF (IV(J).LE.4) THEN
                IF (IJDIF.EQ.1) THEN
                  K2=IV(I)
                ELSEIF (IJDIF.EQ.3) THEN
                  K2=IV(J)
                ENDIF
              ELSE
                IF (IJDIF.EQ.4) K2=IV(J)
              ENDIF
            ELSE
              IF (IJDIF.EQ.1) THEN
                K2=IV(I)+4
              ELSEIF (IJDIF.EQ.3) THEN
                K2=IV(J)+4
              ENDIF
            ENDIF
            IF (K2.GT.0) GOTO 1
  20      CONTINUE
   1      CALL SBSF5B(XYZ,DXYZ,FRC,VERT,K2,EYE,LSHINE,LIGHT,1)
        ELSE
          K3=IV(1)+IV(2)+IV(3)-5+2*(IV(1)/5+2*(IV(2)/5)+IV(3)/5)
          CALL SBSF5C(XYZ,DXYZ,FRC,VERT,K3,EYE,LSHINE,LIGHT)
        ENDIF
      ELSE
        IF (ISF.EQ.12) THEN
          DO 30 I=1,4
  30        CALL SBSF5A(XYZ,DXYZ,FRC,VERT,IV(I),EYE,LSHINE,LIGHT)
        ELSEIF (ISF.EQ.4) THEN
          K4=(IV(1)+IV(2)+IV(3)+IV(4)-6)/4
          IF ((IV(2)-IV(1)).EQ.3) K4=6
          CALL SBSF5B(XYZ,DXYZ,FRC,VERT,K4,EYE,LSHINE,LIGHT,2)
        ELSEIF (ISF.EQ.6) THEN
          IF (IV(3).LE.4) THEN
            K3=IV(1)+IV(2)+IV(3)-6
            K4=MOD((IV(4)+K3),4)+3*K3
          ELSE
            IF (IV(2).GE.5) THEN
              K3=IV(2)+IV(3)+IV(4)-18
              K4=IV4MAP(MOD((IV(1)+K3),4)+3*K3)
            ELSE
              K4=12+IV(3)-IV(2)
              IF ((IV(1)+IV(2)+IV(3)+IV(4)).EQ.22) K4=29-K4
            ENDIF
          ENDIF
          CALL SBSF5D(XYZ,DXYZ,FRC,VERT,K4,EYE,LSHINE,LIGHT)
        ELSE
          K4=IV(1)+IV(2)+IV(3)+IV(4)
          IF (K4.EQ.16 .OR. K4.EQ.20) THEN          
            CALL SBSF5B(XYZ,DXYZ,FRC,VERT,IV(3),EYE,LSHINE,LIGHT,1)
            CALL SBSF5B(XYZ,DXYZ,FRC,VERT,IV(4),EYE,LSHINE,LIGHT,1)
          ELSEIF (K4.EQ.18) THEN
            K4A=IV(1)
            IF ((IV(2)-K4A).EQ.3) K4A=4
            K4B=9+MOD(K4A+1,4)
            CALL SBSF5B(XYZ,DXYZ,FRC,VERT,K4A,EYE,LSHINE,LIGHT,1)
            CALL SBSF5B(XYZ,DXYZ,FRC,VERT,K4B,EYE,LSHINE,LIGHT,1)
          ELSE
            IF (K4.EQ.14) THEN
              K4A=IV(4)
              K3=IV(1)+IV(2)+IV(3)-5+2*(IV(1)/5+2*(IV(2)/5)+IV(3)/5)
            ELSEIF (K4.EQ.22) THEN
              K4A=IV(1)
              K3=IV(2)+IV(3)+IV(4)-5+2*(IV(2)/5+2*(IV(3)/5)+IV(4)/5)
            ELSE
              IF (MOD((IV(1)+IV(2)),2).EQ.0) THEN
                IF (IV(4).EQ.6 .OR. (IV(3)-IV(2)).EQ.2) THEN
                  K4A=IV(2)
                  K3=IV(1)+IV(3)+IV(4)-5+2*(IV(1)/5+2*(IV(3)/5)+IV(4)/5)
                ELSE
                  K4A=IV(1)
                  K3=IV(2)+IV(3)+IV(4)-5+2*(IV(2)/5+2*(IV(3)/5)+IV(4)/5)
                ENDIF
              ELSE
                IF (IV(1).EQ.3 .OR. (IV(3)-IV(2)).EQ.2) THEN
                  K4A=IV(3)
                  K3=IV(1)+IV(2)+IV(4)-5+2*(IV(1)/5+2*(IV(2)/5)+IV(4)/5)
                ELSE
                  K4A=IV(4)
                  K3=IV(1)+IV(2)+IV(3)-5+2*(IV(1)/5+2*(IV(2)/5)+IV(3)/5)
                ENDIF
              ENDIF
            ENDIF
            CALL SBSF5A(XYZ,DXYZ,FRC,VERT,K4A,EYE,LSHINE,LIGHT)
            CALL SBSF5C(XYZ,DXYZ,FRC,VERT,K3,EYE,LSHINE,LIGHT)
          ENDIF
        ENDIF
      ENDIF
      END SUBROUTINE SBSRF5

      SUBROUTINE SBSF5A(XYZ,DXYZ,FRC,VERT,IV,EYE,LSHINE,LIGHT)
C     ---------------------------------------------------------
C
      REAL    XYZ(*),DXYZ(3,12,*),FRC(*),VERT(3,*),EYE(*),LIGHT(*)
      LOGICAL LSHINE
C
      IF (IV.LE.4) THEN
        J=IV
        K=1+MOD(IV+2,4)
        L=IV+4
      ELSE
        J=IV+4
        K=9+MOD(IV-2,4)
        L=IV
      ENDIF
      DO 10 I=1,3
        VERT(I,1)=XYZ(I)+DXYZ(I,J,1)+FRC(J)*DXYZ(I,J,2)
        VERT(I,2)=XYZ(I)+DXYZ(I,K,1)+FRC(K)*DXYZ(I,K,2)
        VERT(I,3)=XYZ(I)+DXYZ(I,L,1)+FRC(L)*DXYZ(I,L,2)
  10  CONTINUE
      CALL SBSRF6(EYE,3,VERT,LSHINE,LIGHT,1) 
      END SUBROUTINE SBSF5A

      SUBROUTINE SBSF5B(XYZ,DXYZ,FRC,VERT,KK,EYE,LSHINE,LIGHT,LL)
C     ------------------------------------------------------------
C
      REAL    XYZ(*),DXYZ(3,12,*),FRC(*),VERT(3,*),EYE(*),LIGHT(*)
      INTEGER IVL(4,12,2)
      LOGICAL LSHINE
      DATA    IVL /5,6,2,4,6,7,3,1,7,8,4,2,8,5,1,3,9,1,4,12,10,2,1,9,
     *     11,3,2,10,12,4,3,11,12,5,6,10,9,6,7,11,10,7,8,12,11,8,5,9,
     *     5,6,7,8,4,2,10,12,1,3,11,9,4,2,10,12,5,6,7,8,1,3,11,9,24*0/
C
      J=IVL(1,KK,LL)
      K=IVL(2,KK,LL)
      L=IVL(3,KK,LL)
      M=IVL(4,KK,LL)
      DO 10 I=1,3
        VERT(I,1)=XYZ(I)+DXYZ(I,J,1)+FRC(J)*DXYZ(I,J,2)
        VERT(I,2)=XYZ(I)+DXYZ(I,K,1)+FRC(K)*DXYZ(I,K,2)
        VERT(I,3)=XYZ(I)+DXYZ(I,L,1)+FRC(L)*DXYZ(I,L,2)
        VERT(I,4)=XYZ(I)+DXYZ(I,M,1)+FRC(M)*DXYZ(I,M,2)
        VERT(I,5)=VERT(I,1)
        VERT(I,6)=0.25*(VERT(I,1)+VERT(I,2)+VERT(I,3)+VERT(I,4))
  10  CONTINUE
      DO 20 I=1,4
        CALL SBRCOP(VERT(1,I),VERT(1,7),6)
        CALL SBSRF6(EYE,3,VERT(1,6),LSHINE,LIGHT,1)
  20  CONTINUE
      END SUBROUTINE SBSF5B

      SUBROUTINE SBSF5C(XYZ,DXYZ,FRC,VERT,K3,EYE,LSHINE,LIGHT)
C     ---------------------------------------------------------
C
      REAL    XYZ(*),DXYZ(3,12,*),FRC(*),VERT(3,*),EYE(*),LIGHT(*)
      INTEGER IV3(5,24)
      LOGICAL LSHINE
      DATA    IV3 /5,6,7,3,4,8,5,6,2,3,7,8,5,1,2,6,7,8,4,1,
     *             12,4,2,6,9,4,2,10,9,5,9,1,3,8,12,9,1,3,7,10,
     *             1,3,11,10,6,1,3,11,12,5,4,2,10,11,8,2,4,12,11,7,
     *             10,12,4,1,6,12,10,2,1,5,11,9,1,4,8,1,9,11,7,2,
     *             3,11,9,6,2,3,11,9,5,4,2,10,12,8,3,4,12,10,7,3,
     *             5,6,7,11,12,8,5,6,10,11,7,8,5,9,10,6,7,8,12,9/
C
      J=IV3(1,K3)
      K=IV3(2,K3)
      L=IV3(3,K3)
      M=IV3(4,K3)
      N=IV3(5,K3)
      DO 10 I=1,3
        VERT(I,1)=XYZ(I)+DXYZ(I,J,1)+FRC(J)*DXYZ(I,J,2)
        VERT(I,2)=XYZ(I)+DXYZ(I,K,1)+FRC(K)*DXYZ(I,K,2)
        VERT(I,3)=XYZ(I)+DXYZ(I,L,1)+FRC(L)*DXYZ(I,L,2)
        VERT(I,4)=XYZ(I)+DXYZ(I,M,1)+FRC(M)*DXYZ(I,M,2)
        VERT(I,5)=XYZ(I)+DXYZ(I,N,1)+FRC(N)*DXYZ(I,N,2)
        VERT(I,6)=VERT(I,1)
        VERT(I,7)=0.2*(VERT(I,1)+VERT(I,2)+VERT(I,3)+VERT(I,4)+
     *                 VERT(I,5))
  10  CONTINUE
      DO 20 I=1,5
        CALL SBRCOP(VERT(1,I),VERT(1,8),6)
        CALL SBSRF6(EYE,3,VERT(1,7),LSHINE,LIGHT,1)
  20  CONTINUE
      END SUBROUTINE SBSF5C

      SUBROUTINE SBSF5D(XYZ,DXYZ,FRC,VERT,K4,EYE,LSHINE,LIGHT)
C     ---------------------------------------------------------
C
      REAL    XYZ(*),DXYZ(3,12,*),FRC(*),VERT(3,*),EYE(*),LIGHT(*)
      INTEGER IV4(6,16)
      LOGICAL LSHINE
      DATA    IV4 /12,9,6,7,3,4,10,9,5,4,3,7,11,10,6,5,4,3,
     *             11,12,5,6,2,3,9,12,8,3,2,6,10,9,5,8,3,2,
     *             10,11,8,5,1,2,12,11,7,2,1,5,9,12,8,7,2,1,
     *             9,10,7,8,4,1,11,10,6,1,4,8,12,11,7,6,1,4,
     *             12,10,6,1,3,8,12,10,7,3,1,5,11,9,6,2,4,8,
     *             11,9,5,4,2,7/
      DATA    VNORM /0.1666666667/
C
      CALL SBRFIL(VERT(1,8),0.0,3)
      DO 20 J=1,6
        K=IV4(J,K4)
        DO 10 I=1,3
          VERT(I,J)=XYZ(I)+DXYZ(I,K,1)+FRC(K)*DXYZ(I,K,2)
          VERT(I,8)=VERT(I,8)+VERT(I,J)
  10    CONTINUE
  20  CONTINUE
      CALL SBRCOP(VERT,VERT(1,7),3)
      DO 30 I=1,3
  30    VERT(I,8)=VERT(I,8)*VNORM
      DO 40 I=1,6
        CALL SBRCOP(VERT(1,I),VERT(1,9),6)
        CALL SBSRF6(EYE,3,VERT(1,8),LSHINE,LIGHT,1)
  40  CONTINUE
      END SUBROUTINE SBSF5D

      SUBROUTINE SBSRF6(EYE,NV,VERT,LSHINE,LIGHT,INSIDE)
C     --------------------------------------------------
C
      REAL             EYE(*),VERT(3,*),LIGHT(*)
      LOGICAL          LSHINE
C
      REAL*8           XLNORM,ZZ,DZZ
      REAL             XW(20),YW(20),MTRX
      LOGICAL          LPS,LCOLOR
      COMMON  /SRFCOM/ GRDCUB(3,8),MTRX(3,3),ORIG(3),XL2,COL0,COLSCL
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
C
C Carry out some initial checks and calculate the coordinates of the 
C projected triangle.
C
      IF (NV.LT.3 .OR. NV.GT.10) RETURN
      SMALL=1.0E-10
      XMIN=+1.0E20
      XMAX=-1.0E20
      YMIN=+1.0E20
      YMAX=-1.0E20
      DO 10 I=1,NV
        CALL SBLIN1(EYE,VERT(1,I),VERT(2,I),VERT(3,I),XW(I),YW(I))
        IF (XW(I).LT.XMIN) THEN
          XMIN=XW(I)
          ILEFT=I
        ENDIF
        IF (YW(I).LT.YMIN) THEN
          YMIN=YW(I)
          JBOTOM=I
        ENDIF
        XMAX=MAX(XW(I),XMAX)
        YMAX=MAX(YW(I),YMAX)
  10  CONTINUE
      IF (XMIN.GE.XTRC .OR. XMAX.LE.XBLC) RETURN
      IF (YMIN.GE.YTRC .OR. YMAX.LE.YBLC) RETURN
C
C Find the outward normal seen by the eye.
C
      AX=VERT(1,2)-VERT(1,1)
      AY=VERT(2,2)-VERT(2,1)
      AZ=VERT(3,2)-VERT(3,1)
      BX=VERT(1,1)-VERT(1,NV)
      BY=VERT(2,1)-VERT(2,NV)
      BZ=VERT(3,1)-VERT(3,NV)
      XN=BY*AZ-AY*BZ
      YN=BZ*AX-AZ*BX
      ZN=BX*AY-AX*BY
      TEN=XN*(EYE(1)-VERT(1,1))+YN*(EYE(2)-VERT(2,1))
     *   +ZN*(EYE(3)-VERT(3,1))
      IF (TEN.LT.0.0) THEN
        XN=-XN
        YN=-YN
        ZN=-ZN
        TEN=-TEN
      ENDIF
C
C Plot the projected triangle.
C
      XLNORM=DBLE(TEN)
      EYENRM=XN*EYE(1)+YN*EYE(2)+ZN*EYE(3)
      DX=FLOAT(NXP-1)/(XTRC-XBLC)
      DY=FLOAT(NYP-1)/(YTRC-YBLC)
      DYJ=1.0/DY
      DXI=1.0/DX
      SAFER=0.0001
      IF ((XMAX-XMIN).GT.(YMAX-YMIN)) THEN
        JYMIN=INT((YMIN-YBLC)*DY)+2
        JYMAX=MIN(INT((YMAX-YBLC)*DY)+1,NYP)
        IF (JYMIN.GT.JYMAX) RETURN
        YJ=YBLC+(FLOAT(JYMIN-1)+SAFER)*DYJ
        NVL2=JBOTOM
        NVR2=JBOTOM
        J1=JYMIN
        DO 40 IVERT=1,NV
          IF (YJ.GT.YW(NVL2)) THEN
   1        NVL1=NVL2
            NVL2=NVL1-1
            IF (NVL2.LT.1) NVL2=NV
            IF (NVL2.EQ.JBOTOM) RETURN
            IF (YJ.GT.YW(NVL2)) GOTO 1
            YDIFL=YW(NVL2)-YW(NVL1)
            IF (ABS(YDIFL).LT.SMALL) YDIFL=SMALL
            GRADL=(XW(NVL2)-XW(NVL1))/YDIFL
          ENDIF
          IF (YJ.GT.YW(NVR2)) THEN
   2        NVR1=NVR2
            NVR2=NVR1+1
            IF (NVR2.GT.NV) NVR2=1
            IF (NVR2.EQ.JBOTOM) RETURN
            IF (YJ.GT.YW(NVR2)) GOTO 2
            YDIFR=YW(NVR2)-YW(NVR1)
            IF (ABS(YDIFR).LT.SMALL) YDIFR=SMALL
            GRADR=(XW(NVR2)-XW(NVR1))/YDIFR
          ENDIF
          IF (YW(NVL2).LT.YW(NVR2)) THEN
            J2=MIN(INT((YW(NVL2)-YBLC)*DY)+1,JYMAX)
          ELSE
            J2=MIN(INT((YW(NVR2)-YBLC)*DY)+1,JYMAX)
          ENDIF
          DO 30 J=J1,J2
            IF (J.GE.1) THEN
              XL=XW(NVL1)+GRADL*(YJ-YW(NVL1))
              XR=XW(NVR1)+GRADR*(YJ-YW(NVR1))
              ISTEP=1
              IX1=MAX(INT((XL-XBLC)*DX)+2,1)
              IX2=MIN(INT((XR-XBLC)*DX)+1,NXP)
              IF (IX1.GT.IX2) THEN
                ISTEP=-1
                IX1=MIN(IX1-1,NXP)
                IX2=MAX(IX2+1,1)
              ENDIF
              XI=XBLC+FLOAT(IX1-1)*DXI
              SDXI=FLOAT(ISTEP)*DXI
              DZZ=DBLE(SDXI*XN)
              ZZ=DBLE(EYENRM-XI*XN-YJ*YN)
              K=(J-1)*NXP+IX1
              DO 20 I=IX1,IX2,ISTEP
                XLAMDA=SNGL(XLNORM/ZZ)
                Z=EYE(3)*(1.0-XLAMDA)
                IF (Z.GT.SBBUFF(K)) THEN
                  SBBUFF(K)=Z
                  X=EYE(1)+XLAMDA*(XI-EYE(1))
                  Y=EYE(2)+XLAMDA*(YJ-EYE(2))
                  IF (INSIDE.EQ.0) THEN
                    GX=XN
                    GY=YN
                    GZ=ZN
                  ELSE
                    CALL SBSF6A(X,Y,Z,ORIG,MTRX,GRDCUB,GX,GY,GZ)
                  ENDIF
                  CALL SBSF6B(EYE,X,Y,Z,GX,GY,GZ,LIGHT,XL2,LSHINE,CLR)
                  SBBUFF(KSTART+K)=COL0+COLSCL*CLR
                ENDIF
                XI=XI+SDXI
                ZZ=ZZ-DZZ
                K=K+ISTEP
  20          CONTINUE
            ENDIF
            YJ=YJ+DYJ
  30      CONTINUE
          J1=J2+1
          IF (J1.GT.JYMAX) RETURN
  40    CONTINUE
      ELSE
        IXMIN=INT((XMIN-XBLC)*DX)+2
        IXMAX=MIN(INT((XMAX-XBLC)*DX)+1,NXP)
        IF (IXMIN.GT.IXMAX) RETURN
        XI=XBLC+(FLOAT(IXMIN-1)+SAFER)*DXI
        NVL2=ILEFT
        NVR2=ILEFT
        I1=IXMIN
        DO 70 IVERT=1,NV
          IF (XI.GT.XW(NVL2)) THEN
   3        NVL1=NVL2
            NVL2=NVL1-1
            IF (NVL2.LT.1) NVL2=NV
            IF (NVL2.EQ.ILEFT) RETURN
            IF (XI.GT.XW(NVL2)) GOTO 3
            XDIFL=XW(NVL2)-XW(NVL1)
            IF (ABS(XDIFL).LT.SMALL) XDIFL=SMALL
            GRADL=(YW(NVL2)-YW(NVL1))/XDIFL
          ENDIF
          IF (XI.GT.XW(NVR2)) THEN
   4        NVR1=NVR2
            NVR2=NVR1+1
            IF (NVR2.GT.NV) NVR2=1
            IF (NVR2.EQ.ILEFT) RETURN
            IF (XI.GT.XW(NVR2)) GOTO 4
            XDIFR=XW(NVR2)-XW(NVR1)
            IF (ABS(XDIFR).LT.SMALL) XDIFR=SMALL
            GRADR=(YW(NVR2)-YW(NVR1))/XDIFR
          ENDIF
          IF (XW(NVL2).LT.XW(NVR2)) THEN
            I2=MIN(INT((XW(NVL2)-XBLC)*DX)+1,IXMAX)
          ELSE
            I2=MIN(INT((XW(NVR2)-XBLC)*DX)+1,IXMAX)
          ENDIF
          DO 60 I=I1,I2
            IF (I.GE.1) THEN
              YL=YW(NVL1)+GRADL*(XI-XW(NVL1))
              YR=YW(NVR1)+GRADR*(XI-XW(NVR1))
              ISTEP=1
              JY1=MAX(INT((YL-YBLC)*DY)+2,1)
              JY2=MIN(INT((YR-YBLC)*DY)+1,NYP)
              IF (JY1.GT.JY2) THEN
                ISTEP=-1
                JY1=MIN(JY1-1,NYP)
                JY2=MAX(JY2+1,1)
              ENDIF
              YJ=YBLC+FLOAT(JY1-1)*DYJ
              SDYJ=FLOAT(ISTEP)*DYJ
              DZZ=DBLE(SDYJ*YN)
              ZZ=DBLE(EYENRM-YJ*YN-XI*XN)
              K=(JY1-1)*NXP+I
              KSTEP=ISTEP*NXP
              DO 50 J=JY1,JY2,ISTEP
                XLAMDA=SNGL(XLNORM/ZZ)
                Z=EYE(3)*(1.0-XLAMDA)
                IF (Z.GT.SBBUFF(K)) THEN
                  SBBUFF(K)=Z
                  X=EYE(1)+XLAMDA*(XI-EYE(1))
                  Y=EYE(2)+XLAMDA*(YJ-EYE(2))
                  IF (INSIDE.EQ.0) THEN
                    GX=XN
                    GY=YN
                    GZ=ZN
                  ELSE
                    CALL SBSF6A(X,Y,Z,ORIG,MTRX,GRDCUB,GX,GY,GZ)
                  ENDIF
                  CALL SBSF6B(EYE,X,Y,Z,GX,GY,GZ,LIGHT,XL2,LSHINE,CLR)
                  SBBUFF(KSTART+K)=COL0+COLSCL*CLR
                ENDIF
                YJ=YJ+SDYJ
                ZZ=ZZ-DZZ
                K=K+KSTEP
  50          CONTINUE
            ENDIF
            XI=XI+DXI
  60      CONTINUE
          I1=I2+1
          IF (I1.GT.IXMAX) RETURN
  70    CONTINUE
      ENDIF
      END SUBROUTINE SBSRF6

      SUBROUTINE SBSF6A(X,Y,Z,ORIG,MTRX,GRD,XN,YN,ZN)
C     -----------------------------------------------
C
      REAL ORIG(*),MTRX(3,*),GRD(3,*)
      DATA ZERO,ONE /0.00001,0.99999/
C
      X0=X-ORIG(1)
      Y0=Y-ORIG(2)
      Z0=Z-ORIG(3)
      XI=X0*MTRX(1,1)+Y0*MTRX(2,1)+Z0*MTRX(3,1)
      YJ=X0*MTRX(1,2)+Y0*MTRX(2,2)+Z0*MTRX(3,2)
      ZK=X0*MTRX(1,3)+Y0*MTRX(2,3)+Z0*MTRX(3,3)
      DX=MIN(ONE,MAX(ZERO,XI-FLOAT(INT(XI))))
      DY=MIN(ONE,MAX(ZERO,YJ-FLOAT(INT(YJ))))
      DZ=MIN(ONE,MAX(ZERO,ZK-FLOAT(INT(ZK))))
      XN1=(1.0-DX)*(GRD(1,1)+DY*(GRD(1,4)-GRD(1,1)))
     *        +DX*(GRD(1,2)+DY*(GRD(1,3)-GRD(1,2)))
      XN2=(1.0-DX)*(GRD(1,5)+DY*(GRD(1,8)-GRD(1,5)))
     *        +DX*(GRD(1,6)+DY*(GRD(1,7)-GRD(1,6)))
      XN=XN1+DZ*(XN2-XN1)
      YN1=(1.0-DX)*(GRD(2,1)+DY*(GRD(2,4)-GRD(2,1)))
     *        +DX*(GRD(2,2)+DY*(GRD(2,3)-GRD(2,2)))
      YN2=(1.0-DX)*(GRD(2,5)+DY*(GRD(2,8)-GRD(2,5)))
     *        +DX*(GRD(2,6)+DY*(GRD(2,7)-GRD(2,6)))
      YN=YN1+DZ*(YN2-YN1)
      ZN1=(1.0-DX)*(GRD(3,1)+DY*(GRD(3,4)-GRD(3,1)))
     *        +DX*(GRD(3,2)+DY*(GRD(3,3)-GRD(3,2)))
      ZN2=(1.0-DX)*(GRD(3,5)+DY*(GRD(3,8)-GRD(3,5)))
     *        +DX*(GRD(3,6)+DY*(GRD(3,7)-GRD(3,6)))
      ZN=ZN1+DZ*(ZN2-ZN1)
      END SUBROUTINE SBSF6A

      SUBROUTINE SBSF6B(EYE,X,Y,Z,XN,YN,ZN,LIGHT,XL2,LSHINE,COLOUR)
C     -------------------------------------------------------------
C
      REAL    EYE(*),LIGHT(*)
      LOGICAL LSHINE
      DATA    SMALL2 /1.0E-20/
C
      COLOUR=0.0
      XNL=XN*LIGHT(1)+YN*LIGHT(2)+ZN*LIGHT(3)
      IF (XNL.GE.0.0) RETURN
      XN2=XN**2+YN**2+ZN**2+SMALL2
      IF (LSHINE) THEN
        RFNORM=2.0*XNL/XN2
        RX=LIGHT(1)-XN*RFNORM
        RY=LIGHT(2)-YN*RFNORM
        RZ=LIGHT(3)-ZN*RFNORM
        VX=EYE(1)-X
        VY=EYE(2)-Y
        VZ=EYE(3)-Z
        XRV=RX*VX+RY*VY+RZ*VZ
        IF (XRV.LT.0.0) RETURN
        V2=VX**2+VY**2+VZ**2
        COLOUR=MIN(XRV**2/(ABS(XL2*V2)+SMALL2),1.0)
      ELSE
        COLOUR=MIN(-XNL/SQRT(ABS(XL2*XN2)+SMALL2),1.0)
      ENDIF
      END SUBROUTINE SBSF6B

      SUBROUTINE SB2SRF(EYE,LATICE,DENS,N1,N2,DLOW,DHIGH,DVERT,IC1,IC2,
     *                  NCBAND,LIGHT,LSHINE)
C     -----------------------------------------------------------------
C
      REAL             EYE(*),LATICE(3,*),DENS(0:N1,0:N2),LIGHT(*)
      LOGICAL          LSHINE
C
      REAL*8           XLNORM,ZZ,DZZ,DSMAL2
      REAL             LATIC2(3,4),BAS(3,3),MTRX(3,3)
      REAL             VERT(3,8),XW(20),YW(20),GRDSCL(3)
      LOGICAL          LPS,LCOLOR
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      This subroutine plots a 3-d surface given a 2-d unit-cell
C    of density. All (x,y,z) values are taken to be given in world 
C    coordinates. The z-component of the eye-poisition should be 
C    positive and that of all the lattice-vertices should be negative; 
C    the viewing-screen is fixed at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    LATICE   R*4    I     3 x 3    (x,y,z) coordinates of the origin
C                                   and the a and b lattice-vertices.
C    DENS     R*4    I     (N1+1)   The density at regular points within
C                        x (N2+1)   the unit cell, wrapped around so
C                                   that DENS(0,J)=DENS(N1,J) etc..
C    N1,N2    I*4    I       -      The dimensions of the unit-cell grid.
C    DLOW     R*4    I       -      Lowest density to be plotted.
C    DHIGH    R*4    I       -      Highest density to be plotted.
C    DVERT    R*4    I       -      "Vertical" world-coordinate length
C                                   corresponding to density-range.
C    IC1,IC2  I*4    I       -      Lowest and highest colour-index to
C                                   be used for the rendering.
C    NCBAND   I*4    I       -      Number of colour-bands for the
C                                   height, so that the number of shades
C                                   per band = (IC2-IC1+1)/NCBAND.
C    LIGHT    R*4    I       3      (x,y,z) direction of flood-light.
C    LSHINE   L*1    I       -      Shiny surface if TRUE, else diffuse.
C
C Globals 
C    SFTBUF
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     SBLIN1     Calculates the projection of (x,y,z) on viewing screen.
C     SB2SR1     Calculates vertecies of triangular breakdown of grid.
C     SB2SR3     Calculates the normal of the surface.
C     SB2SR4     Calculates the appropriate colour for a given pixel.
C
C History
C   D. S. Sivia        1 Jun 1995  Initial release.
C   D. S. Sivia        7 Jul 1995  Fixed bug in determinant calculation.
C   D. S. Sivia       20 Oct 1995  Speeded up computations slightly.
C   D. S. Sivia       26 Oct 1995  Completely new algorithm!
C   D. S. Sivia       24 Oct 1997 "Safe-guarded" some rounding errors.
C-----------------------------------------------------------------------
C
C Carry out some initial checks.
C
      BIG=1.0E20
      SMALL=1.0E-10
      SMALL2=SMALL**2
      DSMAL2=DBLE(SMALL2)
      IF (EYE(3).LE.SMALL) RETURN
      IF (N1.LT.1 .OR. N2.LT.1) RETURN
      DRANGE=DHIGH-DLOW
      IF (DRANGE.LE.SMALL) RETURN
      XL2=LIGHT(1)**2+LIGHT(2)**2+LIGHT(3)**2
      IF (XL2.LT.SMALL) RETURN
      DO 10 I=1,3
        BAS(I,1)=LATICE(I,2)-LATICE(I,1)
        BAS(I,2)=LATICE(I,3)-LATICE(I,1)
  10  CONTINUE
      CX=BAS(2,1)*BAS(3,2)-BAS(2,2)*BAS(3,1)
      CY=BAS(3,1)*BAS(1,2)-BAS(3,2)*BAS(1,1)
      CZ=BAS(1,1)*BAS(2,2)-BAS(1,2)*BAS(2,1)
      CSCL=DVERT/SQRT(CX**2+CY**2+CZ**2+SMALL**2)
      BAS(1,3)=CX*CSCL
      BAS(2,3)=CY*CSCL
      BAS(3,3)=CZ*CSCL
      DMIN=MIN(DLOW,0.0)
      DMAX=MAX(DHIGH,0.0)
      ORGSCL=DMIN/(DMAX-DMIN+SMALL)
      DO 11 I=1,3
        LATIC2(I,1)=LATICE(I,1)+ORGSCL*BAS(I,3)
        LATIC2(I,2)=LATIC2(I,1)+BAS(I,1)
        LATIC2(I,3)=LATIC2(I,1)+BAS(I,2)
        LATIC2(I,4)=LATIC2(I,1)+BAS(I,3)
  11  CONTINUE
      IF (LATIC2(3,1).GE.0.0) RETURN
      ZFAR=LATIC2(3,2)+LATIC2(3,3)+LATIC2(3,4)-2.0*LATIC2(3,1)
      IF (ZFAR.GE.0.0) RETURN
      DO 12 J=1,3
        IF (LATIC2(3,J+1).GE.0.0) RETURN
        IF ((ZFAR-BAS(3,J)).GE.0.0) RETURN
        BAS2J=BAS(1,J)**2+BAS(2,J)**2+BAS(3,J)**2
        IF (BAS2J.LT.SMALL2) RETURN
  12  CONTINUE
      EYLAT1=EYE(1)-LATIC2(1,1)
      EYLAT2=EYE(2)-LATIC2(2,1)
      NTOT=(N1+1)*(N2+1)
C
C Set up matrix for real-space to lattice-index transformation.
C
      SAFE=0.0001
      XN1=0.99999*FLOAT(N1)
      XN2=0.99999*FLOAT(N2)
      XN3=0.99999
      DET=BAS(1,1)*BAS(2,2)*BAS(3,3)+BAS(1,2)*BAS(2,3)*BAS(3,1)
     *   +BAS(1,3)*BAS(2,1)*BAS(3,2)-BAS(3,1)*BAS(2,2)*BAS(1,3)
     *   -BAS(3,2)*BAS(2,3)*BAS(1,1)-BAS(3,3)*BAS(2,1)*BAS(1,2)
      IF (ABS(DET).LT.SMALL2) RETURN
      DETNRM=1.0/DET
      MTRX(1,1)=XN1*DETNRM*(BAS(2,2)*BAS(3,3)-BAS(2,3)*BAS(3,2))
      MTRX(1,2)=XN2*DETNRM*(BAS(2,3)*BAS(3,1)-BAS(2,1)*BAS(3,3))
      MTRX(1,3)=XN3*DETNRM*(BAS(2,1)*BAS(3,2)-BAS(2,2)*BAS(3,1))
      MTRX(2,1)=XN1*DETNRM*(BAS(3,2)*BAS(1,3)-BAS(3,3)*BAS(1,2))
      MTRX(2,2)=XN2*DETNRM*(BAS(3,3)*BAS(1,1)-BAS(3,1)*BAS(1,3))
      MTRX(2,3)=XN3*DETNRM*(BAS(3,1)*BAS(1,2)-BAS(3,2)*BAS(1,1))
      MTRX(3,1)=XN1*DETNRM*(BAS(1,2)*BAS(2,3)-BAS(1,3)*BAS(2,2))
      MTRX(3,2)=XN2*DETNRM*(BAS(1,3)*BAS(2,1)-BAS(1,1)*BAS(2,3))
      MTRX(3,3)=XN3*DETNRM*(BAS(1,1)*BAS(2,2)-BAS(1,2)*BAS(2,1))
C
C Some general initialisations.
C
      GRDSCL(1)=-FLOAT(N1)
      GRDSCL(2)=-FLOAT(N2)
      GRDSCL(3)=1.0/DRANGE
      IF (IC2.LT.IC1) RETURN
      NSHADS=MAX((IC2-IC1+1)/MAX(NCBAND,1),1)
      COLSCL=FLOAT(NSHADS-1)
      COL0=FLOAT(IC1)
      DKSCL=0.9999*FLOAT((IC2-IC1+1)/NSHADS)
      DX=FLOAT(NXP-1)/(XTRC-XBLC)
      DY=FLOAT(NYP-1)/(YTRC-YBLC)
      DYJ=1.0/DY
      DXI=1.0/DX
C
C New algorithm here: divide each box of 4 grid-points into four 
C triangles and paint them.
C
      DO 70 JLAT=1,N2
        DO 60 ILAT=1,N1
          CALL SB2SR1(ILAT,JLAT,DENS,N1,N2,DLOW,DRANGE,BAS,LATIC2,VERT)
          DO 50 IV=1,4
            CALL SBRCOP(VERT(1,IV),VERT(1,6),6)
            XMIN=+BIG
            XMAX=-BIG
            YMIN=+BIG
            YMAX=-BIG
            DO 20 I=1,3
              II=5+I
              CALL SBLIN1(EYE,VERT(1,II),VERT(2,II),VERT(3,II),
     *                    XW(I),YW(I))
              IF (XW(I).LT.XMIN) THEN
                XMIN=XW(I)
                ILEFT=I
              ENDIF
              IF (YW(I).LT.YMIN) THEN
                YMIN=YW(I)
                JBOTOM=I
              ENDIF
              XMAX=MAX(XW(I),XMAX)
              YMAX=MAX(YW(I),YMAX)
  20        CONTINUE
            IF (XMIN.GE.XTRC .OR. XMAX.LE.XBLC) GOTO 50
            IF (YMIN.GE.YTRC .OR. YMAX.LE.YBLC) GOTO 50
            AX=VERT(1,7)-VERT(1,6)
            AY=VERT(2,7)-VERT(2,6)
            AZ=VERT(3,7)-VERT(3,6)
            BX=VERT(1,6)-VERT(1,8)
            BY=VERT(2,6)-VERT(2,8)
            BZ=VERT(3,6)-VERT(3,8)
            XN=BY*AZ-AY*BZ
            YN=BZ*AX-AZ*BX
            ZN=BX*AY-AX*BY
            TEN=XN*(EYE(1)-VERT(1,6))+YN*(EYE(2)-VERT(2,6))
     *         +ZN*(EYE(3)-VERT(3,6))
            XLNORM=DBLE(TEN)
            EYENRM=XN*EYE(1)+YN*EYE(2)+ZN*EYE(3)
            SAFER=0.0001
            IF ((XMAX-XMIN).GT.(YMAX-YMIN)) THEN
              JYMIN=INT((YMIN-YBLC)*DY)+2
              JYMAX=MIN(INT((YMAX-YBLC)*DY)+1,NYP)
              IF (JYMIN.GT.JYMAX) GOTO 50
              YJ=YBLC+(FLOAT(JYMIN-1)+SAFER)*DYJ
              NVL2=JBOTOM
              NVR2=JBOTOM
              J1=JYMIN
              DO 30 IVERT=1,3
                IF (YJ.GT.YW(NVL2)) THEN
   1              NVL1=NVL2
                  NVL2=NVL1-1
                  IF (NVL2.LT.1) NVL2=3
                  IF (NVL2.EQ.JBOTOM) GOTO 50
                  IF (YJ.GT.YW(NVL2)) GOTO 1
                  YDIFL=YW(NVL2)-YW(NVL1)
                  IF (ABS(YDIFL).LT.SMALL) YDIFL=SMALL
                  GRADL=(XW(NVL2)-XW(NVL1))/YDIFL
                ENDIF
                IF (YJ.GT.YW(NVR2)) THEN
   2              NVR1=NVR2
                  NVR2=NVR1+1
                  IF (NVR2.GT.3) NVR2=1
                  IF (NVR2.EQ.JBOTOM) GOTO 50
                  IF (YJ.GT.YW(NVR2)) GOTO 2
                  YDIFR=YW(NVR2)-YW(NVR1)
                  IF (ABS(YDIFR).LT.SMALL) YDIFR=SMALL
                  GRADR=(XW(NVR2)-XW(NVR1))/YDIFR
                ENDIF
                IF (YW(NVL2).LT.YW(NVR2)) THEN
                  J2=MIN(INT((YW(NVL2)-YBLC)*DY)+1,JYMAX)
                ELSE
                  J2=MIN(INT((YW(NVR2)-YBLC)*DY)+1,JYMAX)
                ENDIF
                DO 29 J=J1,J2
                  IF (J.GE.1) THEN
                    XL=XW(NVL1)+GRADL*(YJ-YW(NVL1))
                    XR=XW(NVR1)+GRADR*(YJ-YW(NVR1))
                    ISTEP=1
                    IX1=MAX(INT((XL-XBLC)*DX)+2,1)
                    IX2=MIN(INT((XR-XBLC)*DX)+1,NXP)
                    IF (IX1.GT.IX2) THEN
                      ISTEP=-1
                      IX1=MIN(IX1-1,NXP)
                      IX2=MAX(IX2+1,1)
                    ENDIF
                    XI=XBLC+FLOAT(IX1-1)*DXI
                    DXISTP=FLOAT(ISTEP)*DXI
                    DZZ=DBLE(DXISTP*XN)
                    ZZ=DBLE(EYENRM-XI*XN-YJ*YN)
                    K=(J-1)*NXP+IX1
                    DO 28 I=IX1,IX2,ISTEP
                      XLAMDA=SNGL(XLNORM/ZZ)
                      Z=EYE(3)*(1.0-XLAMDA)
                      IF (Z.GT.SBBUFF(K)) THEN
                        SBBUFF(K)=Z
                        IF (IC1.EQ.IC2) THEN
                          SBBUFF(K+KSTART)=COL0
                        ELSE
                          XDI=EYLAT1+XLAMDA*(XI-EYE(1))
                          YDJ=EYLAT2+XLAMDA*(YJ-EYE(2))
                          ZDK=Z-LATIC2(3,1)
                          IF (NCBAND.GT.1) THEN
                            DK=MAX(MIN((XDI*MTRX(1,3)+YDJ*MTRX(2,3)
     *                        +ZDK*MTRX(3,3)),XN3),SAFE)
                            COL0=FLOAT(IC1+NSHADS*INT(DK*DKSCL))
                          ENDIF
                          DI=MAX(MIN((XDI*MTRX(1,1)+YDJ*MTRX(2,1)
     *                      +ZDK*MTRX(3,1)),XN1),SAFE)
                          DJ=MAX(MIN((XDI*MTRX(1,2)+YDJ*MTRX(2,2)
     *                      +ZDK*MTRX(3,2)),XN2),SAFE)
                          CALL SB2SR3(DENS,N1,N2,DI,DJ,BAS,GX,GY,GZ,
     *                                GRDSCL)
                          CALL SB2SR4(EYE,XI,YJ,0.0,GX,GY,GZ,LIGHT,
     *                                XL2,SMALL2,LSHINE,COLOUR)
                          SBBUFF(K+KSTART)=COL0+COLOUR*COLSCL
                        ENDIF
                      ENDIF
                      XI=XI+DXISTP
                      ZZ=ZZ-DZZ
                      K=K+ISTEP
  28                CONTINUE
                  ENDIF
                  YJ=YJ+DYJ
  29            CONTINUE
                J1=J2+1
                IF (J1.GT.JYMAX) GOTO 50
  30          CONTINUE
            ELSE
              IXMIN=INT((XMIN-XBLC)*DX)+2
              IXMAX=MIN(INT((XMAX-XBLC)*DX)+1,NXP)
              IF (IXMIN.GT.IXMAX) GOTO 50
              XI=XBLC+(FLOAT(IXMIN-1)+SAFER)*DXI
              NVL2=ILEFT
              NVR2=ILEFT
              I1=IXMIN
              DO 40 IVERT=1,3
                IF (XI.GT.XW(NVL2)) THEN
   3              NVL1=NVL2
                  NVL2=NVL1-1
                  IF (NVL2.LT.1) NVL2=3
                  IF (NVL2.EQ.ILEFT) GOTO 50
                  IF (XI.GT.XW(NVL2)) GOTO 3
                  XDIFL=XW(NVL2)-XW(NVL1)
                  IF (ABS(XDIFL).LT.SMALL) XDIFL=SMALL
                  GRADL=(YW(NVL2)-YW(NVL1))/XDIFL
                ENDIF
                IF (XI.GT.XW(NVR2)) THEN
   4              NVR1=NVR2
                  NVR2=NVR1+1
                  IF (NVR2.GT.3) NVR2=1
                  IF (NVR2.EQ.ILEFT) GOTO 50
                  IF (XI.GT.XW(NVR2)) GOTO 4
                  XDIFR=XW(NVR2)-XW(NVR1)
                  IF (ABS(XDIFR).LT.SMALL) XDIFR=SMALL
                  GRADR=(YW(NVR2)-YW(NVR1))/XDIFR
               ENDIF
                IF (XW(NVL2).LT.XW(NVR2)) THEN
                  I2=MIN(INT((XW(NVL2)-XBLC)*DX)+1,IXMAX)
                ELSE
                  I2=MIN(INT((XW(NVR2)-XBLC)*DX)+1,IXMAX)
                ENDIF
                DO 39 I=I1,I2
                  IF (I.GE.1) THEN
                    YL=YW(NVL1)+GRADL*(XI-XW(NVL1))
                    YR=YW(NVR1)+GRADR*(XI-XW(NVR1))
                    JSTEP=1
                    JY1=MAX(INT((YL-YBLC)*DY)+2,1)
                    JY2=MIN(INT((YR-YBLC)*DY)+1,NYP)
                    IF (JY1.GT.JY2) THEN
                      JSTEP=-1
                      JY1=MIN(JY1-1,NYP)
                      JY2=MAX(JY2+1,1)
                    ENDIF
                    YJ=YBLC+FLOAT(JY1-1)*DYJ
                    DYJSTP=FLOAT(JSTEP)*DYJ
                    DZZ=DBLE(DYJSTP*YN)
                    ZZ=DBLE(EYENRM-YJ*YN-XI*XN)
                    K=(JY1-1)*NXP+I
                    KSTEP=JSTEP*NXP
                    DO 38 J=JY1,JY2,JSTEP
                      XLAMDA=SNGL(XLNORM/ZZ)
                      Z=EYE(3)*(1.0-XLAMDA)
                      IF (Z.GT.SBBUFF(K)) THEN
                        SBBUFF(K)=Z
                        IF (IC1.EQ.IC2) THEN
                          SBBUFF(K+KSTART)=COL0
                        ELSE
                          XDI=EYLAT1+XLAMDA*(XI-EYE(1))
                          YDJ=EYLAT2+XLAMDA*(YJ-EYE(2))
                          ZDK=Z-LATIC2(3,1)
                          IF (NCBAND.GT.1) THEN
                            DK=MAX(MIN((XDI*MTRX(1,3)+YDJ*MTRX(2,3)
     *                        +ZDK*MTRX(3,3)),XN3),SAFE)
                            COL0=FLOAT(IC1+NSHADS*INT(DK*DKSCL))
                          ENDIF
                          DI=MAX(MIN((XDI*MTRX(1,1)+YDJ*MTRX(2,1)
     *                      +ZDK*MTRX(3,1)),XN1),SAFE)
                          DJ=MAX(MIN((XDI*MTRX(1,2)+YDJ*MTRX(2,2)
     *                      +ZDK*MTRX(3,2)),XN2),SAFE)
                          CALL SB2SR3(DENS,N1,N2,DI,DJ,BAS,GX,GY,GZ,
     *                                GRDSCL)
                          CALL SB2SR4(EYE,XI,YJ,0.0,GX,GY,GZ,LIGHT,
     *                                XL2,SMALL2,LSHINE,COLOUR)
                          SBBUFF(K+KSTART)=COL0+COLOUR*COLSCL
                        ENDIF
                      ENDIF
                      YJ=YJ+DYJSTP
                      ZZ=ZZ-DZZ
                      K=K+KSTEP
  38                CONTINUE
                  ENDIF
                  XI=XI+DXI
  39            CONTINUE
                I1=I2+1
                IF (I1.GT.IXMAX) GOTO 50
  40          CONTINUE
            ENDIF
  50      CONTINUE
  60    CONTINUE
  70  CONTINUE
      END       SUBROUTINE SB2SRF

      SUBROUTINE SB2SR1(I1,J1,DENS,N1,N2,DLOW,DRANGE,BAS,LATICE,VERT)
C     ---------------------------------------------------------------
C
      REAL DENS(0:N1,0:N2),BAS(3,*),LATICE(*),VERT(3,*)
C
      I0=I1-1
      J0=J1-1
      XNORM=1.0/FLOAT(N1)
      YNORM=1.0/FLOAT(N2)
      ZNORM=1.0/DRANGE
      D00=MAX(MIN((DENS(I0,J0)-DLOW)*ZNORM,1.0),0.0)
      D10=MAX(MIN((DENS(I1,J0)-DLOW)*ZNORM,1.0),0.0)
      D11=MAX(MIN((DENS(I1,J1)-DLOW)*ZNORM,1.0),0.0)
      D01=MAX(MIN((DENS(I0,J1)-DLOW)*ZNORM,1.0),0.0)
      X0=FLOAT(I0)*XNORM
      X1=FLOAT(I1)*XNORM
      Y0=FLOAT(J0)*YNORM
      Y1=FLOAT(J1)*YNORM
      VERT(1,1)=X0*BAS(1,1)+Y0*BAS(1,2)+D00*BAS(1,3)+LATICE(1)
      VERT(2,1)=X0*BAS(2,1)+Y0*BAS(2,2)+D00*BAS(2,3)+LATICE(2)
      VERT(3,1)=X0*BAS(3,1)+Y0*BAS(3,2)+D00*BAS(3,3)+LATICE(3)
      VERT(1,2)=X1*BAS(1,1)+Y0*BAS(1,2)+D10*BAS(1,3)+LATICE(1)
      VERT(2,2)=X1*BAS(2,1)+Y0*BAS(2,2)+D10*BAS(2,3)+LATICE(2)
      VERT(3,2)=X1*BAS(3,1)+Y0*BAS(3,2)+D10*BAS(3,3)+LATICE(3)
      VERT(1,3)=X1*BAS(1,1)+Y1*BAS(1,2)+D11*BAS(1,3)+LATICE(1)
      VERT(2,3)=X1*BAS(2,1)+Y1*BAS(2,2)+D11*BAS(2,3)+LATICE(2)
      VERT(3,3)=X1*BAS(3,1)+Y1*BAS(3,2)+D11*BAS(3,3)+LATICE(3)
      VERT(1,4)=X0*BAS(1,1)+Y1*BAS(1,2)+D01*BAS(1,3)+LATICE(1)
      VERT(2,4)=X0*BAS(2,1)+Y1*BAS(2,2)+D01*BAS(2,3)+LATICE(2)
      VERT(3,4)=X0*BAS(3,1)+Y1*BAS(3,2)+D01*BAS(3,3)+LATICE(3)
      VERT(1,5)=VERT(1,1)
      VERT(2,5)=VERT(2,1)
      VERT(3,5)=VERT(3,1)
      XM=0.5*FLOAT(I0+I1)*XNORM
      YM=0.5*FLOAT(J0+J1)*YNORM
      DM=0.25*(DENS(I0,J0)+DENS(I1,J0)+DENS(I1,J1)+DENS(I0,J1))
      DM=MAX(MIN((DM-DLOW)*ZNORM,1.0),0.0)
      VERT(1,8)=XM*BAS(1,1)+YM*BAS(1,2)+DM*BAS(1,3)+LATICE(1)
      VERT(2,8)=XM*BAS(2,1)+YM*BAS(2,2)+DM*BAS(2,3)+LATICE(2)
      VERT(3,8)=XM*BAS(3,1)+YM*BAS(3,2)+DM*BAS(3,3)+LATICE(3)
      END SUBROUTINE SB2SR1

      SUBROUTINE SB2SR3(DENS,N1,N2,XI,YJ,BAS,XN,YN,ZN,GRDSCL)
C     -------------------------------------------------------
C
      REAL DENS(0:N1,0:N2),BAS(3,*),GRDSCL(*)
C
      I=INT(XI)
      J=INT(YJ)
      II=I+1
      JJ=J+1
      DX=XI-FLOAT(I)
      DY=YJ-FLOAT(J)
      CALL S2SR3A(I,DX,N1,IM,I0,IP,DDX)
      XM=DENS(IM,J)+DY*(DENS(IM,JJ)-DENS(IM,J))
      X0=DENS(I0,J)+DY*(DENS(I0,JJ)-DENS(I0,J))
      XP=DENS(IP,J)+DY*(DENS(IP,JJ)-DENS(IP,J))
      GX=GRDSCL(1)*GRDSCL(3)*((1.0-DDX)*(X0-XM)+DDX*(XP-X0))
      CALL S2SR3A(J,DY,N2,JM,J0,JP,DDY)
      YM=DENS(I,JM)+DX*(DENS(II,JM)-DENS(I,JM))
      Y0=DENS(I,J0)+DX*(DENS(II,J0)-DENS(I,J0))
      YP=DENS(I,JP)+DX*(DENS(II,JP)-DENS(I,JP))
      GY=GRDSCL(2)*GRDSCL(3)*((1.0-DDY)*(Y0-YM)+DDY*(YP-Y0))
      GZ=1.0
      XN=GX*BAS(1,1)+GY*BAS(1,2)+GZ*BAS(1,3)
      YN=GX*BAS(2,1)+GY*BAS(2,2)+GZ*BAS(2,3)
      ZN=GX*BAS(3,1)+GY*BAS(3,2)+GZ*BAS(3,3)
      END SUBROUTINE SB2SR3

      SUBROUTINE S2SR3A(I,DX,NX,IM,I0,IP,DDX)
C     ---------------------------------------
C
      IF (DX.LT.0.5) THEN
        DDX=DX+0.5
        I0=I
        IM=I0-1
        IP=I0+1
        IF (IM.LT.0) IM=NX
      ELSE
        DDX=DX-0.5
        I0=I+1
        IM=I0-1
        IP=I0+1
        IF (IP.GT.NX) IP=0
      ENDIF
      END SUBROUTINE S2SR3A

      SUBROUTINE SB2SR4(EYE,X,Y,Z,XN,YN,ZN,LIGHT,XL2,SMALL2,LSHINE,
     *                  COLOUR)
C     -------------------------------------------------------------
C
      REAL    EYE(*),LIGHT(*)
      LOGICAL LSHINE
C
      COLOUR=0.0
      XNL=XN*LIGHT(1)+YN*LIGHT(2)+ZN*LIGHT(3)
      IF (XNL.GE.0.0) RETURN
      XN2=XN**2+YN**2+ZN**2+SMALL2
      IF (LSHINE) THEN
        RFNORM=2.0*XNL/XN2
        RX=LIGHT(1)-XN*RFNORM
        RY=LIGHT(2)-YN*RFNORM
        RZ=LIGHT(3)-ZN*RFNORM
        VX=EYE(1)-X
        VY=EYE(2)-Y
        VZ=EYE(3)-Z
        XRV=RX*VX+RY*VY+RZ*VZ
        IF (XRV.LT.0.0) RETURN
        V2=VX**2+VY**2+VZ**2
        COLOUR=MIN(XRV**2/(ABS(XL2*V2)+SMALL2),1.0)
      ELSE
        COLOUR=MIN(-XNL/SQRT(ABS(XL2*XN2)+SMALL2),1.0)
      ENDIF
      END SUBROUTINE SB2SR4

      SUBROUTINE SBPLNT(EYE,NV,VERT,IC1,IC2,LIGHT,ITRANS)
C     ---------------------------------------------------
C
      REAL             EYE(*),VERT(3,*),LIGHT(*)
C
      REAL*8           XLNORM,ZZ,DZZ
      REAL             XW(400),YW(400)
      LOGICAL          LPS,LCOLOR
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
!




C      This subroutine plots a diffusively-lit, semi-transparent, 
C    coloured plane; the use must ensure that all the verticies lie in a
C    flat plane, and that the bounding polygon be convex (so that the 
C    angle at any vertex <= 180 degs). All (x,y,z) values are taken to 
C    be given in world coordinates. The z-component of the eye-poisition
C    should be positive and that of the vertices should be negative; the
C    viewing-screen is fixed at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    NV       R*4    I       -      No. of verticies (>=3).
C    VERT     R*4    I     3 x NV   (x,y,z) coordinate of verticies.
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for the shading.
C    LIGHT    R*4    I       3      (x,y,z) direction of flood-light.
C    ITRANS   I*4    I       -      Level of transparency:
C                                        1 = 25%; 2 = 50%; 3 = 75%.
C
C Globals 
C    SFTBUF
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     SBLIN1     Calculates the projection of (x,y,z) on viewing screen.
C
C History
C   D. S. Sivia      21 Aug 1995  Initial release.
C   D. S. Sivia      24 Oct 1997 "Safe-guarded" some rounding errors.
C-----------------------------------------------------------------------
C
C Carry out some initial checks and calculate the coordinates of the 
C projected polygon.
C
      SMALL=1.0E-10
      SMALL2=SMALL**2
      IF (EYE(3).LE.SMALL) RETURN
      IF (NV.LT.3 .OR. NV.GT.400) RETURN
      DO 10 I=1,NV
  10    IF (VERT(3,I).GE.0.0) RETURN
      XMIN=+1.0E20
      XMAX=-1.0E20
      YMIN=+1.0E20
      YMAX=-1.0E20
      DO 20 I=1,NV
        CALL SBLIN1(EYE,VERT(1,I),VERT(2,I),VERT(3,I),XW(I),YW(I))
        IF (XW(I).LT.XMIN) THEN
          XMIN=XW(I)
          ILEFT=I
        ENDIF
        IF (YW(I).LT.YMIN) THEN
          YMIN=YW(I)
          JBOTOM=I
        ENDIF
        XMAX=MAX(XW(I),XMAX)
        YMAX=MAX(YW(I),YMAX)
  20  CONTINUE
      IF (XMIN.GE.XTRC .OR. XMAX.LE.XBLC) RETURN
      IF (YMIN.GE.YTRC .OR. YMAX.LE.YBLC) RETURN
C
C Find the outward normal seen by the eye, and activate the appropriate 
C colour.
C
      AX=VERT(1,2)-VERT(1,1)
      AY=VERT(2,2)-VERT(2,1)
      AZ=VERT(3,2)-VERT(3,1)
      BX=VERT(1,1)-VERT(1,NV)
      BY=VERT(2,1)-VERT(2,NV)
      BZ=VERT(3,1)-VERT(3,NV)
      XN=BY*AZ-AY*BZ
      YN=BZ*AX-AZ*BX
      ZN=BX*AY-AX*BY
      TEN=XN*(EYE(1)-VERT(1,1))+YN*(EYE(2)-VERT(2,1))
     *   +ZN*(EYE(3)-VERT(3,1))
      COLOUR=FLOAT(IC1)
      NC=IC2-IC1
      IF (NC.GT.0) THEN
        TNL=XN*LIGHT(1)+YN*LIGHT(2)+ZN*LIGHT(3)
        IF (TEN.LT.0.0) TNL=-TNL
        COSDIF=0.0
        IF (TNL.LT.0.0) THEN
          TN2=XN**2+YN**2+ZN**2
          TL2=LIGHT(1)**2+LIGHT(2)**2+LIGHT(3)**2
          COSDIF=MIN(-TNL/SQRT(TN2*TL2+SMALL2),1.0)
        ENDIF
        COLOUR=COLOUR+COSDIF*FLOAT(NC)
      ENDIF
C
C Plot the projected polygon.
C
      ITLEVL=MAX(MIN(ITRANS,3),1)
      XLNORM=DBLE(EYE(3))*DBLE(TEN)
      EYENRM=XN*EYE(1)+YN*EYE(2)+ZN*EYE(3)
      DX=FLOAT(NXP-1)/(XTRC-XBLC)
      DY=FLOAT(NYP-1)/(YTRC-YBLC)
      DYJ=1.0/DY
      DXI=1.0/DX
      SAFER=0.0001
      IF ((XMAX-XMIN).GT.(YMAX-YMIN)) THEN
        JYMIN=INT((YMIN-YBLC)*DY)+2
        JYMAX=MIN(INT((YMAX-YBLC)*DY)+1,NYP)
        IF (JYMIN.GT.JYMAX) RETURN
        YJ=YBLC+(FLOAT(JYMIN-1)+SAFER)*DYJ
        NVL2=JBOTOM
        NVR2=JBOTOM
        J1=JYMIN
        DO 50 IVERT=1,NV
          IF (YJ.GT.YW(NVL2)) THEN
   1        NVL1=NVL2
            NVL2=NVL1-1
            IF (NVL2.LT.1) NVL2=NV
            IF (NVL2.EQ.JBOTOM) RETURN
            IF (YJ.GT.YW(NVL2)) GOTO 1
            YDIFL=YW(NVL2)-YW(NVL1)
            IF (ABS(YDIFL).LT.SMALL) YDIFL=SMALL
            GRADL=(XW(NVL2)-XW(NVL1))/YDIFL
          ENDIF
          IF (YJ.GT.YW(NVR2)) THEN
   2        NVR1=NVR2
            NVR2=NVR1+1
            IF (NVR2.GT.NV) NVR2=1
            IF (NVR2.EQ.JBOTOM) RETURN
            IF (YJ.GT.YW(NVR2)) GOTO 2
            YDIFR=YW(NVR2)-YW(NVR1)
            IF (ABS(YDIFR).LT.SMALL) YDIFR=SMALL
            GRADR=(XW(NVR2)-XW(NVR1))/YDIFR
          ENDIF
          IF (YW(NVL2).LT.YW(NVR2)) THEN
            J2=MIN(INT((YW(NVL2)-YBLC)*DY)+1,JYMAX)
          ELSE
            J2=MIN(INT((YW(NVR2)-YBLC)*DY)+1,JYMAX)
          ENDIF
          DO 40 J=J1,J2
            IF (J.GE.1) THEN
              JTEST=MOD(J,2)
              IF (ITLEVL.EQ.3 .AND. JTEST.EQ.1) GOTO 39
              XL=XW(NVL1)+GRADL*(YJ-YW(NVL1))
              XR=XW(NVR1)+GRADR*(YJ-YW(NVR1))
              ISTEP=1
              IX1=MAX(INT((XL-XBLC)*DX)+2,1)
              IX2=MIN(INT((XR-XBLC)*DX)+1,NXP)
              IF (IX1.GT.IX2) THEN
                ISTEP=-1
                IX1=MIN(IX1-1,NXP)
                IX2=MAX(IX2+1,1)
              ENDIF
              DZZ=DBLE(FLOAT(ISTEP)*DXI*XN)
              ZZ=DBLE(EYENRM-(XBLC+FLOAT(IX1-1)*DXI)*XN-YJ*YN)
              K=(J-1)*NXP+IX1
              DO 30 I=IX1,IX2,ISTEP
                ITEST=MOD(I,2)
                IF (ITLEVL.EQ.1) THEN
                  IF ((ITEST+JTEST).EQ.0) GOTO 29
                ELSEIF (ITLEVL.EQ.2) THEN
                  IF ((ITEST+JTEST).EQ.1) GOTO 29
                ELSE
                  IF (ITEST.EQ.1) GOTO 29
                ENDIF
                Z=EYE(3)-SNGL(XLNORM/ZZ)
                IF (Z.GT.SBBUFF(K)) THEN
                  SBBUFF(K)=Z
                  SBBUFF(KSTART+K)=COLOUR
                ENDIF
  29            ZZ=ZZ-DZZ
                K=K+ISTEP
  30          CONTINUE
            ENDIF
  39        YJ=YJ+DYJ
  40      CONTINUE
          J1=J2+1
          IF (J1.GT.JYMAX) RETURN
  50    CONTINUE
      ELSE
        IXMIN=INT((XMIN-XBLC)*DX)+2
        IXMAX=MIN(INT((XMAX-XBLC)*DX)+1,NXP)
        IF (IXMIN.GT.IXMAX) RETURN
        XI=XBLC+(FLOAT(IXMIN-1)+SAFER)*DXI
        NVL2=ILEFT
        NVR2=ILEFT
        I1=IXMIN
        DO 80 IVERT=1,NV
          IF (XI.GT.XW(NVL2)) THEN
   3        NVL1=NVL2
            NVL2=NVL1-1
            IF (NVL2.LT.1) NVL2=NV
            IF (NVL2.EQ.ILEFT) RETURN
            IF (XI.GT.XW(NVL2)) GOTO 3
            XDIFL=XW(NVL2)-XW(NVL1)
            IF (ABS(XDIFL).LT.SMALL) XDIFL=SMALL
            GRADL=(YW(NVL2)-YW(NVL1))/XDIFL
          ENDIF
          IF (XI.GT.XW(NVR2)) THEN
   4        NVR1=NVR2
            NVR2=NVR1+1
            IF (NVR2.GT.NV) NVR2=1
            IF (NVR2.EQ.ILEFT) RETURN
            IF (XI.GT.XW(NVR2)) GOTO 4
            XDIFR=XW(NVR2)-XW(NVR1)
            IF (ABS(XDIFR).LT.SMALL) XDIFR=SMALL
            GRADR=(YW(NVR2)-YW(NVR1))/XDIFR
          ENDIF
          IF (XW(NVL2).LT.XW(NVR2)) THEN
            I2=MIN(INT((XW(NVL2)-XBLC)*DX)+1,IXMAX)
          ELSE
            I2=MIN(INT((XW(NVR2)-XBLC)*DX)+1,IXMAX)
          ENDIF
          DO 70 I=I1,I2
            IF (I.GE.1) THEN
              ITEST=MOD(I,2)
              IF (ITLEVL.EQ.3 .AND. ITEST.EQ.1) GOTO 69
              YL=YW(NVL1)+GRADL*(XI-XW(NVL1))
              YR=YW(NVR1)+GRADR*(XI-XW(NVR1))
              ISTEP=1
              JY1=MAX(INT((YL-YBLC)*DY)+2,1)
              JY2=MIN(INT((YR-YBLC)*DY)+1,NYP)
              IF (JY1.GT.JY2) THEN
                ISTEP=-1
                JY1=MIN(JY1-1,NYP)
                JY2=MAX(JY2+1,1)
              ENDIF
              DZZ=DBLE(FLOAT(ISTEP)*DYJ*YN)
              ZZ=DBLE(EYENRM-(YBLC+FLOAT(JY1-1)*DYJ)*YN-XI*XN)
              K=(JY1-1)*NXP+I
              KSTEP=ISTEP*NXP
              DO 60 J=JY1,JY2,ISTEP
                JTEST=MOD(J,2)
                IF (ITLEVL.EQ.1) THEN
                  IF ((ITEST+JTEST).EQ.0) GOTO 59
                ELSEIF (ITLEVL.EQ.2) THEN
                  IF ((ITEST+JTEST).EQ.1) GOTO 59
                ELSE
                  IF (JTEST.EQ.1) GOTO 59
                ENDIF
                Z=EYE(3)-SNGL(XLNORM/ZZ)
                IF (Z.GT.SBBUFF(K)) THEN
                  SBBUFF(K)=Z
                  SBBUFF(KSTART+K)=COLOUR
                ENDIF
  59            ZZ=ZZ-DZZ
                K=K+KSTEP
  60          CONTINUE
            ENDIF
  69        XI=XI+DXI
  70      CONTINUE
          I1=I2+1
          IF (I1.GT.IXMAX) RETURN
  80    CONTINUE
      ENDIF
      END SUBROUTINE SBPLNT

      SUBROUTINE SBELIP(EYE,CENTRE,PAXES,IC1,IC2,LIGHT,LSHINE,ICLINE,
     *                  ANGLIN,X0,Y0,R0)
C     ---------------------------------------------------------------
C
      REAL            EYE(*),CENTRE(*),PAXES(3,*),LIGHT(*)
      LOGICAL         LSHINE
C
      REAL            SURF(3),EVEC(3,3),ENRM(3)
      REAL*8          DXE,DYE,DZE,DZE2,DWZE,DXH,DYH,DUXH,DVYH
      REAL*8          ALFA,BETA,GAMA,QXX,QYY,QZZ,QXY,QYZ,QZX,U,V,W,XMU
      REAL*8          DBL0,DBL1,DBL2,A,B,C,DET,Q,DX0H,DY0H,DSMALL
      REAL*8          XL0,XL1,HYP,SINPHI,COSPHI,R1,R2
      LOGICAL         LPS,LCOLOR
      COMMON /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
!




C      This subroutine plots a shiny or matt coloured elliptical ball. 
C    All (x,y,z) values are taken to be given in world coordinates. The 
C    z-component of the eye-poisition should be positive and that of
C    the ball-centre should be negative (< -radius); the viewing-screen
C    is fixed at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    CENTRE   R*4    I       3      (x,y,z) coordinate of ball-centre.
C    PAXES    R*4    I     3 x 3    Principal axes of the elliposid.
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for shading.
C    LIGHT    R*4    I       3      (x,y,z) direction of flood-light.
C    LSHINE   L*1    I       -      Shiny ball if .TRUE., else diffuse.
C    ICLINE   I*4    I       -      If >=0, colour index for lines on
C                                   surface of ellipsoid.
C    ANGLIN   R*4    I       -      Width of lines: +/- degs.
C    X0,Y0    R*4    O       -      Centre of projected ball.
C    R0       R*4    O       -      Average radius of projected ball.
C
C Globals 
C    SFTBUF
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     SBEGLS     Works out colour-shade for surface of ellipsoid.
C
C History
C   D. S. Sivia       8 Sep 1995  Initial release.
C   D. S. Sivia      29 Sep 1995  Pass down angular-width of lines.
C-----------------------------------------------------------------------
C
C Set up standard ellipsoid and carry out some initial checks.
C
      SMALL=1.0E-20
      DSMALL=DBLE(SMALL)
      IF (EYE(3).LE.0.0) RETURN
      EVAL1=PAXES(1,1)**2+PAXES(2,1)**2+PAXES(3,1)**2
      EVAL2=PAXES(1,2)**2+PAXES(2,2)**2+PAXES(3,2)**2
      EVAL3=PAXES(1,3)**2+PAXES(2,3)**2+PAXES(3,3)**2
      IF (EVAL1.LT.SMALL .OR. EVAL2.LT.SMALL .OR. EVAL3.LT.SMALL) RETURN
      EVAL1=1.0/EVAL1
      EVAL2=1.0/EVAL2
      EVAL3=1.0/EVAL3
      ENRM(1)=SQRT(EVAL1)
      ENRM(2)=SQRT(EVAL2)
      ENRM(3)=SQRT(EVAL3)
      DO 20 J=1,3
        DO 10 I=1,3
  10      EVEC(I,J)=PAXES(I,J)*ENRM(J)
  20  CONTINUE
      DOTSUM=EVEC(1,1)*EVEC(1,2)+EVEC(2,1)*EVEC(2,2)+EVEC(3,1)*EVEC(3,2)
     *      +EVEC(1,2)*EVEC(1,3)+EVEC(2,2)*EVEC(2,3)+EVEC(3,2)*EVEC(3,3)
     *      +EVEC(1,3)*EVEC(1,1)+EVEC(2,3)*EVEC(2,1)+EVEC(3,3)*EVEC(3,1)
      IF (DOTSUM.GT.0.001) RETURN
      QXX=DBLE(EVAL1*EVEC(1,1)**2+EVAL2*EVEC(1,2)**2+EVAL3*EVEC(1,3)**2)
      QYY=DBLE(EVAL1*EVEC(2,1)**2+EVAL2*EVEC(2,2)**2+EVAL3*EVEC(2,3)**2)
      QZZ=DBLE(EVAL1*EVEC(3,1)**2+EVAL2*EVEC(3,2)**2+EVAL3*EVEC(3,3)**2)
      QXY=DBLE(EVAL1*EVEC(1,1)*EVEC(2,1)+EVAL2*EVEC(1,2)*EVEC(2,2)
     *        +EVAL3*EVEC(1,3)*EVEC(2,3))
      QYZ=DBLE(EVAL1*EVEC(2,1)*EVEC(3,1)+EVAL2*EVEC(2,2)*EVEC(3,2)
     *        +EVAL3*EVEC(2,3)*EVEC(3,3))
      QZX=DBLE(EVAL1*EVEC(3,1)*EVEC(1,1)+EVAL2*EVEC(3,2)*EVEC(1,2)
     *        +EVAL3*EVEC(3,3)*EVEC(1,3))
      DBL1=(QYZ*QXX-QXY*QZX)/(QXY**2-QXX*QYY)
      DBL2=(QYZ*QXY-QYY*QZX)/(QXX*QYY-QXY**2)
      A=QXX*DBL2**2+QYY*DBL1**2+QZZ
      B=QXY*DBL1*DBL2+QYZ*DBL1+QZX*DBL2
      ZMAX=CENTRE(3)+SNGL((SQRT(B**2+A)-B)/A)
      IF (ZMAX.GT.-SMALL) RETURN
C
C Calculate some useful parameters.
C
      DXE=DBLE(EYE(1))
      DYE=DBLE(EYE(2))
      DZE=DBLE(EYE(3))
      DZE2=DZE**2
      ALFA=DBLE(EYE(1)-CENTRE(1))
      BETA=DBLE(EYE(2)-CENTRE(2))
      GAMA=DBLE(EYE(3)-CENTRE(3))
      U=ALFA*QXX+BETA*QXY+GAMA*QZX
      V=ALFA*QXY+BETA*QYY+GAMA*QYZ
      W=ALFA*QZX+BETA*QYZ+GAMA*QZZ
      XMU=QXX*ALFA**2+QYY*BETA**2+QZZ*GAMA**2+2.0D0*(ALFA*BETA*QXY
     *    +BETA*GAMA*QYZ+GAMA*ALFA*QZX)-1.0D0
      A=XMU*QXX-U**2
      B=XMU*QXY-U*V
      C=XMU*QYY-V**2
      DET=ABS(A*C-B**2)+DSMALL
      DBL1=DZE*(XMU*QZX-U*W)
      DBL2=DZE*(XMU*QYZ-V*W)
      DX0H=(DBL1*C-DBL2*B)/DET
      DY0H=(DBL2*A-DBL1*B)/DET
      Q=DZE2*(W**2-XMU*QZZ)+A*DX0H**2+2.0D0*B*DX0H*DY0H+C*DY0H**2
      X0H=SNGL(DX0H)
      Y0H=SNGL(DY0H)
      DX=(XTRC-XBLC)/FLOAT(NXP-1)
      DY=(YTRC-YBLC)/FLOAT(NYP-1)
      XDIF=SNGL(SQRT(ABS(C*Q/DET)+DSMALL))
      XMIN=X0H-XDIF+EYE(1)
      XMAX=X0H+XDIF+EYE(1)
      IXMIN=INT((XMIN-XBLC)/DX)+2
      IXMAX=INT((XMAX-XBLC)/DX)+1
      IF (IXMIN.GT.NXP .OR. IXMAX.LT.1) RETURN
      YDIF=(SQRT(ABS(A*Q/DET)+DSMALL))
      YMIN=Y0H-YDIF+EYE(2)
      YMAX=Y0H+YDIF+EYE(2)
      JYMIN=INT((YMIN-YBLC)/DY)+2
      JYMAX=INT((YMAX-YBLC)/DY)+1
      IF (JYMIN.GT.NYP .OR. JYMAX.LT.1) RETURN
      IF (JYMIN.LT.1) JYMIN=1
      IF (JYMAX.GT.NYP) JYMAX=NYP
      X0=X0H+EYE(1)
      Y0=Y0H+EYE(2)
      COREL=SNGL(SQRT(ABS((B*B)/(A*C))+DSMALL))
      IF (COREL.GT.0.0001) THEN
        XL0=(A+C)/2.0D0
        XL1=XL0-SQRT(ABS(XL0*XL0-DET)+DSMALL)
        HYP=SQRT((XL1-A)**2+B**2+DSMALL)
        SINPHI=(XL1-A)/HYP
        COSPHI=B/HYP
      ELSE
        SINPHI=0.0D0
        COSPHI=1.0D0
      ENDIF
      R1=SQRT(Q/(A*COSPHI*COSPHI+SINPHI*(C*SINPHI+2.0*B*COSPHI)))
      R2=SQRT(Q/(A*SINPHI*SINPHI+COSPHI*(C*COSPHI-2.0*B*SINPHI)))
      R0=SNGL((R1+R2)/2.0D0)
C
C Fill the inside of the projected ellipse with the right colours.
C
      COSMIN=MAX(SIN(ABS(ANGLIN/57.29578)),0.0001)
      NC=IC2-IC1
      COL0=FLOAT(IC1)
      COLSCL=FLOAT(NC)
      COLINE=FLOAT(ICLINE)
      XL2=LIGHT(1)**2+LIGHT(2)**2+LIGHT(3)**2
      YH=YBLC+DY*FLOAT(JYMIN-1)-EYE(2)
      DWZE=W*DZE
      BA=SNGL(B/A)
      DO 40 JY=JYMIN,JYMAX
        DYH=DBLE(YH)
        DVYH=V*DYH
        DBL0=QZZ*DZE2+DYH*(QYY*DYH-2.0D0*QYZ*DZE)
        YDIF=YH-Y0H
        XDIF=SNGL(SQRT(ABS(A*Q-DET*DBLE(YDIF**2))+DSMALL)/A)
        XMIN=X0H-BA*YDIF-XDIF+EYE(1)
        XMAX=X0H-BA*YDIF+XDIF+EYE(1)
        IXMIN=INT((XMIN-XBLC)/DX)+2
        IXMAX=INT((XMAX-XBLC)/DX)+1
        IF (IXMIN.LE.NXP .AND. IXMAX.GE.1) THEN
          IF (IXMIN.LT.1) IXMIN=1
          IF (IXMAX.GT.NXP) IXMAX=NXP
          XH=XBLC+DX*FLOAT(IXMIN-1)-EYE(1)
          K=(JY-1)*NXP+IXMIN
          DO 30 IX=IXMIN,IXMAX
            IF (ZMAX.GT.SBBUFF(K)) THEN
              DXH=DBLE(XH)
              DUXH=U*DXH
              DBL1=DUXH+DVYH-DWZE
              DBL2=DBL0+DXH*(QXX*DXH+2.0D0*(QXY*DYH-QZX*DZE))
              XLM=SNGL((-DBL1-SQRT(ABS(DBL1**2-XMU*DBL2)+DSMALL))/DBL2)
              SURF(3)=EYE(3)*(1.0-XLM)
              IF (SURF(3).GT.SBBUFF(K)) THEN
                SBBUFF(K)=SURF(3)
                IF (NC.EQ.0) THEN
                  SBBUFF(KSTART+K)=COL0
                ELSE
                  SURF(2)=EYE(2)+YH*XLM
                  SURF(1)=EYE(1)+XH*XLM
                  CALL SBEGLS(EYE,CENTRE,LIGHT,SURF,XL2,QXX,QYY,QZZ,QXY,
     *              QYZ,QZX,SMALL,LSHINE,COLOUR,EVEC,ICLINE,COSMIN)
                  IF (COLOUR.GT.2.0) THEN
                    SBBUFF(KSTART+K)=COLINE
                  ELSE
                    SBBUFF(KSTART+K)=COL0+COLOUR*COLSCL
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
            K=K+1
            XH=XH+DX
  30      CONTINUE
        ENDIF
        YH=YH+DY
  40  CONTINUE
      END SUBROUTINE SBELIP

      SUBROUTINE SBEGLS(EYE,CENTRE,LIGHT,SURF,XL2,QXX,QYY,QZZ,QXY,QYZ,
     *                  QZX,SMALL,LSHINE,COLOUR,EVEC,ICLINE,COSANG)
C     ----------------------------------------------------------------
C
C Support subroutine for SBELIP, to work out colour-shade.
C
      REAL    EYE(*),CENTRE(*),LIGHT(*),SURF(*),EVEC(3,*)
      REAL*8  QXX,QYY,QZZ,QXY,QYZ,QZX,DDX,DDY,DDZ
      LOGICAL LSHINE
      REAL    NORMAL(3),REFLEC(3),VIEW(3)
C
      COLOUR=0.0
      DX=SURF(1)-CENTRE(1)
      DY=SURF(2)-CENTRE(2)
      DZ=SURF(3)-CENTRE(3)
      IF (ICLINE.GE.0) THEN
        SNORM=1.0/SQRT(DX**2+DY**2+DZ**2)
        COS1=ABS(SNORM*(DX*EVEC(1,1)+DY*EVEC(2,1)+DZ*EVEC(3,1)))
        COS2=ABS(SNORM*(DX*EVEC(1,2)+DY*EVEC(2,2)+DZ*EVEC(3,2)))
        COS3=ABS(SNORM*(DX*EVEC(1,3)+DY*EVEC(2,3)+DZ*EVEC(3,3)))
        COSMIN=MIN(COS1,COS2,COS3)
        IF (COSMIN.LT.COSANG) THEN
          COLOUR=10.0
          RETURN
        ENDIF
      ENDIF
      DDX=DBLE(DX)
      DDY=DBLE(DY)
      DDZ=DBLE(DZ)
      NORMAL(1)=SNGL(QXX*DDX+QXY*DDY+QZX*DDZ)
      NORMAL(2)=SNGL(QXY*DDX+QYY*DDY+QYZ*DDZ)
      NORMAL(3)=SNGL(QZX*DDX+QYZ*DDY+QZZ*DDZ)
      XN2=0.0
      XNL=0.0
      DO 10 I=1,3
        XNL=XNL+NORMAL(I)*LIGHT(I)
        XN2=XN2+NORMAL(I)**2
  10  CONTINUE
      IF (XNL.GE.0.0) RETURN
      IF (LSHINE) THEN
        RFNORM=(XNL+XNL)/(XN2+SMALL)
        XRV=0.0
        DO 20 I=1,3
          VIEW(I)=EYE(I)-SURF(I)
          REFLEC(I)=LIGHT(I)-RFNORM*NORMAL(I)
          XRV=XRV+REFLEC(I)*VIEW(I)
  20    CONTINUE
        IF (XRV.LT.0.0) RETURN
        REF2=0.0
        VIEW2=0.0
        DO 30 I=1,3
          REF2=REF2+REFLEC(I)**2
          VIEW2=VIEW2+VIEW(I)**2
  30    CONTINUE
        COLOUR=MIN(XRV**2/(ABS(REF2*VIEW2)+SMALL),1.0)
      ELSE
        COLOUR=MIN(-XNL/SQRT(XN2*XL2+SMALL),1.0)
      ENDIF
      END SUBROUTINE SBEGLS

      SUBROUTINE SBTEXT(EYE,TEXT,ICOL,PIVOT,FJUST,ORIENT,SIZE)
C     --------------------------------------------------------
C
      use grpckg1inc
      REAL          EYE(*),PIVOT(*),ORIENT(3,2)
      CHARACTER*(*) TEXT
C
      REAL          END1(3),END2(3)
      INTEGER       SYMBOL(256),XYGRID(300),XYBASE,XYLEFT
      LOGICAL       LSTART,UNUSED
      SAVE          LSTART
      DATA          LSTART,SMALL,IJFLAG /.FALSE.,1.0E-10,-64/
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      Write a text string in 3-d perspective. All (x,y,z) values are 
C    taken to be given in world coordinates. The z-component of the 
C    eye-poisition should be positive and that of the text string should 
C    be negative; the viewing-screen is fixed at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    TEXT     C*1    I       *      The text string to be written.
C    ICOL     I*4    I       -      Colour index for text.
C    PIVOT    R*4    I       3      (x,y,z) coordinate of pivot point.
C    FJUST    R*4    I       -      Position of pivot along the text: 
C                                   0.0=left, 0.5=centre, 1.0=right.
C    ORIENT   R*4    I     3 x 2    (x,y,z) for X-length and Y-height
C                                   directions of the text.
C    SIZE     R*4    I       -      Height of the reference symbol "A".
C
C Globals
C    GRPCKG1.INC
C
C External Calls
!




C   SUBROUTINE   DESCRIPTION
C     GRSY00     Initialises font description.
C     GRSYDS     Decodes string into a list of Hershey symbol numbers.
C     GRSYXD     Obtains the polyline representation of a given symbol.
C     GRLEN      Calculates the length of the string.
C     SBLINE     Draws a 3-d line in perspective.
C
C History
C   D. S. Sivia      14 Sep 1995  Initial release.
C   D. S. Sivia      11 Oct 1995  Modified a J DO LOOP for a Pentium!
C-----------------------------------------------------------------------
C
C Carry out some initial checks.
C
      IF (EYE(3).LE.SMALL) RETURN
      IF (FJUST.LT.0.0 .OR. FJUST.GT.1.0) RETURN
      IF (SIZE.LT.SMALL) RETURN
      XLEN=SQRT(ORIENT(1,1)**2+ORIENT(2,1)**2+ORIENT(3,1)**2)
      YLEN=SQRT(ORIENT(1,2)**2+ORIENT(2,2)**2+ORIENT(3,2)**2)
      IF (XLEN.LT.SMALL .OR. YLEN.LT.SMALL) RETURN
      COSANG=(ORIENT(1,1)*ORIENT(1,2)+ORIENT(2,1)*ORIENT(2,2)+
     *        ORIENT(3,1)*ORIENT(3,2))/(XLEN*YLEN)
      IF (ABS(COSANG).GT.0.001) RETURN
      IF (.NOT.LSTART) THEN
        CALL GRSY00
        LSTART=.TRUE.
      ENDIF
      NCHAR=MIN(LEN(TEXT),256)
      DO 10 I=NCHAR,1,-1
  10    IF (TEXT(I:I).NE.' ') GOTO 1
   1  NCHMAX=I
      IF (NCHMAX.LT.1) RETURN
      DO 20 I=1,NCHMAX
  20    IF (TEXT(I:I).NE.' ') GOTO 2
   2  NCHMIN=I
C
C Calculate the parameters for the Hershey --> world coordinates 
C transformation.
C
      CALL GRLEN(TEXT(NCHMIN:NCHMAX),D)
      D=D*2.5/GRCFAC(GRCIDE)
      CALL GRSYDS(ISYMBA,NSYMBS,'A',1)
      CALL GRSYXD(ISYMBA,XYGRID,UNUSED)
      TSCL=SIZE/FLOAT(XYGRID(3)-XYGRID(2))
      XNORM=TSCL/XLEN
      YNORM=TSCL/YLEN
      XX=ORIENT(1,1)*XNORM
      XY=ORIENT(2,1)*XNORM
      XZ=ORIENT(3,1)*XNORM
      YX=ORIENT(1,2)*YNORM
      YY=ORIENT(2,2)*YNORM
      YZ=ORIENT(3,2)*YNORM
      X0=PIVOT(1)-FJUST*D*XX
      Y0=PIVOT(2)-FJUST*D*XY
      Z0=PIVOT(3)-FJUST*D*XZ
      Z1=PIVOT(3)+(1.0-FJUST)*D*XZ
      IF (Z0.GT.-SMALL .OR. Z1.GT.-SMALL) RETURN
C
C Write out the text string, character by character.
C
      DX=0.0
      DY=0.0
      DZ=0.0
      FNTBAS=0.0
      FNTFAC=1.0
      IFNTLV=0
      CALL GRSYDS(SYMBOL,NSYMBS,TEXT(NCHMIN:NCHMAX),1)
      DO 40 K=1,NSYMBS
        KSYMB=SYMBOL(K)
        IF (KSYMB.LT.0) THEN
          IF (KSYMB.EQ.-1) THEN
            IFNTLV=IFNTLV+1
            FNTBAS=FNTBAS+16.0*FNTFAC
            FNTFAC=0.75**ABS(IFNTLV)
          ELSEIF (KSYMB.EQ.-2) THEN
            IFNTLV=IFNTLV-1
            FNTFAC=0.75**ABS(IFNTLV)
            FNTBAS=FNTBAS-16.0*FNTFAC
          ELSEIF (KSYMB.EQ.-3) THEN
            X0=X0-DX
            Y0=Y0-DY
            Z0=Z0-DZ
          ENDIF
          GOTO 40
        ENDIF
        CALL GRSYXD(KSYMB,XYGRID,UNUSED)
        IF (.NOT. UNUSED) THEN
          XYBASE=XYGRID(2)
          XYLEFT=XYGRID(4)
          RLX=FLOAT(XYGRID(6)-XYLEFT)*FNTFAC
          RLY=FLOAT(XYGRID(7)-XYBASE)*FNTFAC+FNTBAS
          END1(1)=X0+RLX*XX+RLY*YX
          END1(2)=Y0+RLX*XY+RLY*YY
          END1(3)=Z0+RLX*XZ+RLY*YZ
          J=8
          DO 30 JJ=8,298,2
            IX=XYGRID(J)
            JY=XYGRID(J+1)
            IF (JY.EQ.IJFLAG) GOTO 3
            IF (IX.EQ.IJFLAG) THEN
              J=J+2
              RLX=FLOAT(XYGRID(J)-XYLEFT)*FNTFAC
              RLY=FLOAT(XYGRID(J+1)-XYBASE)*FNTFAC+FNTBAS
              END1(1)=X0+RLX*XX+RLY*YX
              END1(2)=Y0+RLX*XY+RLY*YY
              END1(3)=Z0+RLX*XZ+RLY*YZ
            ELSE
              RLX=FLOAT(IX-XYLEFT)*FNTFAC
              RLY=FLOAT(JY-XYBASE)*FNTFAC+FNTBAS
              END2(1)=X0+RLX*XX+RLY*YX
              END2(2)=Y0+RLX*XY+RLY*YY
              END2(3)=Z0+RLX*XZ+RLY*YZ
              CALL SBLINE(EYE,END1,END2,ICOL,.FALSE.)
              CALL SBRCOP(END2,END1,3)
            ENDIF
            J=J+2            
  30      CONTINUE
        ENDIF
  3     XL=FNTFAC*FLOAT(XYGRID(5)-XYLEFT)
        DX=XL*XX
        DY=XL*XY
        DZ=XL*XZ
        X0=X0+DX
        Y0=Y0+DY
        Z0=Z0+DZ
  40  CONTINUE
      END SUBROUTINE SBTEXT

      SUBROUTINE SBCPLN(EYE,LATICE,IC1,IC2,LIGHT,SLNORM,APOINT,ICEDGE,
     *                  ITRANS)
C     ----------------------------------------------------------------
C
      REAL    EYE(*),LATICE(3,*),LIGHT(*)
      REAL    SLNORM(*),APOINT(*)
C
      REAL    END1(3),END2(3),VERT1(3,12),VERT2(3,12)
      LOGICAL LVERT(12)
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
!




C      This subroutine plots a diffusively-lit, semi-transparent, 
C    coloured plane through a unit cell. All (x,y,z) values are taken to
C    be given in world coordinates. The z-component of the eye-poisition 
C    should be positive and that of all the lattice-vertices should be 
C    negative; the viewing-screen is fixed at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    LATICE   R*4    I     3 x 4    (x,y,z) coordinates of the origin
C                                   and the a, b & C lattice-vertices.
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for the shading.
C    LIGHT    R*4    I       3      (x,y,z) direction of flood-light.
C    SLNORM   R*4    I       3      (x,y,z) direction of normal to plane.
C    APONIT   R*4    I       3      (x,y,z) coordinate of a point within
C                                   the plane.
C    ICEDGE   I*4    I       -      If >=0, it's the colour-index for
C                                   the boundary of the plane.
C    ITRANS   I*4    I       -      Level of transparency:
C                                     0 = 0%; 1 = 25%; 2 = 50%; 3 = 75%.
C
C Globals 
C    None
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     SBSLC1     Checks whether a side of the unit cell is cut by the
C                plane & calculates the coordinates of the intersection.
C     SBCPL1     Order the verticies of the polygon-of-intersection.
C     SBLIN1     Calculates the projection of (x,y,z) on viewing screen.
C     SBPLAN     Plots a coloured plane.
C     SBPLNT     Plots a semi-transparent coloured plane.
C
C History
C   D. S. Sivia      26 Sep 1995  Initial release.
C-----------------------------------------------------------------------
C
C Carry out some initial checks.
C
      SMALL=1.0E-10
      SMALL2=SMALL**2
      IF (EYE(3).LE.SMALL) RETURN
      SNRM=1.0/SQRT(SLNORM(1)**2+SLNORM(2)**2+SLNORM(3)**2+SMALL2)
      XN=SLNORM(1)*SNRM
      YN=SLNORM(2)*SNRM
      ZN=SLNORM(3)*SNRM
      XAE=EYE(1)-APOINT(1)
      YAE=EYE(2)-APOINT(2)
      ZAE=EYE(3)-APOINT(3)
      XLNORM=DBLE(XN*XAE)+DBLE(YN*YAE)+DBLE(ZN*ZAE)
      COSNRM=SNGL(XLNORM/SQRT(DBLE(XAE**2)+DBLE(YAE**2)+DBLE(ZAE**2)
     *      +DBLE(SMALL2)))
      IF (ABS(COSNRM).LT.0.001) RETURN
      DO 10 J=1,3
        DX=LATICE(1,J+1)-LATICE(1,1)
        DY=LATICE(2,J+1)-LATICE(2,1)
        DZ=LATICE(3,J+1)-LATICE(3,1)
        D2=DX**2+DY**2+DZ**2
        IF (D2.LT.SMALL2) RETURN
  10  CONTINUE
C
C Calculate the coordinates of the polygon-of-intersection between the
C the plane and the edges of the unit cell.
C
      NVERT=0
      II=0
      DO 20 L=1,12,4
        I=II+2
        J=MOD(II+1,3)+2
        K=MOD(II+2,3)+2
        CALL SBSLC1(LATICE,LATICE(1,K),XN,YN,ZN,APOINT,LVERT(L),
     *              VERT1(1,L),NVERT)
        END1(1)=LATICE(1,I)+LATICE(1,J)-LATICE(1,1)
        END1(2)=LATICE(2,I)+LATICE(2,J)-LATICE(2,1)
        END1(3)=LATICE(3,I)+LATICE(3,J)-LATICE(3,1)
        CALL SBSLC1(LATICE(1,I),END1,XN,YN,ZN,APOINT,LVERT(L+1),
     *              VERT1(1,L+1),NVERT)
        CALL SBSLC1(LATICE(1,J),END1,XN,YN,ZN,APOINT,LVERT(L+2),
     *              VERT1(1,L+2),NVERT)
        END2(1)=END1(1)+LATICE(1,K)-LATICE(1,1)
        END2(2)=END1(2)+LATICE(2,K)-LATICE(2,1)
        END2(3)=END1(3)+LATICE(3,K)-LATICE(3,1)
        CALL SBSLC1(END1,END2,XN,YN,ZN,APOINT,LVERT(L+3),
     *              VERT1(1,L+3),NVERT)
        II=II+1
  20  CONTINUE
      IF (NVERT.LT.3) RETURN
      CALL SBCPL1(EYE,LVERT,VERT1,VERT2,NVERT,XN,YN,ZN,ICEDGE,ZDLINE)
C
C Plot the plane.
C
      ITLEVL=MAX(MIN(ITRANS,3),0)
      IF (ITLEVL.EQ.0) THEN
        CALL SBPLAN(EYE,NVERT,VERT2,IC1,IC2,LIGHT)
      ELSE
        CALL SBPLNT(EYE,NVERT,VERT2,IC1,IC2,LIGHT,ITLEVL)
      ENDIF
      END SUBROUTINE SBCPLN

      SUBROUTINE SBCPL1(EYE,LVERT,VERT1,VERT2,NVERT,XN,YN,ZN,ICOL,ZDIF)
C     -----------------------------------------------------------------
C
      REAL    EYE(*),VERT1(3,*),VERT2(3,*),VERT3(3),ANGLE(12)
      INTEGER ISORT(12)
      LOGICAL LVERT(*)
C
      IV1=0
      XBAR=0.0
      YBAR=0.0
      ZBAR=0.0
      ZMIN=+1.0E20
      ZMAX=-1.0E20
      DO 10 K=1,12
        ZMIN=MIN(ZMIN,VERT1(3,K))
        ZMAX=MAX(ZMAX,VERT1(3,K))
        IF (LVERT(K)) THEN
          IF (IV1.LE.0) IV1=K
          XBAR=XBAR+VERT1(1,K)
          YBAR=YBAR+VERT1(2,K)
          ZBAR=ZBAR+VERT1(3,K)
        ENDIF
  10  CONTINUE
      ZDIF=(ZMAX-ZMIN)/5000.0
      XBAR=XBAR/FLOAT(NVERT)
      YBAR=YBAR/FLOAT(NVERT)
      ZBAR=ZBAR/FLOAT(NVERT)
      XREF=VERT1(1,IV1)-XBAR
      YREF=VERT1(2,IV1)-YBAR
      ZREF=VERT1(3,IV1)-ZBAR
      REFNRM=1.0/SQRT(XREF**2+YREF**2+ZREF**2+1.0E-20)
      XREF=XREF*REFNRM
      YREF=YREF*REFNRM
      ZREF=ZREF*REFNRM
      XNRM=YREF*ZN-YN*ZREF
      YNRM=ZREF*XN-ZN*XREF
      ZNRM=XREF*YN-XN*YREF
      J=1
      ANGLE(J)=0.0
      ISORT(J)=IV1
      CALL SBRCOP(VERT1(1,IV1),VERT2(1,J),3)
      DO 40 K=IV1+1,12
        IF (LVERT(K)) THEN
          J=J+1
          XVEC=VERT1(1,K)-XBAR
          YVEC=VERT1(2,K)-YBAR
          ZVEC=VERT1(3,K)-ZBAR
          X=XVEC*XREF+YVEC*YREF+ZVEC*ZREF
          Y=XVEC*XNRM+YVEC*YNRM+ZVEC*ZNRM
          ANGJ=ATAN2(Y,X)
          CALL SBRCOP(VERT1(1,K),VERT3,3)
          DO 20 I=1,J-1
  20        IF (ANGJ.LT.ANGLE(I)) GOTO 1
   1      II=I
           DO 30 I=J,II+1,-1
            CALL SBRCOP(VERT2(1,I-1),VERT2(1,I),3)
            ANGLE(I)=ANGLE(I-1)
            ISORT(I)=ISORT(I-1)
  30      CONTINUE
          CALL SBRCOP(VERT3,VERT2(1,II),3)
          ANGLE(II)=ANGJ
          ISORT(II)=K
        ENDIF
  40  CONTINUE
      IF (ICOL.GE.0.0) THEN
        DO 50 I=1,NVERT-1
          J=ISORT(I)
          K=ISORT(I+1)
          CALL SBLINE(EYE,VERT1(1,J),VERT1(1,K),ICOL,.FALSE.)
  50    CONTINUE
        CALL SBLINE(EYE,VERT1(1,K),VERT1(1,ISORT(1)),ICOL,.FALSE.)
      ENDIF
      END SUBROUTINE SBCPL1

      SUBROUTINE SBTBAL(EYE,CENTRE,RADIUS,IC1,IC2,LIGHT,LSHINE,X0,Y0,R0,
     *                  ITRANS)
C     ------------------------------------------------------------------
C
      REAL            EYE(*),CENTRE(*),LIGHT(*)
      LOGICAL         LSHINE

      REAL            SURF(3)
      REAL*8          ALFA,BETA,GAMA,XMU,A,B,C,DET,Q,DX0H,DY0H
      REAL*8          DZE,DZE2,DGAMZE,DBL1,DBL2,DSMALL
      REAL*8          XL0,XL1,HYP,SINPHI,COSPHI,R1,R2
      LOGICAL         LPS,LCOLOR
      COMMON /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      This subroutine plots a semi-transparent shiny or matt coloured 
C    ball. All (x,y,z) values are taken to be given in world coordinates.
C    The z-component of the eye-poisition should be positive and that of
C    the ball-centre should be negative (< -radius); the viewing-screen
C    is fixed at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    CENTRE   R*4    I       3      (x,y,z) coordinate of ball-centre.
C    RADIUS   R*4    I       -      Radius of ball.
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for shading.
C    LIGHT    R*4    I       3      (x,y,z) direction of flood-light.
C    LSHINE   L*1    I       -      Shiny ball if .TRUE., else diffuse.
C    X0,Y0    R*4    O       -      Centre of projected ball.
C    R0       R*4    O       -      Average radius of projected ball.
C    ITRANS   I*4    I       -      Level of transparency:
C                                        1 = 25%; 2 = 50%; 3 = 75%.
C
C Globals 
C    SFTBUF
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     SBGLOS     Works out colour-shade for surface of ball.
C
C History
C   D. S. Sivia       8 Jul 1996  Initial release.
C-----------------------------------------------------------------------
C
C Some initial checks.
C
      SMALL=1.0E-20
      DSMALL=DBLE(SMALL)
      IF (EYE(3).LE.0.0) RETURN
      IF (RADIUS.LE.0.0) RETURN
      IF (CENTRE(3).GT.-RADIUS) RETURN
C
C Calculate parameters of projected ellipse.
C
      DZE=DBLE(EYE(3))
      DZE2=DZE**2
      ALFA=DBLE(EYE(1)-CENTRE(1))
      BETA=DBLE(EYE(2)-CENTRE(2))
      GAMA=DBLE(EYE(3)-CENTRE(3))
      XMU=DBLE(RADIUS**2)-(ALFA**2+BETA**2+GAMA**2)
      A=XMU*(XMU+ALFA**2)
      B=XMU*ALFA*BETA
      C=XMU*(XMU+BETA**2)
      DET=ABS(A*C-B**2)+DSMALL
      DX0H=GAMA*XMU*DZE*(ALFA*C-BETA*B)/DET
      DY0H=GAMA*XMU*DZE*(BETA*A-ALFA*B)/DET
      Q=A*DX0H**2+2.0*B*DX0H*DY0H+C*DY0H**2-XMU*(XMU+GAMA**2)*DZE2
      X0H=SNGL(DX0H)
      Y0H=SNGL(DY0H)
      DX=(XTRC-XBLC)/FLOAT(NXP-1)
      DY=(YTRC-YBLC)/FLOAT(NYP-1)
      XDIF=SNGL(SQRT(ABS(C*Q/DET)+DSMALL))
      XMIN=X0H-XDIF+EYE(1)
      XMAX=X0H+XDIF+EYE(1)
      IXMIN=INT((XMIN-XBLC)/DX)+2
      IXMAX=INT((XMAX-XBLC)/DX)+1
      IF (IXMIN.GT.NXP .OR. IXMAX.LT.1) RETURN
      YDIF=(SQRT(ABS(A*Q/DET)+DSMALL))
      YMIN=Y0H-YDIF+EYE(2)
      YMAX=Y0H+YDIF+EYE(2)
      JYMIN=INT((YMIN-YBLC)/DY)+2
      JYMAX=INT((YMAX-YBLC)/DY)+1
      IF (JYMIN.GT.NYP .OR. JYMAX.LT.1) RETURN
      IF (JYMIN.LT.1) JYMIN=1
      IF (JYMAX.GT.NYP) JYMAX=NYP
      ZMAX=CENTRE(3)+RADIUS
      X0=X0H+EYE(1)
      Y0=Y0H+EYE(2)
      COREL=SNGL(SQRT(ABS((B*B)/(A*C))+DSMALL))
      IF (COREL.GT.0.0001) THEN
        XL0=(A+C)/2.0D0
        XL1=XL0-SQRT(ABS(XL0*XL0-DET)+DSMALL)
        HYP=SQRT((XL1-A)**2+B**2+DSMALL)
        SINPHI=(XL1-A)/HYP
        COSPHI=B/HYP
      ELSE
        SINPHI=0.0D0
        COSPHI=1.0D0
      ENDIF
      R1=SQRT(Q/(A*COSPHI*COSPHI+SINPHI*(C*SINPHI+2.0*B*COSPHI)))
      R2=SQRT(Q/(A*SINPHI*SINPHI+COSPHI*(C*COSPHI-2.0*B*SINPHI)))
      R0=SNGL((R1+R2)/2.0D0)
C
C Fill the inside of the projected ellipse with the right colours.
C
      ITLEVL=MAX(MIN(ITRANS,3),1)
      NC=IC2-IC1
      COL0=FLOAT(IC1)
      COLSCL=FLOAT(NC)
      XL2=LIGHT(1)**2+LIGHT(2)**2+LIGHT(3)**2
      XN2=RADIUS**2
      XNL2=1.0/SQRT(XN2*XL2+SMALL)
      XN3=1.0/(XN2+SMALL)
      YH=YBLC+DY*FLOAT(JYMIN-1)-EYE(2)
      DGAMZE=GAMA*DZE
      BA=SNGL(B/A)
      DO 20 JY=JYMIN,JYMAX
        JTEST=MOD(JY,2)
        IF (ITLEVL.EQ.3 .AND. JTEST.EQ.1) GOTO 19
        YH2=YH**2
        BETAYH=BETA*YH
        YDIF=YH-Y0H
        XDIF=SNGL(SQRT(ABS(A*Q-DET*DBLE(YDIF**2))+DSMALL)/A)
        XMIN=X0H-BA*YDIF-XDIF+EYE(1)
        XMAX=X0H-BA*YDIF+XDIF+EYE(1)
        IXMIN=INT((XMIN-XBLC)/DX)+2
        IXMAX=INT((XMAX-XBLC)/DX)+1
        IF (IXMIN.LE.NXP .AND. IXMAX.GE.1) THEN
          IF (IXMIN.LT.1) IXMIN=1
          IF (IXMAX.GT.NXP) IXMAX=NXP
          XH=XBLC+DX*FLOAT(IXMIN-1)-EYE(1)
          K=(JY-1)*NXP+IXMIN
          DO 10 IX=IXMIN,IXMAX
            ITEST=MOD(IX,2)
            IF (ITLEVL.EQ.1) THEN
              IF ((ITEST+JTEST).EQ.0) GOTO 9
            ELSEIF (ITLEVL.EQ.2) THEN
              IF ((ITEST+JTEST).EQ.1) GOTO 9
            ELSE
              IF (ITEST.EQ.1) GOTO 9
            ENDIF
            IF (ZMAX.GT.SBBUFF(K)) THEN
              XH2=XH**2
              ALFAXH=ALFA*XH
              DBL1=DBLE(ALFAXH+BETAYH)-DGAMZE
              DBL2=DBLE(XH2+YH2)+DZE2
              XLM=SNGL((-DBL1-SQRT(ABS(DBL1**2+XMU*DBL2)+DSMALL))/DBL2)
              SURF(3)=EYE(3)*(1.0-XLM)
              IF (SURF(3).GT.SBBUFF(K)) THEN
                SBBUFF(K)=SURF(3)
                IF (NC.EQ.0) THEN
                  SBBUFF(KSTART+K)=COL0
                ELSE
                  SURF(2)=EYE(2)+YH*XLM
                  SURF(1)=EYE(1)+XH*XLM
                  CALL SBGLOS(EYE,CENTRE,LIGHT,SURF,XNL2,XN3,SMALL,
     *                        LSHINE,COLOUR)
                  SBBUFF(KSTART+K)=COL0+COLOUR*COLSCL
                ENDIF
              ENDIF
            ENDIF
   9        K=K+1
            XH=XH+DX
  10      CONTINUE
        ENDIF
  19    YH=YH+DY
  20  CONTINUE
      END SUBROUTINE SBTBAL

      SUBROUTINE SBTSUR(EYE,LATICE,DENS,N1,N2,N3,DSURF,IC1,IC2,LIGHT,
     *                  LSHINE,ITRANS)
C     ---------------------------------------------------------------
C
      REAL             EYE(*),LATICE(3,*),DENS(0:N1,0:N2,0:N3),LIGHT(*)
      LOGICAL          LSHINE
C
      REAL*8           XLNORM,PNEYE(3),DSMAL2
      REAL             BAS(3,3),MTRX
      REAL             XYZ(3),DXYZ(3,3),FRCXYZ(12),DDXYZ(3,12,2)
      REAL             DLOCAL(8),VERT(3,12),GRDSCL(3)
      LOGICAL          LPS,LCOLOR,LEMPTY
      INTEGER          IVERT(8)
      COMMON  /SRFCOM/ GRDCUB(3,8),MTRX(3,3),ORIG(3),XL2,COL0,COLSCL
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
!




C      This subroutine plots a semi-transparent iso-surface through a 
C    unit-cell of density. All (x,y,z) values are taken to be given in 
C    world coordinates. The z-component of the eye-poisition should be 
C    positive and that of all the lattice-vertices should be negative; 
C    the viewing-screen is fixed at z=0.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    EYE      R*4    I       3      (x,y,z) coordinate of eye-position.
C    LATICE   R*4    I     3 x 4    (x,y,z) coordinates of the origin
C                                   and the a, b & C lattice-vertices.
C    DENS     R*4    I     (N1+1)   The density at regular points within
C                        x (N2+1)   the unit cell, wrapped around so
C                        x (N3+1)   that DENS(0,J,K)=DENS(N1,J,K) etc..
C    N1,N2,N3 I*4    I       -      The dimensions of the unit-cell grid.
C    DSURF    R*4    I       -      Density for the iso-surface.
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for the shading.
C    LIGHT    R*4    I       3      (x,y,z) direction of flood-light.
C    LSHINE   L*1    I       -      Shiny surface if TRUE, else diffuse.
C    ITRANS   I*4    I       -      Level of transparency:
C                                        1 = 25%; 2 = 50%; 3 = 75%.
C
C Globals 
C    SFTBUF
C    SRFCOM
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     SBSRF0     A quick check in case there are no iso-surafces.
C     SBSRF1     Anlayses a 2-d box in the surface of the unit-cell.
C     SBTSF2     Paints a 2-d box in the surface of the unit-cell.
C     SBSRF3     Analyses a 3-d box within the unit-cell.
C     SBSRF4     Initialises the gradients for a 3-d box.
C     SBTSF5     Breaks up the iso-surface in a 3-d box into triangles.
C     SBTSF6     Paints a triangular patch of a semi-transp iso-surface.
C
C History
C   D. S. Sivia       9 Jul 1996  Initial release.
C   D. S. Sivia      24 Oct 1997 "Safe-guarded" some rounding errors.
C-----------------------------------------------------------------------
C
C Carry out some initial checks.
C
      SMALL=1.0E-10
      SMALL2=SMALL**2
      DSMAL2=DBLE(SMALL2)
      IF (EYE(3).LE.SMALL) RETURN
      IF (N1.LT.1 .OR. N2.LT.1 .OR. N3.LT.1) RETURN
      XL2=LIGHT(1)**2+LIGHT(2)**2+LIGHT(3)**2
      IF (XL2.LT.SMALL) RETURN
      IF (LATICE(3,1).GE.0.0) RETURN
      ZFAR=LATICE(3,2)+LATICE(3,3)+LATICE(3,4)-2.0*LATICE(3,1)
      IF (ZFAR.GE.0.0) RETURN
      DO 10 J=1,3
        IF (LATICE(3,J+1).GE.0.0) RETURN
        BAS(1,J)=LATICE(1,J+1)-LATICE(1,1)
        BAS(2,J)=LATICE(2,J+1)-LATICE(2,1)
        BAS(3,J)=LATICE(3,J+1)-LATICE(3,1)
        IF ((ZFAR-BAS(3,J)).GE.0.0) RETURN
        BAS2J=BAS(1,J)**2+BAS(2,J)**2+BAS(3,J)**2
        IF (BAS2J.LT.SMALL2) RETURN
  10  CONTINUE
      NTOT=(N1+1)*(N2+1)*(N3+1)
      CALL SBSRF0(DENS,NTOT,DSURF,LEMPTY)
      IF (LEMPTY) RETURN
C
C Set up matrix for real-space to lattice-index transformation.
C
      XN1=0.99999*FLOAT(N1)
      XN2=0.99999*FLOAT(N2)
      XN3=0.99999*FLOAT(N3)
      DET=BAS(1,1)*BAS(2,2)*BAS(3,3)+BAS(1,2)*BAS(2,3)*BAS(3,1)
     *   +BAS(1,3)*BAS(2,1)*BAS(3,2)-BAS(3,1)*BAS(2,2)*BAS(1,3)
     *   -BAS(3,2)*BAS(2,3)*BAS(1,1)-BAS(3,3)*BAS(2,1)*BAS(1,2)
      IF (ABS(DET).LT.SMALL2) RETURN
      DETNRM=1.0/DET
      MTRX(1,1)=XN1*DETNRM*(BAS(2,2)*BAS(3,3)-BAS(2,3)*BAS(3,2))
      MTRX(1,2)=XN2*DETNRM*(BAS(2,3)*BAS(3,1)-BAS(2,1)*BAS(3,3))
      MTRX(1,3)=XN3*DETNRM*(BAS(2,1)*BAS(3,2)-BAS(2,2)*BAS(3,1))
      MTRX(2,1)=XN1*DETNRM*(BAS(3,2)*BAS(1,3)-BAS(3,3)*BAS(1,2))
      MTRX(2,2)=XN2*DETNRM*(BAS(3,3)*BAS(1,1)-BAS(3,1)*BAS(1,3))
      MTRX(2,3)=XN3*DETNRM*(BAS(3,1)*BAS(1,2)-BAS(3,2)*BAS(1,1))
      MTRX(3,1)=XN1*DETNRM*(BAS(1,2)*BAS(2,3)-BAS(1,3)*BAS(2,2))
      MTRX(3,2)=XN2*DETNRM*(BAS(1,3)*BAS(2,1)-BAS(1,1)*BAS(2,3))
      MTRX(3,3)=XN3*DETNRM*(BAS(1,1)*BAS(2,2)-BAS(1,2)*BAS(2,1))
      CALL SBRCOP(LATICE,ORIG,3)
C
C Some general initialisations.
C
      DDSURF=MAX(ABS(DSURF),SMALL)
      IF (DSURF.LT.0.0) DDSURF=-DDSURF
      GRDSCL(1)=-0.5/(DDSURF*FLOAT(N1))
      GRDSCL(2)=-0.5/(DDSURF*FLOAT(N2))
      GRDSCL(3)=-0.5/(DDSURF*FLOAT(N3))
      COL0=FLOAT(IC1)
      COLSCL=FLOAT(IC2-IC1)
      DO 30 I=1,3
        DXYZ(I,1)=BAS(I,1)/FLOAT(N1)
        DXYZ(I,2)=BAS(I,2)/FLOAT(N2)
        DXYZ(I,3)=BAS(I,3)/FLOAT(N3)
        DDXYZ(I,1,1)=0.0
        DDXYZ(I,1,2)=DXYZ(I,1)
        DDXYZ(I,2,1)=DDXYZ(I,1,1)+DDXYZ(I,1,2)
        DDXYZ(I,2,2)=DXYZ(I,2)
        DDXYZ(I,3,1)=DDXYZ(I,2,1)+DDXYZ(I,2,2)
        DDXYZ(I,3,2)=-DXYZ(I,1)
        DDXYZ(I,4,1)=DDXYZ(I,3,1)+DDXYZ(I,3,2)
        DDXYZ(I,4,2)=-DXYZ(I,2)
        DO 20 J=1,4
          DDXYZ(I,J+4,1)=DDXYZ(I,J,1)
          DDXYZ(I,J+4,2)=DXYZ(I,3)
          DDXYZ(I,J+8,1)=DDXYZ(I,J,1)+DXYZ(I,3)
          DDXYZ(I,J+8,2)=DDXYZ(I,J,2)
  20    CONTINUE
  30  CONTINUE
C
C First paint the edges of the lattice.
C
      DO 60 IFACE=1,3
        I=IFACE
        J=MOD(IFACE,3)+1
        K=MOD(J,3)+1
        IF (IFACE.EQ.1) THEN
          IN=N1
          JN=N2
        ELSEIF (IFACE.EQ.2) THEN
          IN=N2
          JN=N3
        ELSE
          IN=N3
          JN=N1
        ENDIF
        KK=0
        XN=BAS(2,J)*BAS(3,I)-BAS(2,I)*BAS(3,J)
        YN=BAS(3,J)*BAS(1,I)-BAS(3,I)*BAS(1,J)
        ZN=BAS(1,J)*BAS(2,I)-BAS(1,I)*BAS(2,J)
        DNRM=SQRT(XN**2+YN**2+ZN**2+SMALL2)
        PNEYE(1)=DBLE(EYE(1)-0.5*(LATICE(1,I+1)+LATICE(1,J+1)))
        PNEYE(2)=DBLE(EYE(2)-0.5*(LATICE(2,I+1)+LATICE(2,J+1)))
        PNEYE(3)=DBLE(EYE(3)-0.5*(LATICE(3,I+1)+LATICE(3,J+1)))
        DEYE=SNGL(SQRT(PNEYE(1)**2+PNEYE(2)**2+PNEYE(3)**2+DSMAL2))
        XLNORM=DBLE(XN)*PNEYE(1)+DBLE(YN)*PNEYE(2)+DBLE(ZN)*PNEYE(3)
        COSSEE=SNGL(XLNORM)/(DEYE*DNRM)
        IF (COSSEE.LT.0.001) THEN
          KK=N3
          IF (IFACE.EQ.2) KK=N1
          IF (IFACE.EQ.3) KK=N2
          PNEYE(1)=PNEYE(1)+DBLE(BAS(1,K))
          PNEYE(2)=PNEYE(2)+DBLE(BAS(2,K))
          PNEYE(3)=PNEYE(3)+DBLE(BAS(3,K))
          DEYE=SNGL(SQRT(PNEYE(1)**2+PNEYE(2)**2+PNEYE(3)**2+DSMAL2))
          XLNORM=DBLE(XN)*PNEYE(1)+DBLE(YN)*PNEYE(2)+DBLE(ZN)*PNEYE(3)
          COSSEE=-SNGL(XLNORM)/(DEYE*DNRM)
        ENDIF
        IF (COSSEE.GT.0.001) THEN
          XYZ1=FLOAT(KK)*DXYZ(1,K)+LATICE(1,1)
          XYZ2=FLOAT(KK)*DXYZ(2,K)+LATICE(2,1)
          XYZ3=FLOAT(KK)*DXYZ(3,K)+LATICE(3,1)
          DO 50 J1=1,JN
            J0=J1-1
            DO 40 I1=1,IN
              I0=I1-1
              IF (IFACE.EQ.1) THEN
                DLOCAL(1)=DENS(I0,J0,KK)-DSURF
                DLOCAL(2)=DENS(I1,J0,KK)-DSURF
                DLOCAL(3)=DENS(I1,J1,KK)-DSURF
                DLOCAL(4)=DENS(I0,J1,KK)-DSURF
              ELSEIF (IFACE.EQ.2) THEN
                DLOCAL(1)=DENS(KK,I0,J0)-DSURF
                DLOCAL(2)=DENS(KK,I1,J0)-DSURF
                DLOCAL(3)=DENS(KK,I1,J1)-DSURF
                DLOCAL(4)=DENS(KK,I0,J1)-DSURF
              ELSE
                DLOCAL(1)=DENS(J0,KK,I0)-DSURF
                DLOCAL(2)=DENS(J0,KK,I1)-DSURF
                DLOCAL(3)=DENS(J1,KK,I1)-DSURF
                DLOCAL(4)=DENS(J1,KK,I0)-DSURF
              ENDIF
              CALL SBSRF1(DLOCAL,IBSIDE,FRCXYZ)
              IF (IBSIDE.NE.0) THEN
                XYZ(1)=XYZ1+DXYZ(1,I)*FLOAT(I0)
                XYZ(2)=XYZ2+DXYZ(2,I)*FLOAT(I0)
                XYZ(3)=XYZ3+DXYZ(3,I)*FLOAT(I0)
                CALL SBTSF2(XYZ,DXYZ(1,I),DXYZ(1,J),IBSIDE,FRCXYZ,VERT,
     *                      EYE,LIGHT,LSHINE,ITRANS)
              ENDIF
  40        CONTINUE
            XYZ1=XYZ1+DXYZ(1,J)
            XYZ2=XYZ2+DXYZ(2,J)
            XYZ3=XYZ3+DXYZ(3,J)
  50      CONTINUE
        ENDIF
  60  CONTINUE
C
C Step through each "cube" in the lattice, and paint any isosurfaces
C found therein.
C
      X00K=LATICE(1,1)
      Y00K=LATICE(2,1)
      Z00K=LATICE(3,1)
      DO 90 K1=1,N3
        K0=K1-1
        DO 80 J1=1,N2
          J0=J1-1
          X0JK=X00K+DXYZ(1,2)*FLOAT(J0)
          Y0JK=Y00K+DXYZ(2,2)*FLOAT(J0)
          Z0JK=Z00K+DXYZ(3,2)*FLOAT(J0)
          DO 70 I1=1,N1
            I0=I1-1
            DLOCAL(1)=DENS(I0,J0,K0)-DSURF
            DLOCAL(2)=DENS(I1,J0,K0)-DSURF
            DLOCAL(3)=DENS(I1,J1,K0)-DSURF
            DLOCAL(4)=DENS(I0,J1,K0)-DSURF
            DLOCAL(5)=DENS(I0,J0,K1)-DSURF
            DLOCAL(6)=DENS(I1,J0,K1)-DSURF
            DLOCAL(7)=DENS(I1,J1,K1)-DSURF
            DLOCAL(8)=DENS(I0,J1,K1)-DSURF
            CALL SBSRF3(DLOCAL,IVERT,FRCXYZ,ISUMV,ISUMF)
            IF (ISUMV.NE.0) THEN
              XYZ(1)=X0JK+DXYZ(1,1)*FLOAT(I0)
              XYZ(2)=Y0JK+DXYZ(2,1)*FLOAT(I0)
              XYZ(3)=Z0JK+DXYZ(3,1)*FLOAT(I0)
              CALL SBSRF4(DENS,N1,N2,N3,I0,J0,K0,GRDSCL,BAS,GRDCUB)
              CALL SBTSF5(XYZ,DDXYZ,ISUMV,ISUMF,IVERT,FRCXYZ,VERT,EYE,
     *                    LIGHT,LSHINE,ITRANS)
            ENDIF
  70      CONTINUE
  80    CONTINUE
        X00K=X00K+DXYZ(1,3)
        Y00K=Y00K+DXYZ(2,3)
        Z00K=Z00K+DXYZ(3,3)
  90  CONTINUE
      END SUBROUTINE SBTSUR

      SUBROUTINE SBTSF2(XYZ,D1,D2,IB,FRC,VERT,EYE,LIGHT,LSHINE,ITRANS)
C     ----------------------------------------------------------------
C
      REAL    XYZ(*),D1(*),D2(*),FRC(*),VERT(3,*),EYE(*),LIGHT(*)
      LOGICAL LSHINE
C
      IF (IB.EQ.15) THEN
        DO 10 I=1,3
          VERT(I,1)=XYZ(I)
          VERT(I,2)=XYZ(I)+D1(I)
          VERT(I,3)=VERT(I,2)+D2(I)
          VERT(I,4)=XYZ(I)+D2(I)
  10    CONTINUE
        CALL SBTSF6(ITRANS,EYE,4,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.1) THEN
        DO 20 I=1,3
          VERT(I,1)=XYZ(I)
          VERT(I,2)=VERT(I,1)+FRC(1)*D1(I)
          VERT(I,3)=XYZ(I)+(1.0-FRC(4))*D2(I)
  20    CONTINUE
        CALL SBTSF6(ITRANS,EYE,3,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.2) THEN
        DO 30 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)
          VERT(I,2)=VERT(I,1)+FRC(2)*D2(I)
          VERT(I,3)=XYZ(I)+FRC(1)*D1(I)
  30    CONTINUE
        CALL SBTSF6(ITRANS,EYE,3,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.4) THEN
        DO 40 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)+D2(I)
          VERT(I,2)=VERT(I,1)-FRC(3)*D1(I)
          VERT(I,3)=VERT(I,1)-(1.0-FRC(2))*D2(I)
  40    CONTINUE
        CALL SBTSF6(ITRANS,EYE,3,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.8) THEN
        DO 50 I=1,3
          VERT(I,1)=XYZ(I)+D2(I)
          VERT(I,2)=VERT(I,1)-FRC(4)*D2(I)
          VERT(I,3)=VERT(I,1)+(1.0-FRC(3))*D1(I)
  50    CONTINUE
        CALL SBTSF6(ITRANS,EYE,3,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.7) THEN
        DO 60 I=1,3
          VERT(I,1)=XYZ(I)
          VERT(I,2)=VERT(I,1)+D1(I)
          VERT(I,3)=VERT(I,2)+D2(I)
          VERT(I,4)=VERT(I,3)-FRC(3)*D1(I)
          VERT(I,5)=XYZ(I)+(1.0-FRC(4))*D2(I)
  60    CONTINUE
        CALL SBTSF6(ITRANS,EYE,5,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.14) THEN
        DO 70 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)
          VERT(I,2)=VERT(I,1)+D2(I)
          VERT(I,3)=XYZ(I)+D2(I)
          VERT(I,4)=XYZ(I)+(1.0-FRC(4))*D2(I)
          VERT(I,5)=XYZ(I)+FRC(1)*D1(I)
  70    CONTINUE
        CALL SBTSF6(ITRANS,EYE,5,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.13) THEN
        DO 80 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)+D2(I)
          VERT(I,2)=XYZ(I)+D2(I)
          VERT(I,3)=XYZ(I)
          VERT(I,4)=XYZ(I)+FRC(1)*D1(I)
          VERT(I,5)=XYZ(I)+D1(I)+FRC(2)*D2(I)
  80    CONTINUE
        CALL SBTSF6(ITRANS,EYE,5,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.11) THEN
        DO 90 I=1,3
          VERT(I,1)=XYZ(I)+D2(I)
          VERT(I,2)=XYZ(I)
          VERT(I,3)=XYZ(I)+D1(I)
          VERT(I,4)=VERT(I,3)+FRC(2)*D2(I)
          VERT(I,5)=VERT(I,1)+(1.0-FRC(3))*D1(I)
  90    CONTINUE
        CALL SBTSF6(ITRANS,EYE,5,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.3) THEN
        DO 100 I=1,3
          VERT(I,1)=XYZ(I)
          VERT(I,2)=XYZ(I)+D1(I)
          VERT(I,3)=VERT(I,2)+FRC(2)*D2(I)
          VERT(I,4)=XYZ(I)+(1.0-FRC(4))*D2(I)
 100    CONTINUE
        CALL SBTSF6(ITRANS,EYE,4,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.6) THEN
        DO 110 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)
          VERT(I,2)=VERT(I,1)+D2(I)
          VERT(I,3)=VERT(I,2)-FRC(3)*D1(I)
          VERT(I,4)=XYZ(I)+FRC(1)*D1(I)
 110    CONTINUE
        CALL SBTSF6(ITRANS,EYE,4,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.12) THEN
        DO 120 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)+D2(I)
          VERT(I,2)=XYZ(I)+D2(I)
          VERT(I,3)=VERT(I,2)-FRC(4)*D2(I)
          VERT(I,4)=XYZ(I)+D1(I)+FRC(2)*D2(I)
 120    CONTINUE
        CALL SBTSF6(ITRANS,EYE,4,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.9) THEN
        DO 130 I=1,3
          VERT(I,1)=XYZ(I)+D2(I)
          VERT(I,2)=XYZ(I)
          VERT(I,3)=XYZ(I)+FRC(1)*D1(I)
          VERT(I,4)=VERT(I,1)+(1.0-FRC(3))*D1(I)
 130    CONTINUE
        CALL SBTSF6(ITRANS,EYE,4,VERT,LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.5) THEN
        DO 140 I=1,3
          VERT(I,1)=XYZ(I)
          VERT(I,2)=VERT(I,1)+FRC(1)*D1(I)
          VERT(I,3)=XYZ(I)+(1.0-FRC(4))*D2(I)
          VERT(I,4)=XYZ(I)+D1(I)+D2(I)
          VERT(I,5)=VERT(I,4)-FRC(3)*D1(I)
          VERT(I,6)=VERT(I,4)-(1.0-FRC(2))*D2(I)
 140    CONTINUE
        CALL SBTSF6(ITRANS,EYE,3,VERT,LSHINE,LIGHT,0) 
        CALL SBTSF6(ITRANS,EYE,3,VERT(1,4),LSHINE,LIGHT,0) 
      ELSEIF (IB.EQ.10) THEN
        DO 150 I=1,3
          VERT(I,1)=XYZ(I)+D1(I)
          VERT(I,2)=VERT(I,1)+FRC(2)*D2(I)
          VERT(I,3)=XYZ(I)+FRC(1)*D1(I)
          VERT(I,4)=XYZ(I)+D2(I)
          VERT(I,5)=VERT(I,4)-FRC(4)*D2(I)
          VERT(I,6)=VERT(I,4)+(1.0-FRC(3))*D1(I)
 150    CONTINUE
        CALL SBTSF6(ITRANS,EYE,3,VERT,LSHINE,LIGHT,0) 
        CALL SBTSF6(ITRANS,EYE,3,VERT(1,4),LSHINE,LIGHT,0) 
      ENDIF
      END SUBROUTINE SBTSF2

      SUBROUTINE SBTSF5(XYZ,DXYZ,ISV,ISF,IV,FRC,VERT,EYE,LIGHT,LSHINE,
     *                  ITRANS)
C     ----------------------------------------------------------------
C
      REAL    XYZ(*),DXYZ(3,12,*),FRC(*),VERT(3,*),EYE(*),LIGHT(*)
      INTEGER IV(*),IV4MAP(12)
      LOGICAL LSHINE
      DATA    IV4MAP /12,8,4,3,11,7,6,2,10,9,5,1/
C
      IF (ISV.EQ.1) THEN
        CALL STSF5A(ITRANS,XYZ,DXYZ,FRC,VERT,IV(1),EYE,LSHINE,LIGHT)
      ELSEIF (ISV.EQ.2) THEN
        IF (ISF.EQ.6) THEN
          CALL STSF5A(ITRANS,XYZ,DXYZ,FRC,VERT,IV(1),EYE,LSHINE,LIGHT)
          CALL STSF5A(ITRANS,XYZ,DXYZ,FRC,VERT,IV(2),EYE,LSHINE,LIGHT)
        ELSE
          IJDIF=IV(2)-IV(1)
          IF (IV(1).LE.4) THEN
            IF (IV(2).LE.4) THEN
              K2=IV(1)
              IF (IJDIF.EQ.3) K2=IV(2)
            ELSE
              K2=IV(2)
            ENDIF
          ELSE
            K2=IV(1)+4
            IF (IJDIF.EQ.3) K2=IV(2)+4
          ENDIF
          CALL STSF5B(ITRANS,XYZ,DXYZ,FRC,VERT,K2,EYE,LSHINE,LIGHT,1)
        ENDIF
      ELSEIF (ISV.EQ.3) THEN
        IF (ISF.EQ.9) THEN
          DO 10 I=1,3
  10        CALL STSF5A(ITRANS,XYZ,DXYZ,FRC,VERT,IV(I),EYE,LSHINE,LIGHT)
        ELSEIF (ISF.EQ.6) THEN
          DO 20 I1=1,3
            I2=1+MOD(I1,3)
            I=MIN(I1,I2)
            J=MAX(I1,I2)
            K2=0
            IJDIF=IV(J)-IV(I)
            IF (IV(I).LE.4) THEN
              IF (IV(J).LE.4) THEN
                IF (IJDIF.EQ.1) THEN
                  K2=IV(I)
                ELSEIF (IJDIF.EQ.3) THEN
                  K2=IV(J)
                ENDIF
              ELSE
                IF (IJDIF.EQ.4) K2=IV(J)
              ENDIF
            ELSE
              IF (IJDIF.EQ.1) THEN
                K2=IV(I)+4
              ELSEIF (IJDIF.EQ.3) THEN
                K2=IV(J)+4
              ENDIF
            ENDIF
            IF (K2.GT.0) GOTO 1
  20      CONTINUE
   1      CALL STSF5B(ITRANS,XYZ,DXYZ,FRC,VERT,K2,EYE,LSHINE,LIGHT,1)
        ELSE
          K3=IV(1)+IV(2)+IV(3)-5+2*(IV(1)/5+2*(IV(2)/5)+IV(3)/5)
          CALL STSF5C(ITRANS,XYZ,DXYZ,FRC,VERT,K3,EYE,LSHINE,LIGHT)
        ENDIF
      ELSE
        IF (ISF.EQ.12) THEN
          DO 30 I=1,4
  30        CALL STSF5A(ITRANS,XYZ,DXYZ,FRC,VERT,IV(I),EYE,LSHINE,LIGHT)
        ELSEIF (ISF.EQ.4) THEN
          K4=(IV(1)+IV(2)+IV(3)+IV(4)-6)/4
          IF ((IV(2)-IV(1)).EQ.3) K4=6
          CALL STSF5B(ITRANS,XYZ,DXYZ,FRC,VERT,K4,EYE,LSHINE,LIGHT,2)
        ELSEIF (ISF.EQ.6) THEN
          IF (IV(3).LE.4) THEN
            K3=IV(1)+IV(2)+IV(3)-6
            K4=MOD((IV(4)+K3),4)+3*K3
          ELSE
            IF (IV(2).GE.5) THEN
              K3=IV(2)+IV(3)+IV(4)-18
              K4=IV4MAP(MOD((IV(1)+K3),4)+3*K3)
            ELSE
              K4=12+IV(3)-IV(2)
              IF ((IV(1)+IV(2)+IV(3)+IV(4)).EQ.22) K4=29-K4
            ENDIF
          ENDIF
          CALL STSF5D(ITRANS,XYZ,DXYZ,FRC,VERT,K4,EYE,LSHINE,LIGHT)
        ELSE
          K4=IV(1)+IV(2)+IV(3)+IV(4)
          IF (K4.EQ.16 .OR. K4.EQ.20) THEN          
            CALL STSF5B(ITRANS,XYZ,DXYZ,FRC,VERT,IV(3),EYE,LSHINE,
     *                  LIGHT,1)
            CALL STSF5B(ITRANS,XYZ,DXYZ,FRC,VERT,IV(4),EYE,LSHINE,
     *                  LIGHT,1)
          ELSEIF (K4.EQ.18) THEN
            K4A=IV(1)
            IF ((IV(2)-K4A).EQ.3) K4A=4
            K4B=9+MOD(K4A+1,4)
            CALL STSF5B(ITRANS,XYZ,DXYZ,FRC,VERT,K4A,EYE,LSHINE,LIGHT,1)
            CALL STSF5B(ITRANS,XYZ,DXYZ,FRC,VERT,K4B,EYE,LSHINE,LIGHT,1)
          ELSE
            IF (K4.EQ.14) THEN
              K4A=IV(4)
              K3=IV(1)+IV(2)+IV(3)-5+2*(IV(1)/5+2*(IV(2)/5)+IV(3)/5)
            ELSEIF (K4.EQ.22) THEN
              K4A=IV(1)
              K3=IV(2)+IV(3)+IV(4)-5+2*(IV(2)/5+2*(IV(3)/5)+IV(4)/5)
            ELSE
              IF (MOD((IV(1)+IV(2)),2).EQ.0) THEN
                IF (IV(4).EQ.6 .OR. (IV(3)-IV(2)).EQ.2) THEN
                  K4A=IV(2)
                  K3=IV(1)+IV(3)+IV(4)-5+2*(IV(1)/5+2*(IV(3)/5)+IV(4)/5)
                ELSE
                  K4A=IV(1)
                  K3=IV(2)+IV(3)+IV(4)-5+2*(IV(2)/5+2*(IV(3)/5)+IV(4)/5)
                ENDIF
              ELSE
                IF (IV(1).EQ.3 .OR. (IV(3)-IV(2)).EQ.2) THEN
                  K4A=IV(3)
                  K3=IV(1)+IV(2)+IV(4)-5+2*(IV(1)/5+2*(IV(2)/5)+IV(4)/5)
                ELSE
                  K4A=IV(4)
                  K3=IV(1)+IV(2)+IV(3)-5+2*(IV(1)/5+2*(IV(2)/5)+IV(3)/5)
                ENDIF
              ENDIF
            ENDIF
            CALL STSF5A(ITRANS,XYZ,DXYZ,FRC,VERT,K4A,EYE,LSHINE,LIGHT)
            CALL STSF5C(ITRANS,XYZ,DXYZ,FRC,VERT,K3,EYE,LSHINE,LIGHT)
          ENDIF
        ENDIF
      ENDIF
      END SUBROUTINE SBTSF5

      SUBROUTINE STSF5A(ITRANS,XYZ,DXYZ,FRC,VERT,IV,EYE,LSHINE,LIGHT)
C     ---------------------------------------------------------------
C
      REAL    XYZ(*),DXYZ(3,12,*),FRC(*),VERT(3,*),EYE(*),LIGHT(*)
      LOGICAL LSHINE
C
      IF (IV.LE.4) THEN
        J=IV
        K=1+MOD(IV+2,4)
        L=IV+4
      ELSE
        J=IV+4
        K=9+MOD(IV-2,4)
        L=IV
      ENDIF
      DO 10 I=1,3
        VERT(I,1)=XYZ(I)+DXYZ(I,J,1)+FRC(J)*DXYZ(I,J,2)
        VERT(I,2)=XYZ(I)+DXYZ(I,K,1)+FRC(K)*DXYZ(I,K,2)
        VERT(I,3)=XYZ(I)+DXYZ(I,L,1)+FRC(L)*DXYZ(I,L,2)
  10  CONTINUE
      CALL SBTSF6(ITRANS,EYE,3,VERT,LSHINE,LIGHT,1) 
      END SUBROUTINE STSF5A

      SUBROUTINE STSF5B(ITRANS,XYZ,DXYZ,FRC,VERT,KK,EYE,LSHINE,LIGHT,LL)
C     ------------------------------------------------------------------
C
      REAL    XYZ(*),DXYZ(3,12,*),FRC(*),VERT(3,*),EYE(*),LIGHT(*)
      INTEGER IVL(4,12,2)
      LOGICAL LSHINE
      DATA    IVL /5,6,2,4,6,7,3,1,7,8,4,2,8,5,1,3,9,1,4,12,10,2,1,9,
     *     11,3,2,10,12,4,3,11,12,5,6,10,9,6,7,11,10,7,8,12,11,8,5,9,
     *     5,6,7,8,4,2,10,12,1,3,11,9,4,2,10,12,5,6,7,8,1,3,11,9,24*0/
C
      J=IVL(1,KK,LL)
      K=IVL(2,KK,LL)
      L=IVL(3,KK,LL)
      M=IVL(4,KK,LL)
      DO 10 I=1,3
        VERT(I,1)=XYZ(I)+DXYZ(I,J,1)+FRC(J)*DXYZ(I,J,2)
        VERT(I,2)=XYZ(I)+DXYZ(I,K,1)+FRC(K)*DXYZ(I,K,2)
        VERT(I,3)=XYZ(I)+DXYZ(I,L,1)+FRC(L)*DXYZ(I,L,2)
        VERT(I,4)=XYZ(I)+DXYZ(I,M,1)+FRC(M)*DXYZ(I,M,2)
        VERT(I,5)=VERT(I,1)
        VERT(I,6)=0.25*(VERT(I,1)+VERT(I,2)+VERT(I,3)+VERT(I,4))
  10  CONTINUE
      DO 20 I=1,4
        CALL SBRCOP(VERT(1,I),VERT(1,7),6)
        CALL SBTSF6(ITRANS,EYE,3,VERT(1,6),LSHINE,LIGHT,1)
  20  CONTINUE
      END SUBROUTINE STSF5B

      SUBROUTINE STSF5C(ITRANS,XYZ,DXYZ,FRC,VERT,K3,EYE,LSHINE,LIGHT)
C     ---------------------------------------------------------------
C
      REAL    XYZ(*),DXYZ(3,12,*),FRC(*),VERT(3,*),EYE(*),LIGHT(*)
      INTEGER IV3(5,24)
      LOGICAL LSHINE
      DATA    IV3 /5,6,7,3,4,8,5,6,2,3,7,8,5,1,2,6,7,8,4,1,
     *             12,4,2,6,9,4,2,10,9,5,9,1,3,8,12,9,1,3,7,10,
     *             1,3,11,10,6,1,3,11,12,5,4,2,10,11,8,2,4,12,11,7,
     *             10,12,4,1,6,12,10,2,1,5,11,9,1,4,8,1,9,11,7,2,
     *             3,11,9,6,2,3,11,9,5,4,2,10,12,8,3,4,12,10,7,3,
     *             5,6,7,11,12,8,5,6,10,11,7,8,5,9,10,6,7,8,12,9/
C
      J=IV3(1,K3)
      K=IV3(2,K3)
      L=IV3(3,K3)
      M=IV3(4,K3)
      N=IV3(5,K3)
      DO 10 I=1,3
        VERT(I,1)=XYZ(I)+DXYZ(I,J,1)+FRC(J)*DXYZ(I,J,2)
        VERT(I,2)=XYZ(I)+DXYZ(I,K,1)+FRC(K)*DXYZ(I,K,2)
        VERT(I,3)=XYZ(I)+DXYZ(I,L,1)+FRC(L)*DXYZ(I,L,2)
        VERT(I,4)=XYZ(I)+DXYZ(I,M,1)+FRC(M)*DXYZ(I,M,2)
        VERT(I,5)=XYZ(I)+DXYZ(I,N,1)+FRC(N)*DXYZ(I,N,2)
        VERT(I,6)=VERT(I,1)
        VERT(I,7)=0.2*(VERT(I,1)+VERT(I,2)+VERT(I,3)+VERT(I,4)+
     *                 VERT(I,5))
  10  CONTINUE
      DO 20 I=1,5
        CALL SBRCOP(VERT(1,I),VERT(1,8),6)
        CALL SBTSF6(ITRANS,EYE,3,VERT(1,7),LSHINE,LIGHT,1)
  20  CONTINUE
      END SUBROUTINE STSF5C

      SUBROUTINE STSF5D(ITRANS,XYZ,DXYZ,FRC,VERT,K4,EYE,LSHINE,LIGHT)
C     ---------------------------------------------------------------
C
      REAL    XYZ(*),DXYZ(3,12,*),FRC(*),VERT(3,*),EYE(*),LIGHT(*)
      INTEGER IV4(6,16)
      LOGICAL LSHINE
      DATA    IV4 /12,9,6,7,3,4,10,9,5,4,3,7,11,10,6,5,4,3,
     *             11,12,5,6,2,3,9,12,8,3,2,6,10,9,5,8,3,2,
     *             10,11,8,5,1,2,12,11,7,2,1,5,9,12,8,7,2,1,
     *             9,10,7,8,4,1,11,10,6,1,4,8,12,11,7,6,1,4,
     *             12,10,6,1,3,8,12,10,7,3,1,5,11,9,6,2,4,8,
     *             11,9,5,4,2,7/
      DATA    VNORM /0.1666666667/
C
      CALL SBRFIL(VERT(1,8),0.0,3)
      DO 20 J=1,6
        K=IV4(J,K4)
        DO 10 I=1,3
          VERT(I,J)=XYZ(I)+DXYZ(I,K,1)+FRC(K)*DXYZ(I,K,2)
          VERT(I,8)=VERT(I,8)+VERT(I,J)
  10    CONTINUE
  20  CONTINUE
      CALL SBRCOP(VERT,VERT(1,7),3)
      DO 30 I=1,3
  30    VERT(I,8)=VERT(I,8)*VNORM
      DO 40 I=1,6
        CALL SBRCOP(VERT(1,I),VERT(1,9),6)
        CALL SBTSF6(ITRANS,EYE,3,VERT(1,8),LSHINE,LIGHT,1)
  40  CONTINUE
      END SUBROUTINE STSF5D

      SUBROUTINE SBTSF6(ITRANS,EYE,NV,VERT,LSHINE,LIGHT,INSIDE)
C     ---------------------------------------------------------
C
      REAL             EYE(*),VERT(3,*),LIGHT(*)
      LOGICAL          LSHINE
C
      REAL*8           XLNORM,ZZ,DZZ
      REAL             XW(20),YW(20),MTRX
      LOGICAL          LPS,LCOLOR
      COMMON  /SRFCOM/ GRDCUB(3,8),MTRX(3,3),ORIG(3),XL2,COL0,COLSCL
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
C
C Carry out some initial checks and calculate the coordinates of the 
C projected triangle.
C
      IF (NV.LT.3 .OR. NV.GT.10) RETURN
      SMALL=1.0E-10
      XMIN=+1.0E20
      XMAX=-1.0E20
      YMIN=+1.0E20
      YMAX=-1.0E20
      DO 10 I=1,NV
        CALL SBLIN1(EYE,VERT(1,I),VERT(2,I),VERT(3,I),XW(I),YW(I))
        IF (XW(I).LT.XMIN) THEN
          XMIN=XW(I)
          ILEFT=I
        ENDIF
        IF (YW(I).LT.YMIN) THEN
          YMIN=YW(I)
          JBOTOM=I
        ENDIF
        XMAX=MAX(XW(I),XMAX)
        YMAX=MAX(YW(I),YMAX)
  10  CONTINUE
      IF (XMIN.GE.XTRC .OR. XMAX.LE.XBLC) RETURN
      IF (YMIN.GE.YTRC .OR. YMAX.LE.YBLC) RETURN
C
C Find the outward normal seen by the eye.
C
      AX=VERT(1,2)-VERT(1,1)
      AY=VERT(2,2)-VERT(2,1)
      AZ=VERT(3,2)-VERT(3,1)
      BX=VERT(1,1)-VERT(1,NV)
      BY=VERT(2,1)-VERT(2,NV)
      BZ=VERT(3,1)-VERT(3,NV)
      XN=BY*AZ-AY*BZ
      YN=BZ*AX-AZ*BX
      ZN=BX*AY-AX*BY
      TEN=XN*(EYE(1)-VERT(1,1))+YN*(EYE(2)-VERT(2,1))
     *   +ZN*(EYE(3)-VERT(3,1))
      IF (TEN.LT.0.0) THEN
        XN=-XN
        YN=-YN
        ZN=-ZN
        TEN=-TEN
      ENDIF
C
C Plot the projected triangle.
C
      ITLEVL=MAX(MIN(ITRANS,3),1)
      XLNORM=DBLE(TEN)
      EYENRM=XN*EYE(1)+YN*EYE(2)+ZN*EYE(3)
      DX=FLOAT(NXP-1)/(XTRC-XBLC)
      DY=FLOAT(NYP-1)/(YTRC-YBLC)
      DYJ=1.0/DY
      DXI=1.0/DX
      SAFER=0.0001
      IF ((XMAX-XMIN).GT.(YMAX-YMIN)) THEN
        JYMIN=INT((YMIN-YBLC)*DY)+2
        JYMAX=MIN(INT((YMAX-YBLC)*DY)+1,NYP)
        IF (JYMIN.GT.JYMAX) RETURN
        YJ=YBLC+(FLOAT(JYMIN-1)+SAFER)*DYJ
        NVL2=JBOTOM
        NVR2=JBOTOM
        J1=JYMIN
        DO 40 IVERT=1,NV
          IF (YJ.GT.YW(NVL2)) THEN
   1        NVL1=NVL2
            NVL2=NVL1-1
            IF (NVL2.LT.1) NVL2=NV
            IF (NVL2.EQ.JBOTOM) RETURN
            IF (YJ.GT.YW(NVL2)) GOTO 1
            YDIFL=YW(NVL2)-YW(NVL1)
            IF (ABS(YDIFL).LT.SMALL) YDIFL=SMALL
            GRADL=(XW(NVL2)-XW(NVL1))/YDIFL
          ENDIF
          IF (YJ.GT.YW(NVR2)) THEN
   2        NVR1=NVR2
            NVR2=NVR1+1
            IF (NVR2.GT.NV) NVR2=1
            IF (NVR2.EQ.JBOTOM) RETURN
            IF (YJ.GT.YW(NVR2)) GOTO 2
            YDIFR=YW(NVR2)-YW(NVR1)
            IF (ABS(YDIFR).LT.SMALL) YDIFR=SMALL
            GRADR=(XW(NVR2)-XW(NVR1))/YDIFR
          ENDIF
          IF (YW(NVL2).LT.YW(NVR2)) THEN
            J2=MIN(INT((YW(NVL2)-YBLC)*DY)+1,JYMAX)
          ELSE
            J2=MIN(INT((YW(NVR2)-YBLC)*DY)+1,JYMAX)
          ENDIF
          DO 30 J=J1,J2
            IF (J.GE.1) THEN
              JTEST=MOD(J,2)
              IF (ITLEVL.EQ.3 .AND. JTEST.EQ.1) GOTO 29
              XL=XW(NVL1)+GRADL*(YJ-YW(NVL1))
              XR=XW(NVR1)+GRADR*(YJ-YW(NVR1))
              ISTEP=1
              IX1=MAX(INT((XL-XBLC)*DX)+2,1)
              IX2=MIN(INT((XR-XBLC)*DX)+1,NXP)
              IF (IX1.GT.IX2) THEN
                ISTEP=-1
                IX1=MIN(IX1-1,NXP)
                IX2=MAX(IX2+1,1)
              ENDIF
              XI=XBLC+FLOAT(IX1-1)*DXI
              SDXI=FLOAT(ISTEP)*DXI
              DZZ=DBLE(SDXI*XN)
              ZZ=DBLE(EYENRM-XI*XN-YJ*YN)
              K=(J-1)*NXP+IX1
              DO 20 I=IX1,IX2,ISTEP
                ITEST=MOD(I,2)
                IF (ITLEVL.EQ.1) THEN
                  IF ((ITEST+JTEST).EQ.0) GOTO 19
                ELSEIF (ITLEVL.EQ.2) THEN
                  IF ((ITEST+JTEST).EQ.1) GOTO 19
                ELSE
                  IF (ITEST.EQ.1) GOTO 19
                ENDIF
                XLAMDA=SNGL(XLNORM/ZZ)
                Z=EYE(3)*(1.0-XLAMDA)
                IF (Z.GT.SBBUFF(K)) THEN
                  SBBUFF(K)=Z
                  X=EYE(1)+XLAMDA*(XI-EYE(1))
                  Y=EYE(2)+XLAMDA*(YJ-EYE(2))
                  IF (INSIDE.EQ.0) THEN
                    GX=XN
                    GY=YN
                    GZ=ZN
                  ELSE
                    CALL SBSF6A(X,Y,Z,ORIG,MTRX,GRDCUB,GX,GY,GZ)
                  ENDIF
                  CALL SBSF6B(EYE,X,Y,Z,GX,GY,GZ,LIGHT,XL2,LSHINE,CLR)
                  SBBUFF(KSTART+K)=COL0+COLSCL*CLR
                ENDIF
  19            XI=XI+SDXI
                ZZ=ZZ-DZZ
                K=K+ISTEP
  20          CONTINUE
            ENDIF
  29        YJ=YJ+DYJ
  30      CONTINUE
          J1=J2+1
          IF (J1.GT.JYMAX) RETURN
  40    CONTINUE
      ELSE
        IXMIN=INT((XMIN-XBLC)*DX)+2
        IXMAX=MIN(INT((XMAX-XBLC)*DX)+1,NXP)
        IF (IXMIN.GT.IXMAX) RETURN
        XI=XBLC+(FLOAT(IXMIN-1)+SAFER)*DXI
        NVL2=ILEFT
        NVR2=ILEFT
        I1=IXMIN
        DO 70 IVERT=1,NV
          IF (XI.GT.XW(NVL2)) THEN
   3        NVL1=NVL2
            NVL2=NVL1-1
            IF (NVL2.LT.1) NVL2=NV
            IF (NVL2.EQ.ILEFT) RETURN
            IF (XI.GT.XW(NVL2)) GOTO 3
            XDIFL=XW(NVL2)-XW(NVL1)
            IF (ABS(XDIFL).LT.SMALL) XDIFL=SMALL
            GRADL=(YW(NVL2)-YW(NVL1))/XDIFL
          ENDIF
          IF (XI.GT.XW(NVR2)) THEN
   4        NVR1=NVR2
            NVR2=NVR1+1
            IF (NVR2.GT.NV) NVR2=1
            IF (NVR2.EQ.ILEFT) RETURN
            IF (XI.GT.XW(NVR2)) GOTO 4
            XDIFR=XW(NVR2)-XW(NVR1)
            IF (ABS(XDIFR).LT.SMALL) XDIFR=SMALL
            GRADR=(YW(NVR2)-YW(NVR1))/XDIFR
          ENDIF
          IF (XW(NVL2).LT.XW(NVR2)) THEN
            I2=MIN(INT((XW(NVL2)-XBLC)*DX)+1,IXMAX)
          ELSE
            I2=MIN(INT((XW(NVR2)-XBLC)*DX)+1,IXMAX)
          ENDIF
          DO 60 I=I1,I2
            IF (I.GE.1) THEN
              ITEST=MOD(I,2)
              IF (ITLEVL.EQ.3 .AND. ITEST.EQ.1) GOTO 59
              YL=YW(NVL1)+GRADL*(XI-XW(NVL1))
              YR=YW(NVR1)+GRADR*(XI-XW(NVR1))
              ISTEP=1
              JY1=MAX(INT((YL-YBLC)*DY)+2,1)
              JY2=MIN(INT((YR-YBLC)*DY)+1,NYP)
              IF (JY1.GT.JY2) THEN
                ISTEP=-1
                JY1=MIN(JY1-1,NYP)
                JY2=MAX(JY2+1,1)
              ENDIF
              YJ=YBLC+FLOAT(JY1-1)*DYJ
              SDYJ=FLOAT(ISTEP)*DYJ
              DZZ=DBLE(SDYJ*YN)
              ZZ=DBLE(EYENRM-YJ*YN-XI*XN)
              K=(JY1-1)*NXP+I
              KSTEP=ISTEP*NXP
              DO 50 J=JY1,JY2,ISTEP
                JTEST=MOD(J,2)
                IF (ITLEVL.EQ.1) THEN
                  IF ((ITEST+JTEST).EQ.0) GOTO 49
                ELSEIF (ITLEVL.EQ.2) THEN
                  IF ((ITEST+JTEST).EQ.1) GOTO 49
                ELSE
                  IF (JTEST.EQ.1) GOTO 49
                ENDIF
                XLAMDA=SNGL(XLNORM/ZZ)
                Z=EYE(3)*(1.0-XLAMDA)
                IF (Z.GT.SBBUFF(K)) THEN
                  SBBUFF(K)=Z
                  X=EYE(1)+XLAMDA*(XI-EYE(1))
                  Y=EYE(2)+XLAMDA*(YJ-EYE(2))
                  IF (INSIDE.EQ.0) THEN
                    GX=XN
                    GY=YN
                    GZ=ZN
                  ELSE
                    CALL SBSF6A(X,Y,Z,ORIG,MTRX,GRDCUB,GX,GY,GZ)
                  ENDIF
                  CALL SBSF6B(EYE,X,Y,Z,GX,GY,GZ,LIGHT,XL2,LSHINE,CLR)
                  SBBUFF(KSTART+K)=COL0+COLSCL*CLR
                ENDIF
  49            YJ=YJ+SDYJ
                ZZ=ZZ-DZZ
                K=K+KSTEP
  50          CONTINUE
            ENDIF
  59        XI=XI+DXI
  60      CONTINUE
          I1=I2+1
          IF (I1.GT.IXMAX) RETURN
  70    CONTINUE
      ENDIF
      END SUBROUTINE SBTSF6

      SUBROUTINE SBFBKG(IC1,IC2,ISHADE)
C     ---------------------------------
C
      LOGICAL          LPS,LCOLOR
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      Sets the shading for the background. This routine should be
C    called after SBFINT, and COLINT or COLTAB, but before any objects
C    are plotted.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    IC1,IC2  I*4    I       -      Lowest & highest colour-index to be
C                                   used for the shading.
C    ISHADE   I*4    I       -      Order of shading (IC1-->IC2 - IC1):
C                                      1 - Bottom to top.
C                                      2 - Left to right.
C                                      3 - Bottom-left to top-right.
C                                      4 - Top-left to bottom-right.
C                                      5 - Bottom, middle and top.
C                                      6 - Left, middle and right.
C                                      7 - Rectangular zoom to centre.
C                                      8 - Elliptical zoom to centre.
C Globals
C    SFTBUF
C
C External Calls
C   SUBROUTINE   DESCRIPTION
C     SBRFIL     Fills a real aray with a constant.
C
C History
C   D. S. Sivia      12 Oct 1995  Initial release.
C-----------------------------------------------------------------------
C
      IF (IBFMOD.EQ.2) RETURN
      NC=IC2-IC1
      NTOT=NXP*NYP
      IF (NC.EQ.0) THEN
        CALL SBRFIL(SBBUFF(KSTART+1),FLOAT(IC1),NTOT)
        RETURN
      ENDIF
      IF (ISHADE.EQ.1) THEN
        COL=FLOAT(IC1)
        DCOL=0.9999*FLOAT(NC)/FLOAT(NYP-1)
        K=KSTART+1
        DO 1 J=1,NYP
           CALL SBRFIL(SBBUFF(K),COL,NXP)
           K=K+NXP
           COL=COL+DCOL
   1    CONTINUE
      ELSEIF (ISHADE.EQ.2) THEN
        COL=FLOAT(IC1)
        DCOL=0.9999*FLOAT(NC)/FLOAT(NXP-1)
        DO 11 I=1,NXP
          DO 10 K=KSTART+I,KSTART+NTOT,NXP
  10        SBBUFF(K)=COL
          COL=COL+DCOL
  11    CONTINUE
      ELSEIF (ISHADE.EQ.3) THEN
        XN=FLOAT(NXP-1)
        YN=FLOAT(NYP-1)
        COL0=FLOAT(IC1)+0.0001*FLOAT(NC)
        DCOL=0.9998*FLOAT(NC)/(XN**2+YN**2)
        K=KSTART+1
        DO 21 J=0,NYP-1
          YNJ=YN*FLOAT(J)
          DO 20 I=0,NXP-1
            SBBUFF(K)=COL0+DCOL*(XN*FLOAT(I)+YNJ)
            K=K+1
  20      CONTINUE
  21    CONTINUE
      ELSEIF (ISHADE.EQ.4) THEN
        XN=FLOAT(NXP-1)
        YN=FLOAT(1-NYP)
        COL0=FLOAT(IC1)+0.0001*FLOAT(NC)
        DCOL=0.9998*FLOAT(NC)/(XN**2+YN**2)
        K=KSTART+1
        DO 31 J=1,NYP
          YNJ=YN*FLOAT(J-NYP)
          DO 30 I=0,NXP-1
            SBBUFF(K)=COL0+DCOL*(XN*FLOAT(I)+YNJ)
            K=K+1
  30      CONTINUE
  31    CONTINUE
      ELSEIF (ISHADE.EQ.5) THEN
        NYP1=1
        NYP2=NYP/2
        COL=FLOAT(IC1)
        DCOL=0.9999*FLOAT(NC)/FLOAT(NYP2-NYP1)
        K=KSTART+1
        DO 41 L=1,2
          IF (L.EQ.2) THEN
            NYP1=NYP2+1
            NYP2=NYP
            COL=FLOAT(IC2)
            DCOL=-0.9999*FLOAT(NC)/FLOAT(NYP2-NYP1)
          ENDIF
          DO 40 J=NYP1,NYP2
             CALL SBRFIL(SBBUFF(K),COL,NXP)
             K=K+NXP
             COL=COL+DCOL
  40       CONTINUE
  41    CONTINUE
      ELSEIF (ISHADE.EQ.6) THEN
        NXP1=1
        NXP2=NXP/2
        COL=FLOAT(IC1)
        DCOL=0.9999*FLOAT(NC)/FLOAT(NXP2-NXP1)
        DO 52 L=1,2
          IF (L.EQ.2) THEN
            NXP1=NXP2+1
            NXP2=NXP
            COL=FLOAT(IC2)
            DCOL=-0.9999*FLOAT(NC)/FLOAT(NXP2-NXP1)
          ENDIF
          DO 51 I=NXP1,NXP2
            DO 50 K=KSTART+I,KSTART+NTOT,NXP
  50          SBBUFF(K)=COL
            COL=COL+DCOL
  51      CONTINUE
  52    CONTINUE
      ELSEIF (ISHADE.EQ.7) THEN
        NXP2=NXP/2+1
        NYP2=NYP/2+1
        XN=1.0/FLOAT(NXP2-1)
        YN=1.0/FLOAT(NYP2-1)
        COL0=FLOAT(IC2)
        DCOL=-0.9999*FLOAT(NC)
        K=KSTART+1
        DO 61 J=1,NYP
          YNJ=ABS(YN*FLOAT(J-NYP2))
          DO 60 I=1,NXP
            XNI=ABS(XN*FLOAT(I-NXP2))
            SBBUFF(K)=COL0+DCOL*MAX(XNI,YNJ)
            K=K+1
  60      CONTINUE
  61    CONTINUE
      ELSEIF (ISHADE.EQ.8) THEN
        NXP2=NXP/2+1
        NYP2=NYP/2+1
        XN=1.0/FLOAT(NXP2-1)
        YN=1.0/FLOAT(NYP2-1)
        COL0=FLOAT(IC2)
        DCOL=-0.9999*FLOAT(NC)
        K=KSTART+1
        DO 71 J=1,NYP
          YNJ=(YN*FLOAT(J-NYP2))**2
          DO 70 I=1,NXP
            XNI=(XN*FLOAT(I-NXP2))**2
            SBBUFF(K)=COL0+DCOL*MIN(XNI+YNJ,1.0)
            K=K+1
  70      CONTINUE
  71    CONTINUE
      ENDIF
      END SUBROUTINE SBFBKG

      SUBROUTINE SBQINF(XLEFT,XRIGHT,YBOT,YTOP,ZBMIN,ZBMAX)
C     -----------------------------------------------------
C
      LOGICAL          LPS,LCOLOR
      COMMON  /SFTBUF/ SBBUFF(2000000),NXP,NYP,IBFMOD,KSTART,
     *                 IR(0:255),IG(0:255),IB(0:255),LPS,LCOLOR,
     *                 XOFF,XLEN,XORG,XSCALE,XPERIN,XBLC,XTRC,
     *                 YOFF,YLEN,YORG,YSCALE,YPERIN,YBLC,YTRC
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C      Passes back some useful information about the software buffer
C    and canvas to be plotted. All (x,y,z) values are taken to be given
C    in world coordinates.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    XLEFT    R*4    O       -      X-coord of left-hand of window.
C    XRIGHT   R*4    O       -      X-coord of right-hand of window.
C    YBOT     R*4    O       -      Y-coord of bottom of window.
C    YTOP     R*4    O       -      Y-coord of top of window.
C    ZBMIN    R*4    O       -      Minimum Z for distance buffer.
C    ZBMAX    R*4    O       -      Maximum Z for distance buffer.
C
C Globals
C    SFTBUF
C
C External Calls
!




C   SUBROUTINE   DESCRIPTION
C     None.
C
C History
C   D. S. Sivia       6 Jul 1995  Initial release.
C-----------------------------------------------------------------------
C
      XLEFT=XBLC
      XRIGHT=XTRC
      YBOT=YBLC
      YTOP=YTRC
C
      NTOT=NXP*NYP
      ZBMIN=0.0
      ZBMAX=-1.0E20
      DO 10 I=1,NTOT
        ZBMIN=MIN(SBBUFF(I),ZBMIN)
        ZBMAX=MAX(SBBUFF(I),ZBMAX)
  10  CONTINUE
      END SUBROUTINE SBQINF

      SUBROUTINE SBRFIL(X,A,N)
C     ------------------------
C
      REAL X(*)
C
      DO 10 I=1,N
  10    X(I)=A
      END SUBROUTINE SBRFIL

      SUBROUTINE SBRCOP(X,Y,N)
C     ------------------------
C
      REAL X(*),Y(*)
C
      DO 10 I=1,N
  10    Y(I)=X(I)
      END SUBROUTINE SBRCOP
      
      real function zeroin(ax,bx,f,tol)
      real ax,bx,f,tol
c
c      a zero of the function  f(x)  is computed in the interval ax,bx .
c
c  input..
c
c  ax     left endpoint of initial interval
c  bx     right endpoint of initial interval
c  f      function subprogram which evaluates f(x) for any x in
c         the interval  ax,bx
c  tol    desired length of the interval of uncertainty of the
c         final result ( .ge. 0.0)
c
c
c  output..
c
c  zeroin abcissa approximating a zero of  f  in the interval ax,bx
c
c
c      it is assumed  that   f(ax)   and   f(bx)   have  opposite  signs
c  without  a  check.  zeroin  returns a zero  x  in the given interval
c  ax,bx  to within a tolerance  4*macheps*abs(x) + tol, where macheps
c  is the relative machine precision.
c      this function subprogram is a slightly  modified  translation  of
c  the algol 60 procedure  zero  given in  richard brent, algorithms for
c  minimization without derivatives, prentice - hall, inc. (1973).
c
c
      real  a,b,c,d,e,eps,fa,fb,fc,tol1,xm,p,q,r,s
c
c  compute eps, the relative machine precision
c
      eps = 1.0
   10 eps = eps/2.0
      tol1 = 1.0 + eps
      if (tol1 .gt. 1.0) go to 10
c
c initialization
c
      a = ax
      b = bx
      fa = f(a)
      fb = f(b)
c
c begin step
c
   20 c = a
      fc = fa
      d = b - a
      e = d
   30 if (abs(fc) .ge. abs(fb)) go to 40
      a = b
      b = c
      c = a
      fa = fb
      fb = fc
      fc = fa
c
c convergence test
c
   40 tol1 = 2.0*eps*abs(b) + 0.5*tol
      xm = .5*(c - b)
      if (abs(xm) .le. tol1) go to 90
      if (fb .eq. 0.0) go to 90
c
c is bisection necessary
c
      if (abs(e) .lt. tol1) go to 70
      if (abs(fa) .le. abs(fb)) go to 70
c
c is quadratic interpolation possible
c
      if (a .ne. c) go to 50
c
c linear interpolation
c
      s = fb/fa
      p = 2.0*xm*s
      q = 1.0 - s
      go to 60
c
c inverse quadratic interpolation
c
   50 q = fa/fc
      r = fb/fc
      s = fb/fa
      p = s*(2.0*xm*q*(q - r) - (b - a)*(r - 1.0))
      q = (q - 1.0)*(r - 1.0)*(s - 1.0)
c
c adjust signs
c
   60 if (p .gt. 0.0) q = -q
      p = abs(p)
c
c is interpolation acceptable
c
      if ((2.0*p) .ge. (3.0*xm*q - abs(tol1*q))) go to 70
      if (p .ge. abs(0.5*e*q)) go to 70
      e = d
      d = p/q
      go to 80
c
c bisection
c
   70 d = xm
      e = d
c
c complete step
c
   80 a = b
      fa = fb
      if (abs(d) .gt. tol1) b = b + d
      if (abs(d) .le. tol1) b = b + sign(tol1, xm)
      fb = f(b)
      if ((fb*(fc/abs(fc))) .gt. 0.0) go to 20
      go to 30
c
c done
c
   90 zeroin = b
      return
      end function zeroin


EOF
EOC
