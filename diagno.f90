#!/bin/sh
#---------------------------------------------------------------------
cat > temp.c << "EOC"
cat > vmodules.f << "EOF"
      module constants
!DK constants
!***********************************************************************
!! holds constants from mathematics and physics
!***********************************************************************
      integer, parameter :: rprec = selected_real_kind(12,100)

      real(rprec), parameter ::      pi = 3.14159265358979312 
      real(rprec), parameter ::   twopi = 6.28318530717958623
      real(rprec), parameter ::  onerad = 1.74532925199432955E-02
      real(rprec), parameter ::     muo = 1.25663706143591729E-06
      real(rprec), parameter :: sqrtmuo = 1.12099824327958572E-03
      save
      end module constants



      module diagno_input
!***********************************************************************
!! This module contains the input for diagno generated by nemec
!! Does only read ascii input files, to avoid library dependencies.
      use constants
      implicit none

!!mf=number of pol. Fourier coefficients, m=0, ... , mf
!!nf=number of tor. Fourier coefficients  n=-nf, ... , nf
!!np=number of field periods
      integer :: mf,nf,np

!!pot=array holding potential
!!cr =Fourier coefficients for R
!!cz =Fourier coefficients for z
      real(rprec), dimension(:,:), allocatable :: pot,cr,cz

!!raxfc,zaxfc = Fourier coefficients of axis filament carrying
!!              the plasma current in case of vmec200
      real(rprec), dimension(:), allocatable :: raxfc,zaxfc

!----------- could be made dynamic ---------------
!     integer, parameter :: nc=4        !w7as
!     integer, parameter :: nc=5        !w7as_cc
!     integer, parameter :: nc=7        !w7x
!!number of coils
      integer :: nc     !number of coils

!!allocatable array to hold coil currents
      real(rprec), dimension(:), allocatable :: current

!----------- 
      integer :: ivertb
      real(rprec) :: phiedge, tor_cur, deltbz

      integer :: nu,nv,nuv,nvp,nuvp

!! string identifying the calculation
      character(60) :: id_string
!! string identifying the machine: W7-AS, W7-X
      character(50) :: machine_string
!! string identifying the input format: nemec93, vmec2000
      character(50) :: input_form
!! filenames for database files for fluxloops and seg.Rogowski coils
      character(256) :: fdb_fluxloops, fdb_SegRogCoils
!! filenames for coils files
      character(256) :: diagno_coils_file, vert_field_file
!! filenames for barrow parameter file
      character(256) :: barrow_param_file
!! filenames for calculation of diagnostics
      character(256) :: flux_diag_file, bprobes_file, mir1_file, &
     &                 seg_rog_file, bfield_points_file 

      logical :: lwrpl_surf, ltrace_progress, lcomp_dia, lflux_comb
      integer :: old_input_form, old_cnv_form
      real(rprec), dimension(100) :: flux_turns, dia_comp_coefs,  &
     &                               seg_rog_turns, flux_comb_coefs
      
      namelist /diagno_in/ nu, nv, input_form, diagno_coils_file,  &
     &  machine_string, vert_field_file, old_input_form, old_cnv_form, &
     &  flux_diag_file, bprobes_file, mir1_file, seg_rog_file,  &
     &  bfield_points_file, barrow_param_file,  &
     &  fdb_fluxloops, fdb_SegRogCoils, lwrpl_surf,ltrace_progress,  &
     &  flux_turns, lcomp_dia, dia_comp_coefs, seg_rog_turns,  &
     &  lflux_comb, flux_comb_coefs

!!   the specification of a file in the namelist enables the corresponding 
!!   computation and output

!! For input_form == 'nemec93', old_input_form specifies format of input file
!!   0 -->   unformatted input (old way)
!!   1 -->     formatted input (old way)
!!   2 -->           xdr input (old way)
!!   3 -->   unformatted input
!!   4 -->     formatted input
!!   5 -->           xdr input
!! and old_cnv_form specifies format for conversion format
!!   no conversion if idiag(1) == idiag(2)
!!   0 -->   unformatted output
!!   1 -->     formatted output
!!   2 -->           xdr output
!!

!! -------------------------------------------------------------
!!    flags for enabling/controlling different analysis types
!!
!!   Historically set values:
!!   index    meaning
!!    1       set to old_input_form
!!    2       set to old_cnv_form
!!    3       =1 => make barrow plot
!!    4       =1 invoke bthdiag for bprobes
!!    5       =1 invoke bthdaig for seg_rog
!!    51      =1 and (5)=1, write to database fdb_SegRogCoils 
!!    6       =1 invoke fluxdiag
!!    60      =1 compute and add compensated diamagnetic flux the fluxdiag output
!!    61      =1 and (6)=1, write to database fdb_fluxloops
!!    62      =1 compute and add to output linear combination of flux signals
!!    7       =1 invoke bthdiag for bfield_points
!!    8       =1 invoke write_plasma_surface (from write_pl_surf)
!!    9       =1 invoke bthdiag for mir1
!!   
      integer, parameter :: maxdiag = 100
      integer, dimension(maxdiag) :: idiag = 0

      save

      contains

!------------- module subroutine -----------------
!! reads control data file holding above namelist, including
!! machine string and grid resolution data
      subroutine read_control_input
      implicit none

      character(80) :: text
      integer :: istat

!
!  initialize the input data
!
      lwrpl_surf = .false.
      ltrace_progress = .false.
      lcomp_dia = .false.
      lflux_comb = .false.

      nu = 100
      nv = 250

      input_form = 'vmec2000'
      old_input_form = 0
      old_cnv_form = 0

      diagno_coils_file = ''
      machine_string = 'W7-AS_cc'
      vert_field_file = ''

      flux_diag_file = ''
      flux_turns = 1
      dia_comp_coefs = 0
      flux_comb_coefs = 0

      bprobes_file = ''
      mir1_file = ''
      seg_rog_file = ''
      seg_rog_turns = 1
      bfield_points_file = ''

      barrow_param_file = ''

      fdb_fluxloops = ''
      fdb_SegRogCoils = ''

      idiag = 0

!
!  Read the control input data
!
      open(unit=20,file='diagno.control',status='old' &
     &    ,action='read', iostat=istat)
      if( istat /= 0) then
         stop 'Cant open diagno.control file'
      endif

      read (20, nml=diagno_in, iostat=istat)
      if( istat /= 0) then
         stop 'Cant open read diagno.control file'
      endif
      close(unit=20)
      
!
!    validate the input
!
      select case (input_form)
      case ("nemec93")
        if( ltrace_progress) write(6,*)'Old input form!  ',input_form
        idiag(1) = old_input_form
        idiag(2) = old_cnv_form
      case ("vmec2000")
        if( ltrace_progress) write(6,*)'New input form!  ',input_form
      case default
        write(6,*)'Unknown input form!'
        stop 'Check diagno_control.data for input_form!'
      end select

      select case (machine_string)
      case ("W7-AS")
        continue
      case ("W7-AS_cc")
        continue
      case ("W7-AS_ttf")
        continue
      case ("W7-X")
        continue
      case default
        write(6,*)'Unknown machine : ',machine_string
        stop 'Check diagno_control.data for machine_string!'
      end select
      if( ltrace_progress) write(6,*)'Machine to be handled: ',machine_string

      if( trim(diagno_coils_file).eq. '') &
     &    stop 'No coils file specified !!'

      if( machine_string(1:4) .eq. 'W7-AS' .and. &
     &    trim(vert_field_file) .eq. '') &
     &    stop 'W7-AS needs verical-field file input'

!      if( trim(barrow_param_file) .ne. '') idiag(3) = 1
      if( trim(bprobes_file) .ne. '') idiag(4) = 1
      if( trim(seg_rog_file) .ne. '') idiag(5) = 1
      if( trim(flux_diag_file) .ne. '') idiag(6) = 1
      if( lcomp_dia ) idiag(60) = 1
      if( lflux_comb ) idiag(62) = 1
      if( trim(bfield_points_file) .ne. '') idiag(7) = 1
      if( lwrpl_surf ) idiag(8) = 1
      if( trim(mir1_file) .ne. '') idiag(9) = 1

      if( trim(fdb_fluxloops) .ne. '' ) idiag(51) = idiag(5)
      if( trim(fdb_SegRogCoils) .ne. '') idiag(61) = idiag(6)

      end subroutine read_control_input
!--------- end module subroutine -----------------

!------------- module subroutine -----------------
!! reads input generated by nemec
      subroutine read_input
      implicit none
      
      if(input_form.eq."nemec93")then
        select case (machine_string)
        case ("W7-AS")
          if( ltrace_progress) write(6,*)'Coils for ',machine_string
          nc = 4
          call allocate_current
          call read_input_w7as
        case ("W7-AS_cc")
          if( ltrace_progress) write(6,*)'Coils for ',machine_string
          nc = 5
          call allocate_current
          call read_input_w7as_cc
        case ("W7-X")
          if( ltrace_progress) write(6,*)'Coils for ',machine_string
          nc = 7
          call allocate_current
          call read_input_w7x
        case default
          write(6,*)'Unknown machine : ',machine_string
          stop 'Check input for machine_string!'
        end select
      elseif(input_form.eq."vmec2000")then
        call read_input_vmec2000
      else
        stop "read_input: unknown input_form!"
      endif

      nuv = nu*nv
      nvp = nv*np
      nuvp = nuv*np
      if( ltrace_progress) then
         write(6,'(a38)')'    nu     nv      nuv     nvp    nuvp'
         write(6,'(5i8)') nu,nv,nuv,nvp,nuvp
      endif

      end subroutine read_input
!--------- end module subroutine -----------------
!------------- module subroutine -----------------
!! allocates coil current array
      subroutine allocate_current
      implicit none
      integer :: i_alloc
      
      allocate(current(nc), stat = i_alloc)
      if(i_alloc /= 0) &
     &    stop 'Allocation of array current in read_input failed!'

      end subroutine allocate_current
!--------- end module subroutine -----------------
!------------- module subroutine -----------------
!! reads input for W7-AS calculation without control coils
      subroutine read_input_w7as

      use constants

      implicit none
      integer :: lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu,neuman
      real(rprec) :: curtor,curpol,bz0,totcur, &
     &        curmod,curson,curaux,curcoils,curivert,c_scale,m_scale
      integer :: i_alloc,i,j,ms,ns, i_show, isc_c, isc_m
      character(60) :: filename,outfilename
      character(15) :: action

!******************************
      i_show = 0
      if( ltrace_progress) i_show = 1 !0=noshow 1=show currents 2=curr+Four.coeff
      isc_c = 1     !scale currents by 1/sqrtmuo
      isc_m = 1     !scale dimensions from cm to m
      c_scale = 1
      m_scale = 1
      if(isc_c == 1) c_scale = 1/sqrtmuo
      if(isc_m == 1) m_scale = 0.01_rprec
      filename = 'diagno.input_data'
      outfilename = 'diagno.input_data.new'

      write(6,*) 'Enter mf,nf:'
      read(5,*)  mf,nf
      if( ltrace_progress) write(6,*)'mf = ',mf,'nf = ',nf
      allocate(pot(0:mf,-nf:nf),cr(0:mf,-nf:nf),cz(0:mf,-nf:nf),&
     &     stat = i_alloc)
      if(i_alloc /= 0) stop 'Allocation of arrays dread failed!'

      select case(idiag(1))
      case (0)
        rewind(15)
        read(15)  lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu
        if( ltrace_progress) write(6,*)'common block vacgrid has been read.'
        read(15) ((cr(i,j),i=0,mf),j=-nf,nf), &
     &          ((cz(i,j),i=0,mf),j=-nf,nf),ms,ns,neuman
        if((mf /= ms).or.(nf /= ns)) &
     &    stop 'Restart with different values of mf and nf'
          
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of boundary have been read.'
        read(15) ((pot(i,j),i=0,mf),j=-nf,nf)
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of potential have been read.'
        read(15) curtor,curpol,bz0,totcur,phiedge
        if( ltrace_progress) write(6,*)'common block vbfield has been read.'
        if( ltrace_progress) write(6,*) curtor,curpol,bz0,totcur,phiedge
        read(15) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,ivertb
        if( ltrace_progress) write(6,*) &
     &      'common block coilcurrents has been read.'
        if( ltrace_progress) write(6,*) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,ivertb

      case (1)
!       write(6,*)'Not yet implemented!'
        open(unit=15,file='diagno.input_data_ascii' &
     &      ,status='unknown',action='read')
        read(15,*)  lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu
        if( ltrace_progress) write(6,*)'common block vacgrid has been read.'
        read(15,*) ((cr(i,j),i=0,mf),j=-nf,nf), &
     &          ((cz(i,j),i=0,mf),j=-nf,nf),ms,ns,neuman
        if((mf /= ms).or.(nf /= ns)) &
     &    stop 'Restart with different values of mf and nf'
          
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of boundary have been read.'
        read(15,*) ((pot(i,j),i=0,mf),j=-nf,nf)
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of potential have been read.'
        read(15,*) curtor,curpol,bz0,totcur,phiedge
        if( ltrace_progress) write(6,*)'common block vbfield has been read.'
        if( ltrace_progress) write(6,*) curtor,curpol,bz0,totcur,phiedge
        read(15,*) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,ivertb
        if( ltrace_progress) write(6,*)'common block coilcurrents has been read.'
        if( ltrace_progress) write(6,*) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,ivertb
        close(unit=15)

      case (2)
        write(6,*) &
     &    'Not active in diagno_input_simple.'
      case (3)
        write(6,*)'Not yet implemented!'
      case (4)
        write(6,*)'Not yet implemented!'
      case default
        write(6,*)'Unknown case in dread/module diagno_input: ' &
     &            ,idiag(1)
        stop ' Check diag.data!'
      end select

      if(idiag(1) /= idiag(2)) &
     &  call write_input_w7as(lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu,&
     &     cr,cz,mf,nf,ms,ns,neuman,pot,curtor,curpol,bz0,totcur,  &
     &     phiedge,curmod,curson,curaux,curcoils,deltbz,curivert,  &
     &     ivertb)

      current(1) = curmod
      current(2) = curson
      current(3) = curaux
      current(4) = curivert
      current = c_scale*current
!     current(1) = 0
!     current(2) = 0
!     current(3) = 0
!     current(4) = 1000
!     curtor = 0
      tor_cur = c_scale*curtor
      cr(0:mf,0)=2*cr(0:mf,0)
      cz(0:mf,0)=2*cz(0:mf,0)
      cr = m_scale*cr
      cz = m_scale*cz
      pot = pot/c_scale
      phiedge = phiedge/c_scale*m_scale
      deltbz = deltbz/c_scale/m_scale
      np = lnvp/lnv
      if(i_show >= 1)then
        write(6,*)'lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu'
        write(6,*)  lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu
        write(6,*)'Number of field periods:',np
        write(6,*)'Coil currents ',machine_string,':'
        write(6,*)'      Im/A        I5/A      It/A         Iv/A'
        write(6,'(1p,9e12.4)')(current(i),i=1,nc)
        write(6,*)'      Bz/T'
        write(6,'(1p,e12.4)')deltbz
        write(6,*)'  tor.curr/A'
        write(6,'(1p,e12.4)')tor_cur
        if(i_show == 2)then
          do j=-nf,nf
            do i=0,mf
              write(6,'(2i4,1p2e14.5)')i,j,cr(i,j),cz(i,j)
            enddo
          enddo
        endif
      endif

      end subroutine read_input_w7as
!--------- end module subroutine -----------------
!------------- module subroutine -----------------
!! reads input for W7-AS calculation with control coils
      subroutine read_input_w7as_cc

      use constants

      implicit none
      integer :: lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu,neuman
      real(rprec):: curtor,curpol,bz0,totcur, &
     &        curmod,curson,curaux,curcoils,curivert, &
     &        curcor,c_scale,m_scale
      integer :: i_alloc,i,j,ms,ns, i_show, isc_c, isc_m, istat
      character(60) :: filename,outfilename
      character(15) :: action

!******************************
      i_show = 0
      if( ltrace_progress) i_show = 1 !0=noshow 1=show currents 2=curr+Four.coeff
      isc_c = 1     !scale currents by 1/sqrtmuo
      isc_m = 1     !scale dimensions from cm to m
      c_scale = 1
      m_scale = 1
      if(isc_c == 1) c_scale = 1/sqrtmuo
      if(isc_m == 1) m_scale = 0.01_rprec
      filename = 'diagno.input_data'
      outfilename = 'diagno.input_data.new'

      write(6,*) 'Enter mf,nf:'
      read(5,*)  mf,nf
      write(6,*)'mf = ',mf,'nf = ',nf
      allocate(pot(0:mf,-nf:nf),cr(0:mf,-nf:nf),cz(0:mf,-nf:nf),&
     &     stat = i_alloc)
      if(i_alloc /= 0) stop 'Allocation of arrays dread failed!'

      select case(idiag(1))
      case (0)
        rewind(15)
        read(15)  lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu
        if( ltrace_progress) write(6,*)'common block vacgrid has been read.'
        read(15) ((cr(i,j),i=0,mf),j=-nf,nf), &
     &          ((cz(i,j),i=0,mf),j=-nf,nf),ms,ns,neuman
        if((mf /= ms).or.(nf /= ns)) &
     &    stop 'Restart with different values of mf and nf'
          
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of boundary have been read.'
        read(15) ((pot(i,j),i=0,mf),j=-nf,nf)
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of potential have been read.'
        read(15) curtor,curpol,bz0,totcur,phiedge
        if( ltrace_progress) write(6,*)'common block vbfield has been read.'
        if( ltrace_progress) write(6,*) curtor,curpol,bz0,totcur,phiedge
        read(15) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,curcor,ivertb
        if( ltrace_progress) write(6,*)'common block coilcurrents has been read.'
        if( ltrace_progress) write(6,*) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,curcor,ivertb

      case (1)
!       write(6,*)'Not yet implemented!'
        open(unit=15,file='diagno.input_data_ascii' &
     &      ,status='old', iostat=istat, action='read')
        if (istat .ne. 0) stop 'problem opening input_data_ascii'
        read(15,*)  lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu
        if( ltrace_progress) write(6,*)'common block vacgrid has been read.'
        read(15,*) ((cr(i,j),i=0,mf),j=-nf,nf), &
     &          ((cz(i,j),i=0,mf),j=-nf,nf),ms,ns,neuman
        if((mf /= ms).or.(nf /= ns)) &
     &    stop 'Restart with different values of mf and nf'
          
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of boundary have been read.'
        read(15,*) ((pot(i,j),i=0,mf),j=-nf,nf)
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of potential have been read.'
        read(15,*) curtor,curpol,bz0,totcur,phiedge
        if( ltrace_progress) write(6,*)'common block vbfield has been read.'
        if( ltrace_progress) write(6,*) curtor,curpol,bz0,totcur,phiedge
        read(15,*) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,curcor,ivertb
        if( ltrace_progress) write(6,*)'common block coilcurrents has been read.'
        if( ltrace_progress) write(6,*) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,curcor,ivertb
        close(unit=15)

      case (2)
        write(6,*) &
     &    'Not active in diagno_input_simple.'
      case (3)
        write(6,*)'Not yet implemented!'
      case (4)
        write(6,*)'Not yet implemented!'
      case default
        write(6,*)'Unknown case in dread/module diagno_input: ' &
     &            ,idiag(1)
        stop ' Check diag.data!'
      end select

      if(idiag(1) /= idiag(2)) &
     &  call write_input_w7as_cc(lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu,&
     &     cr,cz,mf,nf,ms,ns,neuman,pot,curtor,curpol,bz0,totcur,  &
     &     phiedge,curmod,curson,curaux,curcoils,deltbz,curivert,  &
     &     curcor,ivertb)

      current(1) = curmod
      current(2) = curson
      current(3) = curaux
      current(4) = curivert
      current(5) = curcor
      current = c_scale*current
!     current(1) = 0
!     current(2) = 0
!     current(3) = 0
!     current(4) = 1000
!     current(5) = 0
!     curtor = 0
      tor_cur = c_scale*curtor
      cr(0:mf,0)=2*cr(0:mf,0)
      cz(0:mf,0)=2*cz(0:mf,0)
      cr = m_scale*cr
      cz = m_scale*cz
      pot = pot/c_scale
      phiedge = phiedge/c_scale*m_scale
      deltbz = deltbz/c_scale/m_scale
      np = lnvp/lnv
      if(i_show >= 1)then
        write(6,*)'lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu'
        write(6,*)  lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu
        write(6,*)'Number of field periods:',np
        write(6,*)'Coil currents ',machine_string,':'
        write(6,*)'      Im/A        I5/A      It/A         Iv/A'&
     &           ,'     Icc/A'
        write(6,'(1p,9e12.4)')(current(i),i=1,nc)
        write(6,*)'      Bz/T'
        write(6,'(1p,e12.4)')deltbz
        write(6,*)'  tor.curr/A'
        write(6,'(1p,e12.4)')tor_cur
        write(6,*)'  phiedge/Wb'
        write(6,'(1p,e12.4)')phiedge
        if(i_show == 2)then
          do j=-nf,nf
            do i=0,mf
              write(6,'(2i4,1p3e14.5)')i,j,cr(i,j),cz(i,j),pot(i,j)
            enddo
          enddo
        endif
      endif

      end subroutine read_input_w7as_cc
!--------- end module subroutine -----------------
!------------- module subroutine -----------------
!! writes different diagno input format corresponding to
!! read_input_w7as
      subroutine write_input_w7as &
     &    (lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu,&
     &     cr,cz,mf,nf,ms,ns,neuman,pot,curtor,curpol,bz0,totcur, &
     &     phiedge,curmod,curson,curaux,curcoils,deltbz,curivert, &
     &     ivertb)

      use constants

      implicit none
      integer,intent(in) :: lnu,lnv,lnuv,lnvp,ivacfin, &
     &                      ms,ns,mf,nf,icon,isteu,neuman,ivertb
      real(rprec),intent(in) :: curtor,curpol,bz0,totcur,phiedge, &
     &        curmod,curson,curaux,curcoils,deltbz,curivert
      real(rprec), dimension(0:mf,-nf:nf), intent(in) :: cr,cz,pot
      integer :: i,j
      character(60) :: filename
      character(15) :: action

!******************************

      select case(idiag(2))
      case (0)
        rewind(15)
        write(15)  lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu
        if( ltrace_progress) write(6,*)'common block vacgrid has been read.'
        write(15) ((cr(i,j),i=0,mf),j=-nf,nf), &
     &          ((cz(i,j),i=0,mf),j=-nf,nf),ms,ns,neuman
        if((mf /= ms).or.(nf /= ns)) &
     &    stop 'Restart with different values of mf and nf'
          
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of boundary have been read.'
        write(15) ((pot(i,j),i=0,mf),j=-nf,nf)
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of potential have been read.'
        write(15) curtor,curpol,bz0,totcur,phiedge
        if( ltrace_progress) write(6,*)'common block vbfield has been read.'
        if( ltrace_progress) write(6,*) curtor,curpol,bz0,totcur,phiedge
        write(15) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,ivertb
        if( ltrace_progress) write(6,*)'common block coilcurrents has been read.'
        if( ltrace_progress) write(6,*) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,ivertb

      case (1)
!       write(6,*)'Not yet implemented!'
        open(unit=15,file='diagno.input_data.new_ascii' &
     &      ,status='unknown',action='write')
        write(15,*)  lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu
        if( ltrace_progress) write(6,*)'common block vacgrid has been read.'
        write(15,*) ((cr(i,j),i=0,mf),j=-nf,nf), &
     &          ((cz(i,j),i=0,mf),j=-nf,nf),ms,ns,neuman
        if((mf /= ms).or.(nf /= ns)) &
     &    stop 'Restart with different values of mf and nf'
          
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of boundary have been read.'
        write(15,*) ((pot(i,j),i=0,mf),j=-nf,nf)
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of potential have been read.'
        write(15,*) curtor,curpol,bz0,totcur,phiedge
        if( ltrace_progress) write(6,*)'common block vbfield has been read.'
        if( ltrace_progress) write(6,*) curtor,curpol,bz0,totcur,phiedge
        write(15,*) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,ivertb
        if( ltrace_progress) write(6,*)'common block coilcurrents has been read.'
        if( ltrace_progress) write(6,*) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,ivertb
        close(unit=15)

      case (2)
        write(6,*) &
     &    'Not active in diagno_input_simple.'
      case (3)
        write(6,*)'Not yet implemented!'
      case (4)
        write(6,*)'Not yet implemented!'
      case default
        write(6,*)'Unknown case in write_input_w7as/module',&
     &            ' diagno_input: ',idiag(2)
        stop ' Check diag.data!'
      end select

      end subroutine write_input_w7as
!--------- end module subroutine -----------------
!------------- module subroutine -----------------
!! writes different diagno input format corresponding to
!! read_input_w7as_cc
      subroutine write_input_w7as_cc &
     &    (lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu,&
     &     cr,cz,mf,nf,ms,ns,neuman,pot,curtor,curpol,bz0,totcur, &
     &     phiedge,curmod,curson,curaux,curcoils,deltbz,curivert, &
     &     curcor,ivertb)

      use constants

      implicit none
      integer,intent(in) :: lnu,lnv,lnuv,lnvp,ivacfin, &
     &                      ms,ns,mf,nf,icon,isteu,neuman,ivertb
      real(rprec),intent(in) :: curtor,curpol,bz0,totcur,phiedge, &
     &        curmod,curson,curaux,curcoils,deltbz,curivert,curcor
      real(rprec), dimension(0:mf,-nf:nf), intent(in) :: cr,cz,pot
      integer :: i,j
      character(60) :: filename
      character(15) :: action

!******************************

      select case(idiag(2))
      case (0)
        rewind(15)
        write(15)  lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu
        if( ltrace_progress) write(6,*)'common block vacgrid has been written.'
        write(15) ((cr(i,j),i=0,mf),j=-nf,nf), &
     &          ((cz(i,j),i=0,mf),j=-nf,nf),ms,ns,neuman
        if((mf /= ms).or.(nf /= ns)) &
     &    stop 'Restart with different values of mf and nf'
          
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of boundary have been written.'
        write(15) ((pot(i,j),i=0,mf),j=-nf,nf)
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of potential have been written.'
        write(15) curtor,curpol,bz0,totcur,phiedge
        if( ltrace_progress) write(6,*)'common block vbfield has been read.'
        if( ltrace_progress) write(6,*) curtor,curpol,bz0,totcur,phiedge
        write(15) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,curcor,ivertb
        if( ltrace_progress) write(6,*)'common block coilcurrents has been written.'
        if( ltrace_progress) write(6,*) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,curcor,ivertb

      case (1)
!       write(6,*)'Not yet implemented!'
        open(unit=15,file='diagno.input_data.new_ascii' &
     &      ,status='unknown',action='write')
        write(15,*)  lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu
        if( ltrace_progress) write(6,*)'common block vacgrid has been written.'
        write(15,*) ((cr(i,j),i=0,mf),j=-nf,nf), &
     &          ((cz(i,j),i=0,mf),j=-nf,nf),ms,ns,neuman
        if((mf /= ms).or.(nf /= ns)) &
     &    stop 'Restart with different values of mf and nf'
          
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of boundary have been written.'
        write(15,*) ((pot(i,j),i=0,mf),j=-nf,nf)
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of potential have been written.'
        write(15,*) curtor,curpol,bz0,totcur,phiedge
        if( ltrace_progress) write(6,*)'common block vbfield has been written.'
        if( ltrace_progress) write(6,*) curtor,curpol,bz0,totcur,phiedge
        write(15,*) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,curcor,ivertb
        if( ltrace_progress) write(6,*)'common block coilcurrents has been written.'
        if( ltrace_progress) write(6,*) &
     &     curmod,curson,curaux,curcoils,deltbz,curivert,curcor,ivertb
        close(unit=15)

      case (2)
        write(6,*) &
     &    'Not active in diagno_input_simple.'
      case (3)
        write(6,*)'Not yet implemented!'
      case (4)
        write(6,*)'Not yet implemented!'
      case default
        write(6,*)'Unknown case in write_input_w7as_cc/module',&
     &            ' diagno_input: ',idiag(2)
        stop ' Check diag.data!'
      end select

      end subroutine write_input_w7as_cc
!--------- end module subroutine -----------------
!------------- module subroutine -----------------
!! reads input for W7-X calculation
      subroutine read_input_w7x

      use constants

      implicit none
      integer :: lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu,neuman
      real(rprec) :: curtor,curpol,bz0,totcur, &
     &        cur1,cur2,cur3,cur4,cur5,curA,curB,curcoils, &
     &        c_scale,m_scale
      integer :: i_alloc,i,j,ms,ns, i_show, isc_c, isc_m
      character(60) :: filename,outfilename
      character(15) :: action

!******************************
      i_show = 0
      if( ltrace_progress) i_show = 1    !0=noshow 1=show currents 2=curr+Four.coeff
      isc_c = 1     !scale currents by 1/sqrtmuo
      isc_m = 1     !scale dimensions from cm to m
      c_scale = 1
      m_scale = 1
      if(isc_c == 1) c_scale = 1/sqrtmuo
      if(isc_m == 1) m_scale = 0.01_rprec
      filename = 'diagno.input_data'
      outfilename = 'diagno.input_data.new'

      write(6,*) 'Enter mf,nf:'
      read(5,*)  mf,nf
      write(6,*)'mf = ',mf,'nf = ',nf
      allocate(pot(0:mf,-nf:nf),cr(0:mf,-nf:nf),cz(0:mf,-nf:nf),&
     &     stat = i_alloc)
      if(i_alloc /= 0) stop 'Allocation of arrays dread failed!'

      select case(idiag(1))
      case (0)
        rewind(15)
        read(15)  lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu
        if( ltrace_progress) write(6,*)'common block vacgrid has been read.'
        read(15) ((cr(i,j),i=0,mf),j=-nf,nf), &
     &          ((cz(i,j),i=0,mf),j=-nf,nf),ms,ns,neuman
        if((mf /= ms).or.(nf /= ns)) &
     &    stop 'Restart with different values of mf and nf'
          
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of boundary have been read.'
        read(15) ((pot(i,j),i=0,mf),j=-nf,nf)
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of potential have been read.'
        read(15) curtor,curpol,bz0,totcur,phiedge
        if( ltrace_progress) write(6,*)'common block vbfield has been read.'
        if( ltrace_progress) write(6,*) curtor,curpol,bz0,totcur,phiedge
        read(15) &
     &        cur1,cur2,cur3,cur4,cur5,curA,curB,curcoils
        if( ltrace_progress) write(6,*)'common block coilcurrents has been read.'
        if( ltrace_progress) write(6,*) &
     &        cur1,cur2,cur3,cur4,cur5,curA,curB,curcoils

      case (1)
!       write(6,*)'Not yet implemented!'
        rewind(15)
        read(15,*)  lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu
        if( ltrace_progress) write(6,*)'common block vacgrid has been read.'
        read(15,*) ((cr(i,j),i=0,mf),j=-nf,nf), &
     &          ((cz(i,j),i=0,mf),j=-nf,nf),ms,ns,neuman
        if((mf /= ms).or.(nf /= ns)) &
     &    stop 'Restart with different values of mf and nf'
          
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of boundary have been read.'
        read(15,*) ((pot(i,j),i=0,mf),j=-nf,nf)
        if( ltrace_progress) write(6,*) &
     &    'fourier coefficients of potential have been read.'
        read(15,*) curtor,curpol,bz0,totcur,phiedge
        if( ltrace_progress) write(6,*)'common block vbfield has been read.'
        if( ltrace_progress) write(6,*) curtor,curpol,bz0,totcur,phiedge
        read(15,*) &
     &        cur1,cur2,cur3,cur4,cur5,curA,curB,curcoils
        if( ltrace_progress) write(6,*)'common block coilcurrents has been read.'
        if( ltrace_progress) write(6,*) &
     &        cur1,cur2,cur3,cur4,cur5,curA,curB,curcoils


      case (2)
        write(6,*) &
     &    'Not active in diagno_input_simple.'
      case (3)
        write(6,*)'Not yet implemented!'
      case (4)
        write(6,*)'Not yet implemented!'
      case default
        write(6,*)'Unknown case in dread/module diagno_input: ' &
     &            ,idiag(1)
        stop ' Check diag.data!'
      end select

      if(idiag(1) /= idiag(2)) &
     &  call write_input_w7x(lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu,&
     &     cr,cz,mf,nf,ms,ns,neuman,pot,curtor,curpol,bz0,totcur,  &
     &     phiedge,cur1,cur2,cur3,cur4,cur5,curA,curB,curcoils)

      current(1) = cur1
      current(2) = cur2
      current(3) = cur3
      current(4) = cur4
      current(5) = cur5
      current(6) = curA
      current(7) = curB
      current = c_scale*current
!     current(1) = 0
!     current(2) = 0
!     current(3) = 0
!     current(4) = 1000
!     current(5) = 0
!     current(6) = 0
!     current(7) = 0
!     curtor = 0
      tor_cur = c_scale*curtor
      cr(0:mf,0)=2*cr(0:mf,0)
      cz(0:mf,0)=2*cz(0:mf,0)
      cr = m_scale*cr
      cz = m_scale*cz
      pot = pot/c_scale
      phiedge = phiedge/c_scale*m_scale
      np = lnvp/lnv
      if(i_show >= 1)then
        write(6,*)'lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu'
        write(6,*)  lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu
        write(6,*)'Number of field periods:',np
        write(6,*)'Coil currents ',machine_string,':'
        write(6,'(7a12)')'      I1/A  ','      I2/A  ','      I3/A  ', &
     &    '      I4/A  ','      I5/A  ','     I_A/A  ','     I_B/A  '
        write(6,'(1p,9e12.4)')(current(i),i=1,nc)
        write(6,*)'  tor.curr/A'
        write(6,'(1p,e12.4)')tor_cur
        if(i_show == 2)then
          do j=-nf,nf
            do i=0,mf
              write(6,'(2i4,1p2e14.5)')i,j,cr(i,j),cz(i,j)
            enddo
          enddo
        endif
      endif
      end subroutine read_input_w7x
!--------- end module subroutine -----------------
!------------- module subroutine -----------------
!! Writes input for W7-X calculation corresponding
!! to read_input_w7x
      subroutine write_input_w7x(lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu,&
     &     cr,cz,mf,nf,ms,ns,neuman,pot,curtor,curpol,bz0,totcur,  &
     &     phiedge,cur1,cur2,cur3,cur4,cur5,curA,curB,curcoils)

      implicit none
      integer :: lnu,lnv,lnuv,lnvp,ivacfin,icon,isteu, &
     &           mf,nf,ms,ns,neuman
      real(rprec), dimension(0:mf,-nf:nf) :: cr,cz,pot
      real(rprec) :: curtor,curpol,bz0,totcur,phiedge, &
     &        cur1,cur2,cur3,cur4,cur5,curA,curB,curcoils

      stop 'Sorry, implementation has just been started!'

      end subroutine write_input_w7x
!--------- end module subroutine -----------------
!------------- module subroutine -----------------
      subroutine read_input_vmec2000
      implicit none
      character(15) :: tline1
      integer :: mf1,mf2,m,n,nmin,i_alloc,i_show
      real(rprec) :: rdum

      open(unit=15,file='diagno_in.'//trim(id_string) &
     &      ,status='unknown',action='read')

      i_show = 0
      if( ltrace_progress) i_show = 1    !0=noshow 1=show currents 2=curr+Four.coeff
      read(15,*) tline1
      read(15,*) tline1
      read(15,*) np,mf1,nf
      mf = mf1+1    !vmec2000 uses m=0,...,mpol+1 for potvac
      mf2= mf1-1    !vmec2000 uses m=0,...,mpol-1 for r and z
      allocate(pot(0:mf,-nf:nf),cr(0:mf,-nf:nf),cz(0:mf,-nf:nf),&
     &     raxfc(0:nf), zaxfc(0:nf),&
     &     stat = i_alloc)
      if(i_alloc /= 0) stop 'Allocation of arrays dread failed!'
      pot = 0 ; cr = 0 ; cz = 0
      read(15,*) tline1
      do m=0,mf2
        nmin = -nf
        if(m == 0) nmin=0
        do n=nmin,nf
          read(15,*) cr(m,-n)   !vmec2000 uses cos(mu-nv) and
        enddo                   !diagno uses cos(mu+nv)
      enddo
      read(15,*) tline1
      do m=0,mf2
        nmin = -nf
        if(m == 0) nmin=0
        do n=nmin,nf
          read(15,*) cz(m,-n)   !vmec2000 uses cos(mu-nv) and
        enddo                   !diagno uses cos(mu+nv)
      enddo
      read(15,*) tline1
      do n=-nf,nf
        do m=0,mf
          read(15,*) pot(m,-n)  !vmec2000 uses (mu-nv) and
        enddo                   !diagno uses (mu+nv)
      enddo
      do n=1,nf
        pot(0, n) = -pot(0,-n)  !diagno assumes that also
      enddo                     !the other part is there.
      pot = -pot / 2            !sin goes to -sin
                                !factor 0.5 from old vacuum
      read(15,*) tline1
      read(15,*) phiedge
      read(15,*) tline1
      read(15,*) nc
!the number of external coils has to be redefined in the case
!of W7-AS because vmec2000 treats currently the vertical field
!system as 3 coils and diagno as 1 coil system, therefore
! nc(vmec2000) - 2 = nc(diagno)
      select case (machine_string)
      case ("W7-AS")
        if(nc /= 6) then
          write(6,*)'machine_string and number of ext.currents',&
     &              ' not consistent!'
          stop 'Check input data!'
        endif
        nc = nc-2
        call allocate_current
        read(15,*) tline1
        read(15,*) current
        current(1)=current(1)/8
        current(2)=current(2)/20
        current(3)=current(3)/12
        current(4)=current(4)*5/232.0_rprec
        ivertb = 1
        deltbz = 0
      case ("W7-AS_cc")
        if(nc /= 7) then
          write(6,*)'machine_string and number of ext.currents',&
     &              ' not consistent!'
          stop 'Check input data!'
        endif
        nc = nc-2
        call allocate_current
        read(15,*) tline1
        read(15,*) current
        current(1)=current(1)/8
        current(2)=current(2)/20
        current(3)=current(3)/12
        current(4)=current(4)/8
        current(5)=current(5)*5/232.0_rprec
        rdum = current(4)       !save Icor
        current(4) = - current(5) !put Ivert on position 4
        current(5) = rdum       !put Icor  on position 5
        ivertb = 1
        deltbz = 0
      case ("W7-X")
        if(nc /= 7) then
          write(6,*)'machine_string and number of ext.currents',&
     &              ' not consistent!'
          stop 'Check input data!'
        endif
        call allocate_current
        read(15,*) tline1
        read(15,*) current
      case default
        write(6,*)'Unknown machine : ',machine_string
        stop 'Check input for machine_string!'
      end select
      read(15,*) tline1
      read(15,*) tor_cur
      read(15,*) tline1
      read(15,*) raxfc
      read(15,*) tline1
      read(15,*) zaxfc
      zaxfc = -zaxfc  ! due to sin(-n v) = -sin( n v)
      if(i_show >= 1)then
        write(6,*)'Number of field periods:',np
        write(6,*)'Coil currents ',machine_string,':'
        write(6,'(5a12)')'      Im/A  ','      Is/A  ','      It/A  ', &
     &    '      Iv/A  ','      Ic/A  '
        write(6,'(1p,9e12.4)')(current(n),n=1,nc)
        write(6,*)'  tor.curr/A'
        write(6,'(1p,e12.4)')tor_cur
        if(i_show == 2)then
          do n=-nf,nf
            do m=0,mf
              write(6,'(2i4,1p3e14.5)')m,n,cr(m,n),cz(m,n),pot(m,n)
            enddo
          enddo
        endif
      endif

      end subroutine read_input_vmec2000
!--------- end module subroutine -----------------

      end module diagno_input



      module coilsystem
!! contains information about coil systems used, i.e. coil geometry
!! and the subroutines to read it

      use constants
      use diagno_input

      implicit none

      integer :: nall,ntopo
      real(rprec), dimension(:), allocatable :: xw,yw,zw,curre
      integer :: nc_vert
      real(rprec), dimension(:), allocatable :: r_v,z_v,f_v

      save

      contains

!-------------------------------------------------
      subroutine readcoil(machine_string)

      implicit none

      character(10), intent(in) :: machine_string

      select case (machine_string)

      case ("W7-AS")
        if( ltrace_progress) write(6,*)'Coils of ',machine_string,' requested!'
        call readcoil_w7as
        call readvert_w7as
      case ("W7-AS_ttf")  !with tilted tor.field coils
        if( ltrace_progress) write(6,*)'Coils of ',machine_string,' requested!'
        call readcoil_w7as_ttf
        call readvert_w7as
      case ("W7-AS_cc")  !with tilted tor.field coils and corr. coils
        if( ltrace_progress) write(6,*)'Coils of ',machine_string,' requested!'
        call readcoil_w7as_cc
        call readvert_w7as
      case ("W7-X")
        if( ltrace_progress) write(6,*)'Coils of ',machine_string,' requested!'
        call readcoil_w7x
      case default
        if( ltrace_progress) write(6,*)'Unknown machine : ',machine_string
        stop 'Check input for machine_string!'

      end select

      end subroutine readcoil
!-------------------------------------------------

!-------------------------------------------------
      subroutine readcoil_w7as

      use constants
      implicit none

      integer, parameter :: nspul= 1300
      integer :: nw,nw1,nwk,l,i_alloc,npol,k
      real(rprec) :: alp, co, si, r, r0, dr, dtheta

      ntopo = nspul*np
      allocate(xw(ntopo),yw(ntopo),zw(ntopo),curre(ntopo), &
     &      stat = i_alloc)
      if(i_alloc /= 0) &
     &        stop 'Allocation of arrays readcoil_w7as failed!'

      print *,'coils file:',diagno_coils_file
      open(unit=88,file=trim(diagno_coils_file),status='old' &
     &    ,action='read', iostat=i_alloc)
      if (i_alloc .ne. 0) then
         print *,'error opening w7as.coils file ',  &
     &            diagno_coils_file
         stop
       endif
!      rewind(88)
      read(88, *  ) nw
      if( ltrace_progress) write(6,'(a4,i3)') ' nw=',nw
      if( ltrace_progress) write(6,'(a6,i5)') 'ntopo=',ntopo
      if(nw>=nspul)then
        write(6,*)'nw >= nspul=',nspul
        stop 'Increase nspul'
      endif
      do l=1,nw
        read(88,*   ) xw(l),yw(l),zw(l),curre(l)
      enddo

      read(88,  * ) nw1
      if( ltrace_progress) write(6,'(a4,i3)') 'nw1=',nw1
      if(nw+nw1>nspul)then
        write(6,*)'nw > nspul=',nspul
        stop 'Increase nspul'
      endif
      do l=nw+1,nw+nw1
        read(88,*   ) xw(l),yw(l),zw(l),curre(l)
      enddo

      close(88)
!*************************************************
! conversion from [cm] to [m]
!*************************************************
      xw = xw/100
      yw = yw/100
      zw = zw/100

      curre = 0
      curre(1:49*8)      = 8*current(1)         !modular coils
      curre(490+1:49*18) = 8*current(1)         !modular coils
      curre(8*49+1:490)  = 20*current(2)        !special coils
      curre(18*49+1:20*49) = 12*current(3)      !tor.field coils
      curre(49:nw+nw1:49) = 0     !termination of single coil

!*************************************************
! symmetrisize coils !
!*************************************************
      l=0
      do k=1,8
        do npol=1,49
          xw(882-l) =  xw(l+1)
          yw(882-l) = -yw(l+1)
          zw(882-l) = -zw(l+1)
          l = l+1
        enddo
      enddo
      alp    = twopi/float(np)
      co     = cos(alp)
      si     = sin(alp)
      l=1          ! First Sonder Coil filament
      do npol=1,23
        xw(441-l) =  xw(l+393)*co + yw(l+393)*si
        yw(441-l) =  xw(l+393)*si - yw(l+393)*co
        zw(441-l) = -zw(l+393)
        l = l+1
      enddo
      alp    = twopi/float(2*np)
      co     = cos(alp)
      si     = sin(alp)
      r =  sqrt(xw(393)**2 + yw(393)**2)
      xw(393) =  r*co
      yw(393) =  r*si
      zw(393) = 0
      r =  sqrt(xw(417)**2 + yw(417)**2)
      xw(417) =  r*co
      yw(417) =  r*si
      zw(417) = 0
      xw(441) =  xw(393)
      yw(441) =  yw(393)
      zw(441) = 0
      alp    = twopi/float(np)
      co     = cos(alp)
      si     = sin(alp)
      l=1          ! Second Sonder Coil filament
      do npol=1,23
        xw(490-l) =  xw(l+442)*co + yw(l+442)*si
        yw(490-l) =  xw(l+442)*si - yw(l+442)*co
        zw(490-l) = -zw(l+442)
        l = l+1
      enddo
      alp    = twopi/float(2*np)
      co     = cos(alp)
      si     = sin(alp)
      r =  sqrt(xw(442)**2 + yw(442)**2)
      xw(442) =  r*co
      yw(442) =  r*si
      zw(442) = 0
      r =  sqrt(xw(466)**2 + yw(466)**2)
      xw(466) =  r*co
      yw(466) =  r*si
      zw(466) = 0
      xw(490) =  xw(442)
      yw(490) =  yw(442)
      zw(490) = 0
!*************************************************
! Calculate toroidal field coils
!*************************************************
      r0 = 2
      dr = 0.88_rprec
      alp = 13.5_rprec*onerad
      co     = cos(alp)
      si     = sin(alp)
      l=1
      do npol=1,23           ! upper half first coil
        dtheta = twopi/48
        xw(nw+1+l) = (r0+dr*cos(l*dtheta))*co
        yw(nw+1+l) = (r0+dr*cos(l*dtheta))*si
        zw(nw+1+l) =     dr*sin(l*dtheta)
        l = l+1
      enddo
      l=1
      do npol=1,23           ! lower half first coil
        dtheta = twopi/48
        xw(nw+49-l) =  xw(nw+1+l)
        yw(nw+49-l) =  yw(nw+1+l)
        zw(nw+49-l) = -zw(nw+1+l)
        l = l+1
      enddo
      xw(nw+1)  =  (r0+dr)*co
      yw(nw+1)  =  (r0+dr)*si
      zw(nw+1)  =  0
      xw(nw+25) =  (r0-dr)*co
      yw(nw+25) =  (r0-dr)*si
      zw(nw+25) =  0
      xw(nw+49) = xw(nw+1)
      yw(nw+49) = yw(nw+1)
      zw(nw+49) = 0
      l=0
      do npol=1,49           ! Second toroidal field coils
        xw(980-l) =  xw(l+883)
        yw(980-l) = -yw(l+883)
        zw(980-l) = -zw(l+883)
        l = l+1
      enddo
!-----------------------------
      nw     = nw + nw1                   ! do all in any case.
      nall   = nw*np
      alp    = twopi/float (np)
      co     = cos(alp)
      si     = sin(alp)
      do k=1,np-1
        nwk    = nw*k
        xw(nwk+1:nwk+nw) = xw(nwk-nw+1:nwk)*co - yw(nwk-nw+1:nwk)*si
        yw(nwk+1:nwk+nw) = xw(nwk-nw+1:nwk)*si + yw(nwk-nw+1:nwk)*co
        zw(nwk+1:nwk+nw) = zw(nwk-nw+1:nwk)
        curre(nwk+1:nwk+nw) = curre(1:nw)
      enddo
!     do k=1,nall
!       write(3,'(1p,4e14.5)')xw(k),yw(k),zw(k),curre(k)
!     enddo
!     stop

      end subroutine readcoil_w7as
!-------------------------------------------------
      subroutine readcoil_w7as_ttf
!- with tilted toroidal field coils ----

      use constants
      implicit none

      integer, parameter :: nspul= 1000
      integer :: nw,nw1,nwk,l,i_alloc,npol,k
      real(rprec) :: alp, co, si, r, r0, dr, dtheta
      real(rprec) :: th0, co2, si2

      ntopo = nspul*np
      allocate(xw(ntopo),yw(ntopo),zw(ntopo),curre(ntopo), &
     &      stat = i_alloc)
      if(i_alloc /= 0) &
     &        stop 'Allocation of arrays readcoil_w7as failed!'

      open(unit=88,file=trim(diagno_coils_file),status='old' &
     &    ,action='read', iostat=i_alloc)
      if (i_alloc .ne. 0) stop 'error opening w7as.coils file'
!      rewind(88)
      read(88, *  ) nw
      if( ltrace_progress) write(6,'(a4,i3)') ' nw=',nw
      if( ltrace_progress) write(6,'(a6,i5)') 'ntopo=',ntopo
      if(nw>=nspul)then
        write(6,*)'nw >= nspul=',nspul
        stop 'Increase nspul'
      endif
      do l=1,nw
        read(88,*   ) xw(l),yw(l),zw(l),curre(l)
      enddo

      read(88,  * ) nw1
      if( ltrace_progress) write(6,'(a4,i3)') 'nw1=',nw1
      if(nw+nw1>nspul)then
        write(6,*)'nw > nspul=',nspul
        stop 'Increase nspul'
      endif
      do l=nw+1,nw+nw1
        read(88,*   ) xw(l),yw(l),zw(l),curre(l)
      enddo

      close(88)
!*************************************************
! conversion from [cm] to [m]
!*************************************************
      xw = xw/100
      yw = yw/100
      zw = zw/100

      curre = 0
      curre(1:49*8)      = 8*current(1)         !modular coils
      curre(490+1:49*18) = 8*current(1)         !modular coils
      curre(8*49+1:490)  = 20*current(2)        !special coils
      curre(18*49+1:20*49) = 12*current(3)      !tor.field coils
      curre(49:nw+nw1:49) = 0     !termination of single coil

!*************************************************
! symmetrisize coils !
!*************************************************
      l=0
      do k=1,8
        do npol=1,49
          xw(882-l) =  xw(l+1)
          yw(882-l) = -yw(l+1)
          zw(882-l) = -zw(l+1)
          l = l+1
        enddo
      enddo
      alp    = twopi/float(np)
      co     = cos(alp)
      si     = sin(alp)
      l=1          ! First Sonder Coil filament
      do npol=1,23
        xw(441-l) =  xw(l+393)*co + yw(l+393)*si
        yw(441-l) =  xw(l+393)*si - yw(l+393)*co
        zw(441-l) = -zw(l+393)
        l = l+1
      enddo
      alp    = twopi/float(2*np)
      co     = cos(alp)
      si     = sin(alp)
      r =  sqrt(xw(393)**2 + yw(393)**2)
      xw(393) =  r*co
      yw(393) =  r*si
      zw(393) = 0
      r =  sqrt(xw(417)**2 + yw(417)**2)
      xw(417) =  r*co
      yw(417) =  r*si
      zw(417) = 0
      xw(441) =  xw(393)
      yw(441) =  yw(393)
      zw(441) = 0
      alp    = twopi/float(np)
      co     = cos(alp)
      si     = sin(alp)
      l=1          ! Second Sonder Coil filament
      do npol=1,23
        xw(490-l) =  xw(l+442)*co + yw(l+442)*si
        yw(490-l) =  xw(l+442)*si - yw(l+442)*co
        zw(490-l) = -zw(l+442)
        l = l+1
      enddo
      alp    = twopi/float(2*np)
      co     = cos(alp)
      si     = sin(alp)
      r =  sqrt(xw(442)**2 + yw(442)**2)
      xw(442) =  r*co
      yw(442) =  r*si
      zw(442) = 0
      r =  sqrt(xw(466)**2 + yw(466)**2)
      xw(466) =  r*co
      yw(466) =  r*si
      zw(466) = 0
      xw(490) =  xw(442)
      yw(490) =  yw(442)
      zw(490) = 0
!*************************************************
! Calculate toroidal field coils
!*************************************************
      r0 = 2
      dr = 0.88_rprec
      alp = 13.5_rprec*onerad
      co     = cos(alp)
      si     = sin(alp)
      l=1
      th0 =-0.149_rprec*twopi/360
      co2    = cos(th0)
      si2    = sin(th0)
      l=1
      do l=0,48             ! do all
        dtheta = twopi/48
        xw(nw+l+1) = (r0+dr*cos(l*dtheta))*co + dr*sin(l*dtheta)*si2*si
        yw(nw+l+1) = (r0+dr*cos(l*dtheta))*si - dr*sin(l*dtheta)*si2*co
        zw(nw+l+1) =     dr*sin(l*dtheta)*co2
      enddo
      do l=1,23
        zw(nw+49-l) = -zw(nw+1+l)
      enddo
      xw(nw+1)  = (r0+dr)*co
      yw(nw+1)  = (r0+dr)*si
      zw(nw+1)  = 0
      xw(nw+25) = (r0-dr)*co
      yw(nw+25) = (r0-dr)*si
      zw(nw+25) = 0
      xw(nw+49) = xw(nw+1)
      yw(nw+49) = yw(nw+1)
      zw(nw+49) = 0
      l=0
      do npol=1,49           ! Second toroidal field coils
        xw(980-l) =  xw(l+883)
        yw(980-l) = -yw(l+883)
        zw(980-l) = -zw(l+883)
        l = l+1
      enddo
!-----------------------------
      nw     = nw + nw1                   ! do all in any case.
      nall   = nw*np
      alp    = twopi/float (np)
      co     = cos(alp)
      si     = sin(alp)
      do k=1,np-1
        nwk    = nw*k
        xw(nwk+1:nwk+nw) = xw(nwk-nw+1:nwk)*co - yw(nwk-nw+1:nwk)*si
        yw(nwk+1:nwk+nw) = xw(nwk-nw+1:nwk)*si + yw(nwk-nw+1:nwk)*co
        zw(nwk+1:nwk+nw) = zw(nwk-nw+1:nwk)
        curre(nwk+1:nwk+nw) = curre(1:nw)
      enddo
!     do k=1,nall
!       write(3,'(1p,4e14.5)')xw(k),yw(k),zw(k),curre(k)
!     enddo
!     stop
      end subroutine readcoil_w7as_ttf
!-------------------------------------------------
      subroutine readcoil_w7as_cc
!- with tilted toroidal field coils ----

      use constants
      implicit none

      integer, parameter :: nspul= 1000
      integer :: nw,nw1,nw2,nwk,l,i_alloc,npol,k
      real(rprec) :: alp, co, si, r, r0, dr, dtheta
      real(rprec) :: th0, co2, si2

      ntopo = nspul*np
      allocate(xw(ntopo),yw(ntopo),zw(ntopo),curre(ntopo), &
     &      stat = i_alloc)
      if(i_alloc /= 0) &
     &        stop 'Allocation of arrays readcoil_w7as failed!'

      open(unit=88,file=trim(diagno_coils_file),status='old' &
     &    ,action='read', iostat=i_alloc)
      if (i_alloc .ne. 0) then
         print *,'error opening w7as.coils file',diagno_coils_file
         stop
      endif
!      rewind(88)
      read(88, *  ) nw
      if( ltrace_progress) write(6,'(a4,i3)') ' nw=',nw
      if( ltrace_progress) write(6,'(a6,i5)') 'ntopo=',ntopo
      if(nw>=nspul)then
        write(6,*)'nw >= nspul=',nspul
        write(6,*)'Already ',nw, 'requested per period!'
        stop 'Increase nspul'
      endif
      do l=1,nw
        read(88,*   ) xw(l),yw(l),zw(l),curre(l)
      enddo

      read(88,  * ) nw1
      if( ltrace_progress) write(6,'(a4,i3)') 'nw1=',nw1
      if(nw+nw1>nspul)then
        write(6,*)'nw > nspul=',nspul
        write(6,*)'Already ',nw+nw1, 'requested per period!'
        stop 'Increase nspul'
      endif
      do l=nw+1,nw+nw1
        read(88,*   ) xw(l),yw(l),zw(l),curre(l)
      enddo

      read(88,  * ) nw2
      if( ltrace_progress) write(6,'(a4,i3)') 'nw2=',nw2
      if(nw+nw1+nw2>nspul)then
        write(6,*)'nw > nspul=',nspul
        write(6,*)nw+nw1+nw2, 'requested per period!'
        stop 'Increase nspul'
      endif
      do l=nw+nw1+1,nw+nw1+nw2
        read(88,*   ) xw(l),yw(l),zw(l),curre(l)
      enddo

      close(88)
!*************************************************
! conversion from [cm] to [m]
!*************************************************
      xw = xw/100
      yw = yw/100
      zw = zw/100

      curre = 0
      curre(1:49*8)      = 8*current(1)         !modular coils
      curre(490+1:49*18) = 8*current(1)         !modular coils
      curre(8*49+1:490)  = 20*current(2)        !special coils
      curre(18*49+1:20*49) = 12*current(3)      !tor.field coils
      curre(nw+nw1+ 1:nw+nw1+ 8) = 8*current(5) !corr. coils
      curre(nw+nw1+10:nw+nw1+17) = 8*current(5) !corr. coils
      curre(49:nw+nw1:49) = 0     !termination of single coil

!*************************************************
! symmetrisize coils !
!*************************************************
      l=0
      do k=1,8
        do npol=1,49
          xw(882-l) =  xw(l+1)
          yw(882-l) = -yw(l+1)
          zw(882-l) = -zw(l+1)
          l = l+1
        enddo
      enddo
      alp    = twopi/float(np)
      co     = cos(alp)
      si     = sin(alp)
      l=1          ! First Sonder Coil filament
      do npol=1,23
        xw(441-l) =  xw(l+393)*co + yw(l+393)*si
        yw(441-l) =  xw(l+393)*si - yw(l+393)*co
        zw(441-l) = -zw(l+393)
        l = l+1
      enddo
      alp    = twopi/float(2*np)
      co     = cos(alp)
      si     = sin(alp)
      r =  sqrt(xw(393)**2 + yw(393)**2)
      xw(393) =  r*co
      yw(393) =  r*si
      zw(393) = 0
      r =  sqrt(xw(417)**2 + yw(417)**2)
      xw(417) =  r*co
      yw(417) =  r*si
      zw(417) = 0
      xw(441) =  xw(393)
      yw(441) =  yw(393)
      zw(441) = 0
      alp    = twopi/float(np)
      co     = cos(alp)
      si     = sin(alp)
      l=1          ! Second Sonder Coil filament
      do npol=1,23
        xw(490-l) =  xw(l+442)*co + yw(l+442)*si
        yw(490-l) =  xw(l+442)*si - yw(l+442)*co
        zw(490-l) = -zw(l+442)
        l = l+1
      enddo
      alp    = twopi/float(2*np)
      co     = cos(alp)
      si     = sin(alp)
      r =  sqrt(xw(442)**2 + yw(442)**2)
      xw(442) =  r*co
      yw(442) =  r*si
      zw(442) = 0
      r =  sqrt(xw(466)**2 + yw(466)**2)
      xw(466) =  r*co
      yw(466) =  r*si
      zw(466) = 0
      xw(490) =  xw(442)
      yw(490) =  yw(442)
      zw(490) = 0
!*************************************************
! Calculate toroidal field coils
!*************************************************
      r0 = 2
      dr = 0.88_rprec
      alp = 13.5_rprec*onerad
      co     = cos(alp)
      si     = sin(alp)
      l=1
      th0 =-0.149_rprec*twopi/360
      co2    = cos(th0)
      si2    = sin(th0)
      l=1
      do l=0,48             ! do all
        dtheta = twopi/48
        xw(nw+l+1) = (r0+dr*cos(l*dtheta))*co + dr*sin(l*dtheta)*si2*si
        yw(nw+l+1) = (r0+dr*cos(l*dtheta))*si - dr*sin(l*dtheta)*si2*co
        zw(nw+l+1) =     dr*sin(l*dtheta)*co2
      enddo
      do l=1,23
        zw(nw+49-l) = -zw(nw+1+l)
      enddo
      xw(nw+1)  = (r0+dr)*co
      yw(nw+1)  = (r0+dr)*si
      zw(nw+1)  = 0
      xw(nw+25) = (r0-dr)*co
      yw(nw+25) = (r0-dr)*si
      zw(nw+25) = 0
      xw(nw+49) = xw(nw+1)
      yw(nw+49) = yw(nw+1)
      zw(nw+49) = 0
      l=0
      do npol=1,49           ! Second toroidal field coils
        xw(980-l) =  xw(l+883)
        yw(980-l) = -yw(l+883)
        zw(980-l) = -zw(l+883)
        l = l+1
      enddo
      l=0
      do npol=1,9               ! Second correction coil to get
        xw(998-l) =  xw(l+981)  ! a stellarator symmetric
        yw(998-l) = -yw(l+981)  ! second current since the
        zw(998-l) = -zw(l+981)  ! the currents are of equal sign
        l = l+1
      enddo
!-----------------------------
      nw     = nw + nw1 + nw2             ! do all in any case.
      nall   = nw*np
      alp    = twopi/float (np)
      co     = cos(alp)
      si     = sin(alp)
      do k=1,np-1
        nwk    = nw*k
        xw(nwk+1:nwk+nw) = xw(nwk-nw+1:nwk)*co - yw(nwk-nw+1:nwk)*si
        yw(nwk+1:nwk+nw) = xw(nwk-nw+1:nwk)*si + yw(nwk-nw+1:nwk)*co
        zw(nwk+1:nwk+nw) = zw(nwk-nw+1:nwk)
        curre(nwk+1:nwk+nw) = curre(1:nw)
      enddo
!     do k=1,nall
!       write(3,'(1p,4e14.5)')xw(k),yw(k),zw(k),curre(k)
!     enddo
!     stop

      end subroutine readcoil_w7as_cc
!-------------------------------------------------
      subroutine readvert_w7as
      use constants
      implicit none
      integer :: n,i_alloc

      open(unit=20,file=trim(vert_field_file),status='old' &
     &    ,action='read')

      read(20,*)nc_vert
      allocate(r_v(nc_vert),z_v(nc_vert),f_v(nc_vert), &
     &    stat = i_alloc)
      if(i_alloc /= 0) &
     &        stop 'Allocation of arrays readvert_w7as failed!'
      if( ltrace_progress) then
         write(6,*)'#Vertical field calculation using ',nc_vert,' Coils'
         write(6,*)'#Coil positions and number of filaments:'
         write(6,*)'#  R/m         z/m       #filaments'
      endif
      do n=1,nc_vert
        read(20,*) r_v(n),z_v(n),f_v(n)
        if( ltrace_progress) write(6,'(1p,3e12.4)') r_v(n),z_v(n),f_v(n)
      enddo
      close(unit=20)

      end subroutine readvert_w7as

      subroutine readcoil_w7x
! ----------------------------------------------------------------------
!
! Reads in the coordinates of a coilsystem. Indexcur marks the
! different parts of the coilsystem. Its value corresponds to
! the number of windings the conductor represents.
!
! ----------------------------------------------------------------------

      use constants
      implicit none

      integer, parameter :: nspul= 1300
      integer :: i,nw,nw1,nwk,l,i_alloc,npol,k
      real(rprec) :: alp, co, si

      ntopo = nspul*np
      allocate(xw(ntopo),yw(ntopo),zw(ntopo),curre(ntopo), &
     &      stat = i_alloc)
      if(i_alloc /= 0) &
     &        stop 'Allocation of arrays readcoil_w7x failed!'

      open(unit=88,file=trim(diagno_coils_file),status='old' &
     &    ,action='read', iostat=i_alloc)
      if (i_alloc .ne. 0) stop 'error opening w7x.coils file'
!      rewind(88)
!*************************************************
! Modular coils
!*************************************************
      read(88, *  ) nw
      if( ltrace_progress) write(6,'(i4)') nw
      do l=1,nw
        read(88,*   ) xw(l),yw(l),zw(l),curre(l)
        if(l.lt.10 .and. ltrace_progress) &
     &     write(6,'(1p,4e14.4)') xw(l),yw(l),zw(l),curre(l)
      enddo
!*************************************************
! Additional coils
!*************************************************
      read(88,  * ) nw1
      if( ltrace_progress) write(6,'(i4)') nw1
      if((nw+nw1).gt.nspul) then
        write(6,*)nw+nw1,' points for all coils!'
        write(6,*)nspul,' available! ==> Adjust nspul!'
        stop 'Emergency stop!'
      endif
      do l=nw+1,nw+nw1
        read(88,*   ) xw(l),yw(l),zw(l),curre(l)
      enddo

      close(88)
!*************************************************
! fix currents
! up to 13.Feb.2003 the winding number contained the old
!number of 120 windings instead of the new 108!
!*************************************************
      curre = 0
      curre(     1:   97) = 108*current(1)           !cur1
      curre(97*9+1:10*97) = 108*current(1)           !cur1
      curre(  97+1: 2*97) = 108*current(2)           !cur2
      curre(97*8+1: 9*97) = 108*current(2)           !cur2
      curre(2*97+1: 3*97) = 108*current(3)           !cur3
      curre(97*7+1: 8*97) = 108*current(3)           !cur3
      curre(3*97+1: 4*97) = 108*current(4)           !cur4
      curre(97*6+1: 7*97) = 108*current(4)           !cur4
      curre(4*97+1: 5*97) = 108*current(5)           !cur5
      curre(97*5+1: 6*97) = 108*current(5)           !cur5
      curre(nw+     1: nw+1*65) = 36*current(6)      !curA
      curre(nw+3*65+1: nw+4*65) = 36*current(6)      !curA
      curre(nw+1*65+1: nw+2*65) = 36*current(7)      !curB
      curre(nw+2*65+1: nw+3*65) = 36*current(7)      !curB
      curre(   97:nw    :97) = 0     !termination of single coil
      curre(nw+65:nw+nw1:65) = 0     !termination of single coil

!*************************************************
! symmetrisize coils !
!*************************************************
      i=0                ! Modular Coils
      do k=1,5
        do npol=1,97
          xw(970-i) =  xw(i+1)
          yw(970-i) = -yw(i+1)
          zw(970-i) = -zw(i+1)
          i = i+1
        enddo
      enddo
      i=0                ! Additional Coils
      do k=1,2
        do npol=1,65
          xw(1230-i) =  xw(i+971)
          yw(1230-i) = -yw(i+971)
          zw(1230-i) = -zw(i+971)
          i = i+1
        enddo
      enddo
!*************************************************
      nw     = nw + nw1                   ! Do all in any case.
      nall   = nw*np
      alp    = twopi/float(np)
      co     = cos(alp)
      si     = sin(alp)
      do k=1,np-1
        nwk    = nw*(k-1)
        xw   (1+nwk+nw:nw+nwk+nw) = xw(1+nwk:nw+nwk)*co - &
     &                              yw(1+nwk:nw+nwk)*si
        yw   (1+nwk+nw:nw+nwk+nw) = xw(1+nwk:nw+nwk)*si + &
     &                              yw(1+nwk:nw+nwk)*co
        zw   (1+nwk+nw:nw+nwk+nw) = zw(1+nwk:nw+nwk)
        curre(1+nwk+nw:nw+nwk+nw) = curre(1+nwk:nw+nwk)
      enddo
!     do i=1,nall
!       write(12,'(1p,4e14.4,7i4)')xw(i),yw(i),zw(i),curre(i)
!     enddo
!     stop

      return
      end subroutine readcoil_w7x
      end module coilsystem



      module surface_values
!! holds the arrays containing the function values for the surface
!! integrals. Contains the initializing function.
      use constants
      implicit none

!     interface
!       subroutine belicu (xp,yp,zp,bx,by,bz)

!       implicit none

!       real(rprec), intent(in)  :: xp,yp,zp
!       real(rprec), intent(out) :: bx,by,bz
!       end subroutine belicu
!     end interface
!     interface
!       subroutine becoil (x ,y ,z ,bx,by,bz)

!       implicit none

!       real(rprec),intent(in)  :: x ,y ,z   !cartesian coordinates
!       real(rprec),intent(out) :: bx,by,bz  !cartesian components of B
!       end subroutine becoil
!     end interface

      real(rprec), dimension(:), allocatable :: bexn,snx,sny,snz &
     &                                  ,xg,yg,zg &
     &                                  ,rg,rgu,zgu &
     &                                  ,atopx,atopy,atopz

!in case of input_form vmec2000 the axis is needed in tolicu
      real(rprec), dimension(:), allocatable :: rax, xax, yax, zax

      real(rprec) :: rav, z00max, zmidmax               !geom.of boundary
      real(rprec) :: r00min, r00max, rmidmin, rmidmax   !geom.of boundary

      contains

      subroutine initialize_surface_values
!-------------------------------------------------
! Initializes arrays for surface integrations
! based on surfaced written by H.Gardner
! ----------------------------------------------------------------------
!
!     purpose:  returns
!                    bexn = b0 dot df (the outward normal with the
!                           magnitude of the surface element) over the
!                           plasma boundary
!                    snx,sny,snz = cartesian coordinates of
!                        phi times df on the boundary
!                    xx,yy,z,xxbig,yybig,zzbig
!                          = cartesian coordinates of boundary
!                    r,ru,rv,z,zu,zv = cylindrical coordinates r,z
!                        and their derivatives w.r.t. u and v
!                    atopx,atopy,atopz = numerator in the expression
!                        for the vector potential due to the plasma
!                        currents
!
!
! ----------------------------------------------------------------------

      use constants
      use diagno_input

      implicit none

      integer :: i_alloc,i,k,ku,kv,m,n,ii1,ii2
      real(rprec) :: alp,alu,alv,alvp
      real(rprec) :: sw,cw,cop,sip
      real(rprec) :: bx,by,bz,br,bphi,xvdb0,xudb0,bxt,byt,bzt

! probably thought to be automatic arrays which won't work like that
!     real(rprec), dimension(nuv) :: bigphi,phiu,phiv,temp1, &
!    &         temp2,aax,aay,aaz,xxbig,yybig,zzbig
!     real(rprec), dimension(nuv) :: rgv,zgv    !rg,rgu,zgu already declared
!                                        !for use in barrow.
!     real, dimension(nv) :: sih,coh
!     real(rprec), dimension(0:mf,nuv) :: conu,sinu
!     real(rprec), dimension(-nf:nf,nuv) :: conv,sinv
      real(rprec), dimension(:), allocatable :: bigphi,phiu,phiv,temp1, &
     &         temp2,aax,aay,aaz,xxbig,yybig,zzbig
      real(rprec), dimension(:), allocatable :: rgv,zgv    !rg,rgu,zgu already declared
                                         !for use in barrow.
      real(rprec), dimension(:), allocatable :: sih,coh
      real(rprec), dimension(:,:), allocatable :: conu,sinu
      real(rprec), dimension(:,:), allocatable :: conv,sinv
!
!-- define constants --
!
      alp    = twopi / float(np)
      alu    = twopi / float(nu)
      alv    = twopi / float(nv)
      alvp   = twopi / float(nvp)
! allocations of locally used arrays
      allocate(bigphi(nuv),phiu(nuv),phiv(nuv),temp1(nuv), &
     &         temp2(nuv),aax(nuv),aay(nuv),aaz(nuv), &
     &         xxbig(nuv),yybig(nuv),zzbig(nuv), &
     &         rgv(nuv),zgv(nuv),sih(nv),coh(nv), &
     &         conu(0:mf,nuv),sinu(0:mf,nuv), &
     &         conv(-nf:nf,nuv),sinv(-nf:nf,nuv), &
     &         stat = i_alloc)
      if(i_alloc /= 0) &
     &  stop 'Allocation of temporary surface arrays in &
     &initialize_surface_values failed!'
!
! allocations
      allocate(bexn(nuvp),snx(nuvp),sny(nuvp),snz(nuvp) &
     &        ,xg(nuvp),yg(nuvp),zg(nuvp),rg(nuv),rgu(nuv),zgu(nuv) &
     &        ,atopx(nuvp),atopy(nuvp),atopz(nuvp) &
     &        ,stat = i_alloc)
      if(i_alloc /= 0) &
     &  stop 'Allocation of surface arrays in &
     &initialize_surface_values failed!'
!
! -- zero arrays --
!
      bigphi=0
      phiu = 0
      phiv = 0
      zg=0
      zgu=0
      zgv=0
      rg=0
      rgu=0
      rgv=0
!
! -- calculate trigonometric functions
!    (nb: nu,nv may be different here from in vacuumf) --
!
      conu(0,1:nuv) = 1
      sinu(0,1:nuv) = 0
      do m=1,mf
        do ku = 1,nu
          temp1(ku)=cos(alu*m*(ku-1))
          temp2(ku)= sin(alu*m*(ku-1))
        enddo
        do kv=1,nv
          ii1 = (kv-1)*nu+1
          ii2   = ii1+nu-1
          conu(m,ii1:ii2) = temp1(1:nu)
          sinu(m,ii1:ii2) = temp2(1:nu)
        enddo
      enddo
      conv(0,1:nuv) = 1
      sinv(0,1:nuv) = 0
      do n=1,nf
        i = 0
        do kv = 1,nv
          temp1(kv) = cos(alv*n*(kv-1))
          temp2(kv) = sin(alv*n*(kv-1))
        enddo
        do kv= 1,nv    !keep same order of nuv part w.r.to ku and kv
          ii1 = (kv-1)*nu+1
          ii2   = ii1+nu-1
          conv(n,ii1:ii2) = temp1(kv)
          sinv(n,ii1:ii2) = temp2(kv)
        enddo
        sinv(-n,1:nuv) = -sinv(n,1:nuv)
        conv(-n,1:nuv) =  conv(n,1:nuv)
      enddo
      do kv = 1,nv
        sih(kv)  = sin(alvp * (kv-1))
        coh(kv)  = cos(alvp * (kv-1))
      enddo
!-----------------------------------------------------------------------
! /* calculate the potential, phi, in real space
!                   (m=mf)  (n=nf)
!         phi = -2*   sum    sum   phi    * sin(twopi*(m*u+n*v))
!                    (m=0)  (n=-nf)   m,n
!
!         phi     = pot(m,n)   m.ge.1
!            m,n
!                 = 0.5*pot(m,n) m.eq.0
!
!   (mf,nf) are fourier coefficient ranges for the potential field */
!                           and
!  /*   calculate cylindrical coordinates and their derivatives
!
!   (ms,ns) are orig. fourier coefficient ranges for the plasma surface
!           which could be  (ms.le.mf  and ns.le.nf)    */
!   Up to now ms==mf and ns==nf had been used without problems!
!-----------------------------------------------------------------------
      do n=-nf,nf
        bigphi(1:nuv) = bigphi(1:nuv) -         pot(0,n)*sinv(n,1:nuv)
        phiv(1:nuv)   =   phiv(1:nuv) - twopi*n*pot(0,n)*conv(n,1:nuv)
        rg(1:nuv) =rg (1:nuv) +         cr(0,n)*conv(n,1:nuv)
        rgv(1:nuv)=rgv(1:nuv) - twopi*n*cr(0,n)*sinv(n,1:nuv)
        zg(1:nuv) =zg (1:nuv) +         cz(0,n)*sinv(n,1:nuv)
        zgv(1:nuv)=zgv(1:nuv) + twopi*n*cz(0,n)*conv(n,1:nuv)
        do m=1,mf
          do i = 1,nuv
            sw = sinu(m,i)*conv(n,i) &
     &                      + conu(m,i)*sinv(n,i)
            cw  = conu(m,i)*conv(n,i) &
     &                       - sinu(m,i)*sinv(n,i)
            bigphi(i) = bigphi(i) - 2*pot(m,n)*sw
            phiu(i) = phiu(i) - 2*twopi*m*pot(m,n)*cw
            phiv(i) = phiv(i) - 2*twopi*n*pot(m,n)*cw
            rg(i)  = rg (i) +         cr(m,n)*cw
            rgu(i) = rgu(i) - twopi*m*cr(m,n)*sw
            rgv(i) = rgv(i) - twopi*n*cr(m,n)*sw
            zg(i)  = zg (i) +         cz(m,n)*sw
            zgu(i) = zgu(i) + twopi*m*cz(m,n)*cw
            zgv(i) = zgv(i) + twopi*n*cz(m,n)*cw
          enddo
        enddo
      enddo
      do kv=1,nv
        do ku =1,nu
          i  = ku + nu*(kv-1)
          xg(i) = rg(i)*coh(kv)       !store cart.coord.
          yg(i) = rg(i)*sih(kv)       !store cart.coord.
        enddo
      enddo
      do k=2,np         !complete cart.coord. for belicu
        sip = sin((k-1)*alp)
        cop = cos((k-1)*alp)
        ii1 = (k-1)*nuv+1
        ii2 = k*nuv
        xg(ii1:ii2) = xg(1:nuv)*cop - yg(1:nuv)*sip
        yg(ii1:ii2) = yg(1:nuv)*cop + xg(1:nuv)*sip
        zg(ii1:ii2) = zg(1:nuv)
      enddo

!vmec2000 puts the net plasma current on the axis
      if(input_form .eq. "vmec2000")then
        allocate(rax(nvp+1),xax(nvp+1),yax(nvp+1),zax(nvp+1)&
     &          , stat=i_alloc)
        if(i_alloc /= 0) &
     &    stop 'Allocation of axis arrays in &
     &        initialize_surface_values failed!'
        rax = 0 ; xax = 0 ; yax = 0 ; zax = 0
        do kv=1,nv
          do n=0,nf
            rax(kv) = rax(kv)+raxfc(n)*conv(n,(kv-1)*nu+1)
            zax(kv) = zax(kv)+zaxfc(n)*sinv(n,(kv-1)*nu+1)
          enddo
          xax(kv) = rax(kv)*coh(kv)       !store cart.coord.
          yax(kv) = rax(kv)*sih(kv)       !store cart.coord.
        enddo
        do k=2,np         !complete cart.coord. for tolicu
          sip = sin((k-1)*alp)
          cop = cos((k-1)*alp)
          ii1 = (k-1)*nv+1
          ii2 = k*nv
          xax(ii1:ii2) = xax(1:nv)*cop - yax(1:nv)*sip
          yax(ii1:ii2) = yax(1:nv)*cop + xax(1:nv)*sip
          zax(ii1:ii2) = zax(1:nv)
        enddo
        xax(nvp+1)=xax(1)
        yax(nvp+1)=yax(1)
        zax(nvp+1)=zax(1)
      endif

      call average_radius_and_else
!
!  /* calculate components of outward normal (magnitude df) */
!
      if( ltrace_progress) write(6,*)'Calculating components of outward normal'
      temp1(1:nuv) = rgv(1:nuv)*zgu(1:nuv)-rgu(1:nuv)*zgv(1:nuv)
      temp2(1:nuv) = zgu(1:nuv)*rg(1:nuv)*alp
      snz(1:nuv) = -rgu(1:nuv) * rg(1:nuv) * alp
      do kv = 1 , nv
        ii1 = nu*(kv-1)+1
        ii2 = ii1+nu-1
        snx(ii1:ii2)= temp1(ii1:ii2)*sih(kv)+temp2(ii1:ii2)*coh(kv)
        sny(ii1:ii2)=-temp1(ii1:ii2)*coh(kv)+temp2(ii1:ii2)*sih(kv)
      enddo
!
!    /* calculate atopx,atopy,atopz : the cartesian components of the
!        numerator in expression for the vector potential due to
!        the plasma currents.
!        also calculate the components of b0 dot df. */
!           (allowing for net longitudinal current)
!
      if( ltrace_progress) write(6,*)'Calculating components of expr. in vec.pot. cal.'
      if( ltrace_progress) write(6,*)'Calling becoil quite often!'
      temp1(1:nuv) = rgu(1:nuv)*phiv(1:nuv) - rgv(1:nuv)*phiu(1:nuv)
      temp2(1:nuv) = -rg(1:nuv)*alp*phiu(1:nuv)
      aaz(1:nuv) = zgu(1:nuv)*phiv(1:nuv) - zgv(1:nuv)*phiu(1:nuv)
      if( ltrace_progress) write(6,'(3a28)')'phi=0: x           y        ' &
     &                ,'     z             Bx       ' &
     &                ,'     By            Bz       '
      do i =1,nu,nu/10
        call becoil(xg(i),yg(i),zg(i),bx,by,bz)
        if( ltrace_progress) write(6,'(1p,6e14.5)')xg(i),yg(i),zg(i),bx,by,bz
      enddo
      do kv=1,nv
        do ku =1,nu
          i  = ku + nu*(kv-1)
          call becoil(xg(i),yg(i),zg(i),bx,by,bz)
!         call belicu(xg(i),yg(i),zg(i),bxt,byt,bzt)
          bxt = tor_cur*bxt
          byt = tor_cur*byt
          bzt = tor_cur*bzt
          bx     = bx + bxt
          by     = by + byt
          bz     = bz + bzt
          br = bx*coh(kv) + by*sih(kv)
          bphi = -bx*sih(kv) + by*coh(kv)
          bexn(i) = snx(i)*bx + sny(i)*by + snz(i)*bz
          xvdb0 = rgv(i)*br + rg(i)*alp*bphi + zgv(i)*bz
          xudb0 = rgu(i)*br + zgu(i)*bz
          temp1(i) = temp1(i) + xvdb0*rgu(i) - xudb0*rgv(i)
          temp2(i) = temp2(i)               - xudb0*rg(i)*alp
          aaz(i) = aaz(i) + xvdb0*zgu(i) - xudb0*zgv(i)
        enddo
      enddo
      do kv = 1,nv
        ii1 = nu*(kv -1) + 1
        ii2 = ii1+nu-1
        aax(ii1:ii2)=temp1(ii1:ii2)*coh(kv)-temp2(ii1:ii2)*sih(kv)
        aay(ii1:ii2)=temp1(ii1:ii2)*sih(kv)+temp2(ii1:ii2)*coh(kv)
      enddo
!      /* multiply components of the normal by the potential
!         (for use in bpoly)  */
      snx(1:nuv) = snx(1:nuv) * bigphi(1:nuv)
      sny(1:nuv) = sny(1:nuv) * bigphi(1:nuv)
      snz(1:nuv) = snz(1:nuv) * bigphi(1:nuv)
!
!     /* complete calculation of atopx,y,z over the entire plasma */
!        as well as xg,yg,zg and snx,sny,snz and bexn.
!
      if( ltrace_progress) write(6,*)'Finishing calculation and extending over whole',&
     & ' plasma boundary!'
      do k=1,np
         sip = sin((k-1)*alp)
         cop = cos((k-1)*alp)
         ii1 = (k-1)*nuv+1
         ii2 = k*nuv
         atopx(ii1:ii2) = aax(1:nuv)*cop - aay(1:nuv)*sip
         atopy(ii1:ii2) = aay(1:nuv)*cop + aax(1:nuv)*sip
         atopz(ii1:ii2) = aaz(1:nuv)
      enddo
      do k=2,np
         sip = sin((k-1)*alp)
         cop = cos((k-1)*alp)
         ii1 = (k-1)*nuv+1
         ii2 = k*nuv
         snx(ii1:ii2) = snx(1:nuv)*cop - sny(1:nuv)*sip
         sny(ii1:ii2) = sny(1:nuv)*cop + snx(1:nuv)*sip
         snz(ii1:ii2) = snz(1:nuv)
         xg(ii1:ii2) = xg(1:nuv)*cop - yg(1:nuv)*sip
         yg(ii1:ii2) = yg(1:nuv)*cop + xg(1:nuv)*sip
         zg(ii1:ii2) = zg(1:nuv)
         bexn(ii1:ii2) = bexn(1:nuv)
      enddo

      if( ltrace_progress) write(6,*)'Freeing local allocations in surface values!'
      deallocate(bigphi,phiu,phiv,temp1, &
     &         temp2,aax,aay,aaz, &
     &         xxbig,yybig,zzbig, &
     &         rgv,rgu,sih,coh, &
     &         conu,sinu, &
     &         conv,sinv, &
     &         stat = i_alloc)
      if(idiag(8) ==1) call write_plasma_surface

      if( ltrace_progress) write(6,*)'Initializing surface values finished!'

      end subroutine initialize_surface_values
!-------------------------------------------------
      subroutine write_plasma_surface

      use constants
      use diagno_input


      implicit none

      integer :: i,j,k,is

      open(unit=11,file='plasma_surface.geom',status='unknown' &
     &    ,action='write')

!     do k=1,np
      do k=1,1
        do j=1,nv
          do i=1,nu
            is=(k-1)*nuv +(j-1)*nu+i
            write(11,'(3i4,1p,10e14.5)')k,j,i,xg(is),yg(is),zg(is)&
     &              ,snx(is),sny(is),snz(is),bexn(is) &
     &              ,atopx(is),atopy(is),atopz(is)
            if(is > nuvp)then
              write(6,*)'k,j,i,is:',k,j,i,is
              stop 'Alert is>nuvp!'
            endif
          enddo
          write(11,'(3a)') '###'
        enddo
      enddo

      close(unit=11)

      if(input_form .eq. "vmec2000")then
        open(unit=11,file='plasma_axis.geom',status='unknown' &
     &    ,action='write')

        do j=1,nvp+1
          write(11,'(i4,1p,3e14.5)')j,xax(j),yax(j),zax(j)
        enddo

        close(unit=11)
      endif
      stop 'Stop in write_plasma_surface'
      end subroutine write_plasma_surface
!-------------------------------------------------
      subroutine average_radius_and_else

      use constants
      use diagno_input

      implicit none

      integer :: ii1, ii2, j, k, m
!
!     /* find max. and min. r value at phi =  0 degrees  */
!
      ii1= 1
      ii2= nu
      if(ii2 > nuvp) stop 'Emergency stop : ii2 > nuv!!!'
      r00max = maxval(rg(ii1:ii2))
      r00min = minval(rg(ii1:ii2))
      if( ltrace_progress) then
         write(6,'(a25,1pe12.4)') ' rmin at phi= 0 degrees= ',r00min
         write(6,'(a25,1pe12.4)') ' rmax at phi= 0 degrees= ',r00max
      endif
      write(3,'(a25,1pe12.4)') ' rmin at phi= 0 degrees= ',r00min
      write(3,'(a25,1pe12.4)') ' rmax at phi= 0 degrees= ',r00max
!
!     /* find maximum z value at phi =  0 degrees  */
!
      ii1= 1
      ii2= nu
      if(ii2 > nuvp) stop 'Emergency stop : ii2 > nuv!!!'
      z00max = maxval(zg(ii1:ii2))
      if( ltrace_progress) write(6,'(a25,1pe12.4)') ' zmax at phi= 0 degrees= ',z00max
      write(3,'(a25,1pe12.4)') ' zmax at phi= 0 degrees= ',z00max
!
!     /* find max. and min. r value at phi = 36 degrees  */
!
      ii1= nv/2*nu + 1
      ii2= (nv/2 + 1)*nu
      if(ii2 > nuvp) stop 'Emergency stop : ii2 > nuv!!!'
      rmidmax = maxval(rg(ii1:ii2))
      rmidmin = minval(rg(ii1:ii2))
      if( ltrace_progress) then
         write(6,'(a25,1pe12.4)') ' rmin at phi=36 degrees= ',rmidmin
         write(6,'(a25,1pe12.4)') ' rmax at phi=36 degrees= ',rmidmax
      endif

      write(3,'(a25,1pe12.4)') ' rmin at phi=36 degrees= ',rmidmin
      write(3,'(a25,1pe12.4)') ' rmax at phi=36 degrees= ',rmidmax
!
!     /* find maximum z value at phi = 36 degrees (midplane) */
!
      ii1=nv/2*nu + 1
      ii2= (nv/2 + 1)*nu
      if(ii2 > nuvp) stop 'Emergency stop : ii2 > nuv!!!'
      zmidmax = maxval(zg(ii1:ii2))
      if( ltrace_progress) write(6,'(a25,1pe12.4)') ' zmax at phi=36 degrees= ',zmidmax
      write(3,'(a25,1pe12.4)') ' zmax at phi=36 degrees= ',zmidmax
!
!  calculate average minor radius using the Fourier coefficients
!
      rav = 0
      do m = 1,mf
        do j = -nf,nf
          do k = -nf,nf
            rav=rav+m*cr(m,k)*cz(m,j)*(1+(-1)**(k-j))
          enddo
        enddo
      enddo
      rav = sqrt(rav/2)
      write(3,'(a6,1p,e12.5,a1)') ' rav= ',rav,'m'
      if( ltrace_progress) write(6,'(a6,1p,e12.5,a1)') ' rav= ',rav,'m'
      return
      end subroutine average_radius_and_else
!-------------------------------------------------

      end module surface_values
EOF

cat > vdiagno.f << "EOF"
      program diagno
!***********************************************************************
!***********************************************************************
!! The program calculates coil responses using results from the vmec code
!! @author H.Gardener, Joachim Geiger
!! @version 1.0
!***********************************************************************
!***********************************************************************
!
!    /* when called by vmec this calculates the response of
!   the flux loops and poloidal beta coils on wviias */
!
      use constants
      use diagno_input
      use coilsystem
      use surface_values

      implicit none
      integer numargs
      character(150) :: arg1


!     character(10) :: machine_string = 'W7-AS'
!     character(10) :: machine_string = 'W7-X'


      id_string = ''
      CALL GETCARG(1, arg1, numargs)                        ! MCZ
      if (numargs .gt. 0) then
         id_string = trim(arg1)                             ! MCZ

      else
         write(6,*)'Usage: xdiagno data_extension'
         write(6,*)'Data set identification string :'
         read(5,*) id_string
      endif

! read control information

      call read_control_input

! read vmec/nemec output

      call read_input

!           /* read in external coil coordinates */
      call readcoil(machine_string)

      if( ltrace_progress) write(6,*)'Calling initialize_surface_values!'

      call initialize_surface_values

      if( ltrace_progress) write(6,*)'Before diagnostics!'

      if (idiag(4)==1 .or. idiag(5)==1 .or. idiag(7)==1 .or.      &
     &    idiag(9)==1) call bthdiag

      if (idiag(6)==1) call fluxdiag

!     if (idiag(3)==1) call barrow

      end program diagno


      subroutine becoil (x ,y ,z ,bx,by,bz)
!***********************************************************************
!! The subroutine returns the cartesian components of the magnetic field
!! at a point given its cartesian coordinates. The calcuation is done
!! using Biot-Savart or other supplied methods.
!***********************************************************************

      use constants
      use coilsystem

      implicit none

      real(rprec),intent(in)  :: x ,y ,z   !cartesian coordinates
      real(rprec),intent(out) :: bx,by,bz  !cartesian components of B

      real(rprec) :: vertbx,vertby,vertbz,brhos,bzets,brho,bzet,rho
      integer :: i

      bx=0;by=0;bz=0
      call biot_savart(x,y,z,bx,by,bz)
      if(ivertb.eq.0)then
        vertbx = 0
        vertby = 0
        vertbz = deltbz
      elseif (ivertb.eq.1)then
        brhos = 0
        bzets = 0
        do i=1,nc_vert
          rho = sqrt(x**2+y**2)
          call bvert(brho,bzet,rho,z,r_v(i),z_v(i))
          brhos = brhos + brho*f_v(i)
          bzets = bzets + bzet*f_v(i)
        enddo
        vertbx = current(4)*brhos*x/sqrt(x**2+y**2)
        vertby = current(4)*brhos*y/sqrt(x**2+y**2)
        vertbz = current(4)*bzets
      else
        write(6,*)'ivertb = ',ivertb,'! value undefined!'
        stop
      endif

      bx = bx+vertbx
      by = by+vertby
      bz = bz+vertbz

      contains

      subroutine biot_savart(x,y,z,bx,by,bz)
!! Evaluates Biot-Savart.

      use constants
      implicit none

      real(rprec),intent(in)  :: x,y,z     !cartesian coordinates
      real(rprec),intent(out) :: bx,by,bz  !cartesian components of B
      real(rprec), dimension(ntopo) :: x1,y1,z1,rw,fa
      real(rprec) :: ax,ay,az
      integer :: i_alloc
      real(rprec), dimension(:), allocatable, save :: vx,vy,vz,dx,dy,dz
      real(rprec), save :: fac
      integer, save :: i_call = 0

      if(i_call == 0) then
         fac   =  1.e-7_rprec        !if currents in A then B is in T.
         allocate(vx(nall),vy(nall),vz(nall),dx(nall),dy(nall),dz(nall),&
     &           stat = i_alloc)
         if(i_alloc /= 0) stop 'Allocation of arrays biot_savart failed!'

         dx=0;dy=0;dz=0;vx=0;vy=0;vz=0

         dx(1:nall-1) = (xw(2:nall)-xw(1:nall-1))*curre(1:nall-1)
         dy(1:nall-1) = (yw(2:nall)-yw(1:nall-1))*curre(1:nall-1)
         dz(1:nall-1) = (zw(2:nall)-zw(1:nall-1))*curre(1:nall-1)
         vx(1:nall-1) = &
     &         yw(1:nall-1)*dz(1:nall-1)-zw(1:nall-1)*dy(1:nall-1)
         vy(1:nall-1) = &
     &         zw(1:nall-1)*dx(1:nall-1)-xw(1:nall-1)*dz(1:nall-1)
         vz(1:nall-1) = &
     &         xw(1:nall-1)*dy(1:nall-1)-yw(1:nall-1)*dx(1:nall-1)
      endif

      x1(1:nall)  = x - xw(1:nall)
      y1(1:nall)  = y - yw(1:nall)
      z1(1:nall)  = z - zw(1:nall)
      rw(1:nall)  = &
     &       sqrt(x1(1:nall)**2+y1(1:nall)**2+z1(1:nall)**2)

      fa(1:nall-1)  = (rw(2:nall)+rw(1:nall-1))/ &
     &           (rw(2:nall)*rw(1:nall-1)*( &
     &             rw(2:nall)*rw(1:nall-1) +x1(2:nall)*x1(1:nall-1) &
     &            +y1(2:nall)*y1(1:nall-1) +z1(2:nall)*z1(1:nall-1)))

      ax = sum(fa(1:nall-1)*dx(1:nall-1))
      ay = sum(fa(1:nall-1)*dy(1:nall-1))
      az = sum(fa(1:nall-1)*dz(1:nall-1))

      bx = fac*(sum(fa(1:nall-1)*vx(1:nall-1)) -y*az+z*ay)
      by = fac*(sum(fa(1:nall-1)*vy(1:nall-1)) -z*ax+x*az)
      bz = fac*(sum(fa(1:nall-1)*vz(1:nall-1)) -x*ay+y*ax)

!     if(i_call == 0) write(6,*) &
!    &  '      x           y           z     ' &
!    & ,'     bx          by          bz     '
      if(i_call < 10) then
!       write(6,'(1p,6e12.4)') x,y,z,bx ,by ,bz
        i_call=i_call+1
      endif

      end subroutine biot_savart

      subroutine bvert(brho,bzet,rho,zp,ra,z0)
!***********************************************************************
! calculation of vertical field by elliptical integrals
! using the polynomial approximations given in abramowitz pp.591 ,
! which has an error of less than 2*e-08 .
! the returned values are those of a field in tesla generated
! by a current of magnitude muo/4*pi in a.
!***********************************************************************

      use constants
      implicit none
      real(rprec), intent(in) :: rho,zp,ra,z0
      real(rprec), intent(out) :: brho,bzet
      real(rprec) :: arz,amrz,xm,are,ark
      integer ifail

      ifail = 0
      arz = (rho+ra)**2 +(zp-z0)**2
      amrz = (rho-ra)**2 +(zp-z0)**2
      xm = 4*ra*rho/arz

      are = eie(xm)
      ark = eik(xm)

      brho = (zp-z0)*2.e-7_rprec/rho/sqrt(arz)  !gives T for a current of 1 A
      brho = brho*(-ark+ &
     &       (rho**2+ra**2+(zp-z0)**2)*are/amrz)

      bzet =  2.e-7_rprec/sqrt(arz)             !gives T for a current of 1 A
      bzet = bzet*(ark+ &
     &       (ra**2-rho**2-(zp-z0)**2)*are/amrz)

      return
      end subroutine bvert

      real(rprec) function eik(x)
!***********************************************************************
!! Approxiamtion of complete Elliptical Integral K
!! Reference: Abramowitz
!***********************************************************************

      use constants
      implicit none
      real(rprec), intent(in) :: x
      real(rprec) :: omx

      real(rprec), dimension(5) :: &
     &     a=(/1.38629436112_rprec, .09666344259_rprec, .03590092383_rprec, &
     &         .03742563713_rprec, .01451196212_rprec/), &
     &     b=(/ .50000000000_rprec, .12498593597_rprec, .06880248576_rprec, &
     &         .03328355346_rprec , .00441787012_rprec/)

      if(x.ge.1) then
        print * ,'eik : x.ge.1 :',x
        stop
      endif
      if(x.lt.0) then
        print * ,'eik : x.lt.1 :',x
        stop
      endif

      omx = 1 - x

      eik = b(1)+omx*(b(2)+omx*(b(3)+omx*(b(4)+omx*b(5))))
      eik = eik*log(1/omx)
      eik = eik +a(1)+omx*(a(2)+omx*(a(3)+omx*(a(4)+omx*a(5))))

      return
      end function eik

      real(rprec) function eie(x)
!***********************************************************************
!! Approxiamtion of complete Elliptical Integral E
!! Reference: Abramowitz
!***********************************************************************

      use constants
      implicit none
      real(rprec), intent(in) :: x
      real(rprec) :: omx

      real(rprec), dimension(5) :: &
     &     a=(/1.00000000000_rprec, .44325141463_rprec, .06260601220_rprec, &
     &         .04757383546_rprec, .01736506451_rprec/), &
     &     b=(/ .0000000000_rprec, .24998368310_rprec, .09200180037_rprec, &
     &         .04069697526_rprec , .00526449639_rprec/)

      if(x.ge.1) then
        print * ,'eie : x.ge.1 :',x
        stop
      endif
      if(x.lt.0) then
        print * ,'eie : x.lt.1 :',x
        stop
      endif

      omx = 1 - x

      eie = b(1)+omx*(b(2)+omx*(b(3)+omx*(b(4)+omx*b(5))))
      eie = eie*log(1/omx)
      eie = eie +a(1)+omx*(a(2)+omx*(a(3)+omx*(a(4)+omx*a(5))))

      return
      end function eie

      end subroutine becoil

      subroutine belicu (xp,yp,zp,bx,by,bz)
!! Returns the cartesian components of the magnetic field at a
!! given point specified by its cartesian coordinates. The field
!! originates from a line current specified by subroutin tolicu.

      use constants
      use diagno_input
      implicit none

      real(rprec), intent(in)  :: xp,yp,zp
      real(rprec), intent(out) :: bx,by,bz
      real(rprec), dimension(:), allocatable, save :: &
     &     xcw,ycw,zcw,dx,dy,dz,vx,vy,vz
      integer :: i_alloc
      integer, save :: ibelicu = 0 
      real(rprec), dimension(nvp+1) :: x1,y1,z1,rw,fa,r12
      real(rprec) :: ax,ay,az
      real(rprec), save :: fac

      if(ibelicu == 0) then
        fac = 1.e-7_rprec        !if current is in A, B will be in T
        call tolicu
        allocate(dx(nvp+1),dy(nvp+1),dz(nvp+1) &
     &          ,vx(nvp+1),vy(nvp+1),vz(nvp+1) &
     &          ,stat = i_alloc)
        if(i_alloc /= 0) stop 'Allocation in tolicu failed!'

        dx=0;dy=0;dz=0;vx=0;vy=0;vz=0

        dx(1:nvp) = (xcw(2:nvp+1)-xcw(1:nvp))
        dy(1:nvp) = (ycw(2:nvp+1)-ycw(1:nvp))
        dz(1:nvp) = (zcw(2:nvp+1)-zcw(1:nvp))
        vx(1:nvp) =  ycw(1:nvp)*dz(1:nvp)-zcw(1:nvp)*dy(1:nvp)
        vy(1:nvp) =  zcw(1:nvp)*dx(1:nvp)-xcw(1:nvp)*dz(1:nvp)
        vz(1:nvp) =  xcw(1:nvp)*dy(1:nvp)-ycw(1:nvp)*dx(1:nvp)
        ibelicu = 1
      endif
      x1  = xp - xcw
      y1  = yp - ycw
      z1  = zp - zcw
      rw  = sqrt(x1**2+y1**2+z1**2)

      r12(1:nvp) = rw(2:nvp+1)*rw(1:nvp)
      fa(1:nvp) = (rw(2:nvp+1)+rw(1:nvp))/ &
     &   (r12(1:nvp)*(r12(1:nvp) + &
     &           x1(2:nvp+1)*x1(1:nvp)+y1(2:nvp+1)*y1(1:nvp) &
     &          +z1(2:nvp+1)*z1(1:nvp)))

      ax = sum(fa(1:nvp)*dx(1:nvp))
      ay = sum(fa(1:nvp)*dy(1:nvp))
      az = sum(fa(1:nvp)*dz(1:nvp))

      bx = fac*(sum(fa(1:nvp)*vx(1:nvp)) -yp*az+zp*ay)
      by = fac*(sum(fa(1:nvp)*vy(1:nvp)) -zp*ax+xp*az)
      bz = fac*(sum(fa(1:nvp)*vz(1:nvp)) -xp*ay+yp*ax)

!----------------------------------------------------------
      contains

      subroutine tolicu
!! specifies the geometry of the line current carrying the net plasma
!! current.

      use surface_values

      implicit none

      integer :: nuh,i,l,i_alloc

      allocate(xcw(nvp+1),ycw(nvp+1),zcw(nvp+1) &
     &      ,stat = i_alloc)
      if(i_alloc /= 0) stop 'Allocation in tolicu failed!'

      select case (input_form)
      case ("vmec2000")
        xcw = xax
        ycw = yax
        zcw = zax
      case default
        nuh    = nu/2
        i      = 0
        do l=1,nuvp,nu
          i      = i + 1
          xcw(i)  = (xg(l)+xg(l+nuh))/2
          ycw(i)  = (yg(l)+yg(l+nuh))/2
          zcw(i)  = (zg(l)+zg(l+nuh))/2
!         write(19,'(1p,9e14.5)') xcw(i),ycw(i),zcw(i) &
!    &      ,xg(l),xg(l+nuh),yg(l),yg(l+nuh),zg(l),zg(l+nuh)
        enddo
        xcw(nvp+1) = xcw(1)
        ycw(nvp+1) = ycw(1)
        zcw(nvp+1) = zcw(1)
      end select

      end subroutine tolicu

      end subroutine belicu

      subroutine bpoly(xp,yp,zp,bx,by,bz)
!***********************************************************************
!! returns the cartesian components of the magnetic field at a
!! point specified by its cartesian coordinates by performing
!! the surface integrals and adding the field due to a net current
!! (calculated by subroutine belicu).
!***********************************************************************


      use constants
      use surface_values
      use diagno_input

      implicit none

      real(rprec), intent(in)  :: xp,yp,zp
      real(rprec), intent(out) :: bx,by,bz
      real(rprec) :: fac,bxt,byt,bzt
      real(rprec), allocatable, dimension(:) :: an1,an2,an3,  &
     &             temp,temp1
!      real(rprec), dimension(nuvp) :: an1,an2,an3,temp,temp1

      allocate (an1(nuvp), an2(nuvp), an3(nuvp), temp(nuvp), temp1(nuvp))

      fac    = 1/(2*twopi*nuv)
      bx     = 0
      by     = 0
      bz     = 0
!
!     !* integrate over all periods of the toroidal surface */
!
      an1 = 1/sqrt((xp-xg)**2+(yp-yg)**2+(zp-zg)**2)
      an2 = an1**2
      an3 = an1**3
      temp = (xp-xg)*snx+(yp-yg)*sny+(zp-zg)*snz
      temp1= bexn+3*an2*temp

      bx = sum(((xp-xg)*temp1-snx)*an3)
      by = sum(((yp-yg)*temp1-sny)*an3)
      bz = sum(((zp-zg)*temp1-snz)*an3)

      deallocate (an1, an2, an3, temp, temp1)

      bx = -bx*fac
      by = -by*fac
      bz = -bz*fac

      call belicu(xp,yp,zp,bxt,byt,bzt)

      bxt = tor_cur*bxt
      byt = tor_cur*byt
      bzt = tor_cur*bzt

      bx = bx + bxt
      by = by + byt
      bz = bz + bzt

      end subroutine bpoly

      subroutine bthdiag
!***********************************************************************
!! Calculates the magnetic field response due to the plasma based on the
!! precalculated surface functions. Performs different tasks at the
!! moment and is currently a spaghetti-like code.
!***********************************************************************

      use constants
      use diagno_input
      use surface_values

      implicit none

      integer :: i,j,k,ncoils,i_alloc,nseg,npts, istat
      real(rprec), dimension(:), allocatable :: x_c,y_c,z_c,th_inc &
     &       ,phi_inc,eff_area,b_c,b_n,flux
      real(rprec), dimension(:), allocatable :: r_c2th,z_c2th,phi_c2th &
     &      ,x_c2th,y_c2th,wa_c2th,flux_c2th,bint
      integer :: nseg_c2th,npts_c2th
      real(rprec) :: xp,yp,zp,bx,by,bz,br,bphi,dx,dy,dz,wa
      character(80) :: seg_coil_name
      character(5) :: action
!----- temporary -------------------------
      real(rprec) :: bl,dl
!-----------------------------------------

      if( ltrace_progress) write(6,*) ' Start of bthdiag!'
!
!    /* read in br, br and bphi field coils */
!
      if( idiag(4)==1 ) then
        if( ltrace_progress) write(6,*)'Read in dataset of field coils'
        open(unit=11,file=trim(bprobes_file),status='old' &
     &      ,action='read',iostat=istat)
        if (istat .eq. 0) then
          read(11,*)ncoils
          allocate(x_c(ncoils),y_c(ncoils),z_c(ncoils) &
     &       ,th_inc(ncoils),phi_inc(ncoils),eff_area(ncoils) &
     &       ,b_c(ncoils), b_n(ncoils), flux(ncoils) &
     &       , stat = i_alloc)
          if(i_alloc /= 0) stop 'Allocation 1 in bthdiag failed!'
          do j=1,ncoils
            read(11,*)x_c(j),y_c(j),z_c(j) &
     &            ,th_inc(j),phi_inc(j),eff_area(j)
          enddo
          th_inc = th_inc*onerad
          phi_inc = phi_inc*onerad
          close(unit=11)
          if( ltrace_progress) write(6,*)&
     &      '#nc       x/m           y/m           z/m    ' &
     &     ,'       B/T          flux/Wb '
          do j=1,ncoils
            xp = x_c(j)
            yp = y_c(j)
            zp = z_c(j)
            call bpoly(xp,yp,zp,bx,by,bz)
            br =(xp*bx+yp*by)/sqrt(xp*xp+yp*yp)
            bphi =(-yp*bx+xp*by)/sqrt(xp*xp+yp*yp)
            b_c(j) = br*cos(th_inc(j)) + bz*sin(th_inc(j))
            b_n(j) = br*sin(th_inc(j)) - bz*cos(th_inc(j))
            flux(j) = eff_area(j)*b_c(j)
            if( ltrace_progress) write(6,'(i3,1p,10e14.4)') &
     &          j,x_c(j),y_c(j),z_c(j) &
     &         ,b_c(j),flux(j)
          enddo
          open(unit=11,file='diagno_bth.'//id_string,status='unknown' &
     &        ,action='write')
          write(11,'(i6,1p,6e14.6)')(i,x_c(i),y_c(i),z_c(i) &
     &          ,b_c(i),b_n(i),flux(i),i=1,ncoils)
          close(unit=11)
          deallocate(x_c,y_c,z_c,th_inc,phi_inc,eff_area,b_c,flux &
     &             , stat = i_alloc)
          if(i_alloc /= 0) stop 'Deallocation 1 in bthdiag failed!'

        else
          stop 'Failed to open B-probes definition file'
        endif
      endif

      if( idiag(9) == 1) then
        if( ltrace_progress) write(6,*)'Read in dataset of field coils in MIR-1'
        open(unit=11,file=trim(mir1_file),status='old' &
     &      ,action='read',iostat=istat)
        if (istat .eq. 0) then
          read(11,*)ncoils
          allocate(x_c(ncoils),y_c(ncoils),z_c(ncoils) &
     &         ,th_inc(ncoils),phi_inc(ncoils),eff_area(ncoils) &
     &         ,b_c(ncoils), flux(ncoils) &
     &         , stat = i_alloc)
          if(i_alloc /= 0) stop 'Allocation 1 in bthdiag failed!'
          do j=1,ncoils
            read(11,*)x_c(j),y_c(j),z_c(j) &
     &            ,th_inc(j),phi_inc(j),eff_area(j)
          enddo
          th_inc = th_inc*onerad
          phi_inc = phi_inc*onerad
          close(unit=11)
          if( ltrace_progress) write(6,*)&
     &      '#nc       x/m           y/m           z/m    ' &
     &     ,'       B/T          flux/Wb '
          do j=1,ncoils
            xp = x_c(j)
            yp = y_c(j)
            zp = z_c(j)
            call bpoly(xp,yp,zp,bx,by,bz)
!       call becoil(xp,yp,zp,bx,by,bz)
!       call belicu(xp,yp,zp,bx,by,bz)       !is called in bpoly
            br =(xp*bx+yp*by)/sqrt(xp*xp+yp*yp)
            bphi =(-yp*bx+xp*by)/sqrt(xp*xp+yp*yp)
          b_c(j) = br*cos(th_inc(j)) + bz*sin(th_inc(j))
!       b_c(j) = br*cos(th_inc(j))*cos(phi_inc(j)) &
!    &         + bphi*cos(th_inc(j))*sin(phi_inc(j)) &
!    &         + bz*sin(th_inc(j))
            flux(j) = eff_area(j)*b_c(j)
            if( ltrace_progress) write(6,'(i3,1p,10e14.4)') &
     &          j,x_c(j),y_c(j),z_c(j) &
     &         ,b_c(j),flux(j)
          enddo
          open(unit=11,file='diagno_mir1.'//id_string,status='unknown' &
     &      ,action='write')
          write(11,'(1p,30e14.5)')(flux(i),i=1,ncoils)
          close(unit=11)
          deallocate(x_c,y_c,z_c,th_inc,phi_inc,eff_area,b_c,flux &
     &             , stat = i_alloc)
          if(i_alloc /= 0) stop 'Deallocation 1 in bthdiag failed!'
        else
          stop 'Failed to open Mir1 definition file'
        endif
      endif

      if( idiag(5)==1 ) then
        seg_coil_name = "cos2theta"
        action = "read"
        call seg_coil(seg_coil_name, action, istat)

        if( istat == 0 ) then
          nseg=nseg_c2th
          npts=npts_c2th
          if( ltrace_progress) write(6,*)nseg,' Segments for segmented coil!'
          if( ltrace_progress) write(6,*)npts,' Points for each coil segment!'
          allocate(bint(nseg), stat = i_alloc)
          if(i_alloc /= 0) stop 'Allocation of bint in bthdiag failed!'
          bint = 0
          do i=1,nseg
            k=(i-1)*npts+1
            do j=1,npts-1
              xp=(x_c2th(k+1)+x_c2th(k))/2
              yp=(y_c2th(k+1)+y_c2th(k))/2
              zp=(z_c2th(k+1)+z_c2th(k))/2
              wa=(wa_c2th(k+1)+wa_c2th(k))/2
              dx=    (x_c2th(k+1)-x_c2th(k))*wa
              dy=    (y_c2th(k+1)-y_c2th(k))*wa
              dz=    (z_c2th(k+1)-z_c2th(k))*wa
              call bpoly(xp,yp,zp,bx,by,bz)
!         call becoil(xp,yp,zp,bx,by,bz)
!         call belicu(xp,yp,zp,bx,by,bz)       !is called in bpoly
              dl = sqrt(dx**2+dy**2+dz**2)
              bl = (bx*dx + by*dy + bz*dz)
              bint(i) = bint(i)+bx*dx + by*dy + bz*dz
!!            write(6,'(a45,i5,1p,4e14.5)') &
!!     &           'k , vecb*vecdl/dl , |vecdl| , wa , vecb*vecdl' &
!!     &           ,k,bl/dl,dl/wa,wa,bl
              k=k+1
            enddo
          enddo

          if( ltrace_progress) then
             write(6,*)'Cos2theta Coil:'
             write(6,*)'#Flux in Wb of Coil  1 to ',nseg,' :'
             write(6,'(1p,30e14.5)')(bint(i),i=1,nseg)
             write(6,*)'Sum of fluxes : ',sum(bint),' Wb'
          endif

          if(idiag(51)==1) call write_Cos2th_database_w7as(nseg,bint)

          bint(:nseg) = bint(:nseg) * seg_rog_turns(:nseg)     ! scale appropriately

          open(unit=11,file='diagno_seg.'//id_string,status='unknown' &
     &        ,action='write')
          write(11,'(1p,30e14.5)')(bint(i),i=1,nseg)
          do i=1, nseg
             if( i < 10) then
                write(11,'(a,i1)') ' seg',i
             else if (i<100) then
                write(11,'(a,i2)') ' seg',i
             else 
                write(11,'(a,i3)') ' seg',i
             endif          
          enddo

          close(unit=11)
          call seg_coil(seg_coil_name,"close", istat)

          deallocate(bint, stat = i_alloc)
          if(i_alloc /= 0) write(6,*) 'Deallocation of bint in bthdiag failed!'

        else
          stop  'Failure reading segmented-rogowski definition file'
        endif
      endif

      if(idiag(7)==1)then
        if( ltrace_progress) write(6,*)'Read in dataset for testpoints'
        open(unit=11,file=trim(bfield_points_file),status='old' &
     &    ,action='read', iostat=istat)
        if( istat /= 0) stop 'Failure reading b-field point definnition file'

        read(11,*)ncoils
        if( ltrace_progress) then
           write(6,*)ncoils,' test points from file bfield_points.data'
           write(6,'(a3,6a14)') ' No','      x       ','      y       ' &
     &      ,'      z       ','      Br      ' &
     &      ,'      Bphi    ','      Bz      '
        endif
        do j=1,ncoils
          read(11,*)xp,yp,zp
          call bpoly(xp,yp,zp,bx,by,bz)
!         call becoil(xp,yp,zp,bx,by,bz)
!         call belicu(xp,yp,zp,bx,by,bz)       !is called in bpoly
          br =(xp*bx+yp*by)/sqrt(xp*xp+yp*yp)
          bphi =(-yp*bx+xp*by)/sqrt(xp*xp+yp*yp)
          if( ltrace_progress) write(6,'(i3,1p,6e14.5)') &
     &        j,xp,yp,zp,br,bphi,bz
        enddo
        close(unit=11)
      endif

      contains

      subroutine seg_coil(coil_name,action, istat)
!! Handle different segmented Rogowski coils.

      implicit none
      character(80), intent(in) :: coil_name
      character(5), intent(in) :: action
      integer istat

      select case(coil_name)
        case ("cos2theta")
          if( ltrace_progress) write(6,*)'Read data of Coil:',coil_name
          call cos2theta_coord(action, istat)

        case default
          write(6,*)'Coil name ',coil_name,' unknown!'
          stop 'Check coil_name in bthdiag!'
      end select

      end subroutine seg_coil

      subroutine cos2theta_coord(action, istat)
!! Read the coordinates of the Cosine-2-Theta Coil

      implicit none
      character(5), intent(in) :: action
      integer :: j,n, istat

      select case(action)
        case("read")
          open(unit=10,file=trim(seg_rog_file)         &
     &    ,status='unknown',action='read',iostat=istat)
          if( istat /= 0) return

          read(10,*)nseg_c2th,npts_c2th
          n = nseg_c2th*npts_c2th
          allocate(r_c2th(n),z_c2th(n) &
     &      ,phi_c2th(n),wa_c2th(n) &
     &      ,x_c2th(n),y_c2th(n) &
     &      ,flux_c2th(n) &
     &    ,stat=i_alloc)
          if(i_alloc /= 0) &
     &        stop 'Allocation failed in read_cos2theta_coord!'
          read(10,*)(r_c2th(j),z_c2th(j),phi_c2th(j) &
     &              ,wa_c2th(j),j=1,n)
          close(unit=10)
          x_c2th=r_c2th*cos(onerad*phi_c2th)
          y_c2th=r_c2th*sin(onerad*phi_c2th)
        case("close")
          deallocate(r_c2th,z_c2th,phi_c2th,wa_c2th &
     &              ,x_c2th,y_c2th,flux_c2th &
     &              ,stat=i_alloc)
          if(i_alloc /= 0) &
     &        write(6,*) 'Deallocation failed in read_cos2theta_coord!'
        case default
          write(6,*)'Action ',action,' unknown!'
          stop 'Check requested action in bthdiag!'
      end select

      end subroutine cos2theta_coord
!
! Internal subroutine
!
      subroutine write_Cos2th_database_w7as(nseg,bint)
!! Writes results of the Cosine-2-Theta Calculations to a database
!! file : Cos2th.database_new
      use constants
      implicit none
      integer,intent(in) :: nseg
      real(rprec), dimension(nseg) :: bint
      integer :: i
      real(rprec) :: cratio,c0t,c1t,c2t,s1t

      open(unit=11,file=trim(fdb_SegRogCoils),status='old' &
     &    ,action='write',position='append')
      
      write(11,'(60a)',advance='no') id_string(1:len_trim(id_string))
      write(11,'(1pe14.5)',advance='no') current(1)
      cratio = current(2)/current(1)
      write(11,'(1pe14.5)',advance='no') cratio
      cratio = current(3)/current(1)
      write(11,'(1pe14.5)',advance='no') cratio
      cratio = current(4)/current(1)
      write(11,'(1pe14.5)',advance='no') cratio
      cratio = tor_cur/current(1)    !plasma current/I_mod
      write(11,'(1pe14.5)',advance='no') cratio
      write(11,'(1pe14.5)',advance='no') rav
      write(11,'(1p,6e14.5)',advance='no') &
     &               r00min,r00max,z00max,rmidmin,rmidmax,zmidmax
      write(11,'(1p,8e14.5)',advance='no') (bint(i),i=1,nseg)
      c0t=bint(1)+bint(2)+bint(3)+bint(4)
      c1t=bint(1)-bint(2)-bint(3)+bint(4)
      c2t=bint(1)-bint(2)+bint(3)-bint(4)
      s1t=bint(1)+bint(2)-bint(3)-bint(4)
      write(11,'(4(1pe14.5))',advance='yes') c0t,c1t,c2t,s1t
      close(unit=11)

      end subroutine write_Cos2th_database_w7as

      end subroutine bthdiag

      subroutine fluxdiag
!***********************************************************************
!* rewritten by J.Geiger, based on fluxdiag written by H.Gardener 1988**
!
!    /* calculates flux due to plasma through external diagnostic
!       coils. coil coordinates are read in from unit 10.
!          nb: loops may be closed or "open" (i.e. toroidal but
!              input over one period only). only the first end-point
!              is to be input so that the no. of points = no. of
!              segments = nseg.        h.j.g.      8.4.88   */
!
!***********************************************************************
      use constants
      use diagno_input
      use surface_values

      implicit none

      real(rprec) :: xp,yp,zp,cop,sip,sfac
!      real(rprec), dimension(nuvp) :: disinv
      real(rprec), dimension(:), allocatable :: disinv
      character(48), dimension(:), allocatable :: title
      integer, dimension(:), allocatable :: nseg_ar
      real(rprec), dimension(:), allocatable :: xfl,yfl,zfl,dx,dy,dz &
     &                                  ,xmid,ymid,zmid,flux 
      integer :: i,n,nfl,nseg,iflflg,idia,i_alloc,nsegmx

!     write(3,*)'phiedge = ',phiedge,'[Wb]'
      sfac = 1/(2*twopi*nuv)      !factor for surface integral

!
! Read number of flux loops and number of segments.
!
      open(unit=10,file=trim(flux_diag_file),status='old',action='read')

      read(10,*) nfl
      if( ltrace_progress) write(6,*) nfl,' flux loops!'

      allocate(nseg_ar(nfl), title(nfl+2), flux(nfl+2), stat=i_alloc)
      if(i_alloc /= 0) stop &
     &    'Allocation of int.array nseg_ar fluxdiag failed!'

      nseg_ar = 0
      do n = 1,nfl
!       read(10,*) &
        read(10,'(3i5,a48)') nseg_ar(n),iflflg,idia,title(n)
        if( ltrace_progress) write(6,*)nseg_ar(n),' Segments for flux loop ',n

        do i = 1,nseg_ar(n)
          read(10,*) xp,yp,zp
        enddo
      enddo

      nsegmx=maxval(nseg_ar)+1
      if( ltrace_progress) write(6,*)'Maximum number of segments+1 = ',nsegmx

      allocate(xfl(0:nsegmx),yfl(0:nsegmx),zfl(0:nsegmx), &
     &         dx(0:nsegmx),dy(0:nsegmx),dz(0:nsegmx), &
     &         xmid(nsegmx),ymid(nsegmx),zmid(nsegmx)  &
     &        ,stat=i_alloc)
      if(i_alloc /= 0) stop &
     &    'Allocation of pos.arrays xlf,yfl,zfl in fluxdiag failed!'
!
!
!
! Reread input unit to get flux loops and calculate fluxes
!
      rewind(unit=10)
      read(10,*) nfl

      sip = sin(twopi/float(np))
      cop = cos(twopi/float(np))
      idia = 0 ; iflflg = 0
      flux = 0

      do n = 1,nfl
        read(10,'(3i5,a48)') nseg,iflflg,idia,title(n)
        do i=1,nseg
          read(10,*) xfl(i),yfl(i),zfl(i)
        enddo
        xfl=xfl/100 ; yfl=yfl/100 ; zfl=zfl/100  ![cm] -> [m]
!
!        /* calculate zeroth and second end-point */
!
        if (iflflg.eq.0) then
          xfl(0) = xfl(nseg)
          yfl(0) = yfl(nseg)
          zfl(0) = zfl(nseg)
          xfl(nseg+1) = xfl(1)
          yfl(nseg+1) = yfl(1)
          zfl(nseg+1) = zfl(1)
        else
!
!           /* toroidal loop input over one period */
!
          xfl(0) = xfl(nseg)*cop + yfl(nseg)*sip
          yfl(0) = yfl(nseg)*cop - xfl(nseg)*sip
          zfl(0) = zfl(nseg)
          xfl(nseg+1) = xfl(1)*cop - yfl(1)*sip
          yfl(nseg+1) = yfl(1)*cop + xfl(1)*sip
          zfl(nseg+1) = zfl(1)
        endif
!
!        /* calculate distance of points */
!
        dx(1:nseg) = xfl(2:nseg+1) - xfl(1:nseg)
        dy(1:nseg) = yfl(2:nseg+1) - yfl(1:nseg)
        dz(1:nseg) = zfl(2:nseg+1) - zfl(1:nseg)
        if (iflflg.eq.0) then   !for poloidally closed loops
          dx(0) = dx(nseg)
          dy(0) = dy(nseg)
          dz(0) = dz(nseg)
          dx(nseg+1) = dx(1)
          dy(nseg+1) = dy(1)
          dz(nseg+1) = dz(1)
        else   !for toroidally closed loops
!
!           /* toroidal loop input over one period */
!
          dx(0) = dx(nseg)*cop + dy(nseg)*sip
          dy(0) = dy(nseg)*cop - dx(nseg)*sip
          dz(0) = dz(nseg)
          dx(nseg+1) = dx(1)*cop - dy(1)*sip
          dy(nseg+1) = dy(1)*cop + dx(1)*sip
          dz(nseg+1) = dz(1)
        endif
        xmid(1:nseg) = (xfl(1:nseg) + xfl(2:nseg+1))/2
        ymid(1:nseg) = (yfl(1:nseg) + yfl(2:nseg+1))/2
        zmid(1:nseg) = (zfl(1:nseg) + zfl(2:nseg+1))/2
!
!        /* perform line integrals */
!
        allocate (disinv(nuvp), stat = i_alloc)
        if( ltrace_progress) write(6,*)'Performing line integral using closed simpson formula ...'
        do i = 1,nseg
          xp = xfl(i)
          yp = yfl(i)
          zp = zfl(i)
          disinv(1:nuvp) = 1/sqrt((xp - xg(1:nuvp))**2 &
     &                            +(yp - yg(1:nuvp))**2 &
     &                            +(zp - zg(1:nuvp))**2)
          flux(n) = flux(n) &
     &       + (sum(atopx(1:nuvp)*disinv(1:nuvp))*(dx(i-1)+dx(i)) &
     &        + sum(atopy(1:nuvp)*disinv(1:nuvp))*(dy(i-1)+dy(i)) &
     &        + sum(atopz(1:nuvp)*disinv(1:nuvp))*(dz(i-1)+dz(i)) )/2
          xp = xmid(i)
          yp = ymid(i)
          zp = zmid(i)
          disinv(1:nuvp) = 1/sqrt((xp - xg(1:nuvp))**2 &
     &                            +(yp - yg(1:nuvp))**2 &
     &                            +(zp - zg(1:nuvp))**2)
          flux(n) = flux(n) &
     &          + 2*(sum(atopx(1:nuvp)*disinv(1:nuvp))*dx(i) &
     &             + sum(atopy(1:nuvp)*disinv(1:nuvp))*dy(i) &
     &             + sum(atopz(1:nuvp)*disinv(1:nuvp))*dz(i) )
        enddo

        deallocate (disinv)

        flux(n)=flux(n)/3
        flux(n) = sfac*flux(n)         !finish surface integral
        if (iflflg.eq.1) flux(n)=flux(n)*np

!       if (idia.eq.1) flux(n) = -flux(n) + phiedge !up to 21.2.1999
        if (idia.eq.1)then
          if( ltrace_progress) write(6,*)'flux(n),before = ',flux(n),'  phiedge = ',phiedge
          flux(n) = flux(n) - phiedge !changed sign:22.2.1999
        endif
        if( ltrace_progress) then
           write(6,'(" coil number ",i5,10x,a)') n, trim(title(n))
           write(6,'(a7,i4,8(a7,i2,a3,1p,e18.10,a3))') &
     &          ' nseg= ',nseg,'  flux(',n,')= ',flux(n),' Wb'
           write(6,'(a33,1p,e14.5)')'  Flux normalized to phiedge/2 : ' &
     &                             ,2*flux(n)/phiedge
           write(6,*) ' '
        endif
        write(3,'(" coil number ",i5,10x,6a8)') n, trim(title(n))
        write(3,'(a7,i4,8(a7,i2,a3,1p,e18.10,a3))') &
     &    ' nseg= ',nseg,'  flux(',n,')= ',flux(n),' Wb'
        write(3,'(a33,1p,e14.5)')'  Flux normalized to phiedge/2 : ' &
     &            ,2*flux(n)/phiedge
        write(3,*) ' '
      enddo
      close(unit=10)
!
! write database file, if requested
!
      if(idiag(61)==1) call write_flux_database_w7as

!
! scale fluxes by number of turns in coils
!

      flux(:nfl) = flux(:nfl) * flux_turns(:nfl)

!
! compensate diamagnetic, if requested
!
      if( idiag(60)==1 ) then
         flux(nfl+1) = sum( flux(:nfl) * dia_comp_coefs(:nfl) )
         title(nfl+1) = 'comp. diamag. loop'
         flux_comb_coefs(nfl+1) = 0
         nfl = nfl + 1
      endif
!
! make linear combination of flux loops, if requested
!
      if( idiag(62)==1 ) then
         flux(nfl+1) = sum( flux(:nfl) * flux_comb_coefs(:nfl) )
         title(nfl+1) = 'combined flux loops'
         nfl = nfl + 1
      endif

!
! write fluxdiag.result
!
      open(unit=11,file='diagno_flux.'//id_string,status='unknown' &
     &    ,action='write')
      write(11,'(1p,60e18.10)')(flux(n), n=1,nfl)

      do n=1, nfl
         write(11, '(a)') title(n)
      enddo

      close(unit=11)
!
! do deallocations
!
      deallocate(xfl,yfl,zfl,dx,dy,dz,xmid,ymid,zmid,flux, &
     &    nseg_ar, title, stat=i_alloc)
      if(i_alloc /= 0) stop &
     &    'Deallocation of arrays xlf etc. in fluxdiag failed!'


      contains
!
! Internal subroutine
!
      subroutine write_flux_database_w7as
!! Writes results of flux calculations into a database file,
!! currently: flux.database_highbeta2001
!! for W7-AS

      use constants
      implicit none
      real(rprec) :: cratio, olddia1, newdia1, sc_equi

      open(unit=11,file=trim(fdb_fluxloops),status='old' &
     &    ,action='write',position='append')
      
      write(11,'(60a)',advance='no') id_string(1:len_trim(id_string))
      write(11,'(1pe14.5)',advance='no') current(1)
      cratio = current(2)/current(1)
      write(11,'(1pe14.5)',advance='no') cratio
      cratio = current(3)/current(1)
      write(11,'(1pe14.5)',advance='no') cratio
      cratio = current(4)/current(1)
      write(11,'(1pe14.5)',advance='no') cratio
      cratio = tor_cur/current(1)    !plasma current/I_mod
      write(11,'(1pe14.5)',advance='no') cratio
      write(11,'(1pe14.5)',advance='no') rav
      write(11,'(1p,6e14.5)',advance='no') &
     &               r00min,r00max,z00max,rmidmin,rmidmax,zmidmax
      olddia1 = 14*flux(1)+60*5*flux(2)
      newdia1 = 14*flux(4)+3.56*60*flux(5)+2.66*60*flux(6)
      write(11,'(1p,8e14.5)',advance='no') &
     &            14*flux(1),60*flux(2),60*flux(3),olddia1 &
     &           ,14*flux(4),60*flux(5),60*flux(6),newdia1
      write(11,'(1pe14.5)',advance='no') 9*flux(7)       !diamagn.loop 2
      sc_equi = flux(9)+flux(13)  ! excentric saddle loops
      write(11,'(1p,4e14.5)',advance='no') &
     &               flux(9),flux(13),sc_equi,flux(10)
      write(11,'(1p,2e14.5)',advance='yes') &
     &               flux(14),flux(15)
      close(unit=11)

      end subroutine write_flux_database_w7as

      subroutine write_flux_database_w7x
!! Writes results of flux calculations into a database file,
!! currently: flux.database_w7x
!! for W7-X

      use constants
      implicit none
      real(rprec) :: cratio

      open(unit=11,file=trim(fdb_fluxloops),status='old' &
     &    ,action='write',position='append')
      
      write(11,'(60a)',advance='no') id_string(1:len_trim(id_string))
      write(11,'(1pe14.5)',advance='no') current(1)
      cratio = current(2)/current(1)
      write(11,'(1pe14.5)',advance='no') cratio
      cratio = current(3)/current(1)
      write(11,'(1pe14.5)',advance='no') cratio
      cratio = current(4)/current(1)
      write(11,'(1pe14.5)',advance='no') cratio
      cratio = current(5)/current(1)
      write(11,'(1pe14.5)',advance='no') cratio
      cratio = current(6)/current(1)    !curA/I_1
      write(11,'(1pe14.5)',advance='no') cratio
      cratio = current(7)/current(1)    !curB/I_1
      write(11,'(1pe14.5)',advance='no') cratio
      write(11,'(1pe14.5)',advance='no') rav
      write(11,'(1p,6e14.5)',advance='no') &
     &               r00min,r00max,z00max,rmidmin,rmidmax,zmidmax
      write(11,'(1p,e14.5)',advance='no') flux
      close(unit=11)

      end subroutine write_flux_database_w7x

      end subroutine fluxdiag

EOF
EOC

